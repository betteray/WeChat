// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mm.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mm.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmRoot

@implementation MmRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - MmRoot_FileDescriptor

static GPBFileDescriptor *MmRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - SKBuiltinBuffer_t

@implementation SKBuiltinBuffer_t

@dynamic hasILen, iLen;
@dynamic hasBuffer, buffer;

typedef struct SKBuiltinBuffer_t__storage_ {
  uint32_t _has_storage_[1];
  int32_t iLen;
  NSData *buffer;
} SKBuiltinBuffer_t__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "iLen",
        .dataTypeSpecific.className = NULL,
        .number = SKBuiltinBuffer_t_FieldNumber_ILen,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SKBuiltinBuffer_t__storage_, iLen),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "buffer",
        .dataTypeSpecific.className = NULL,
        .number = SKBuiltinBuffer_t_FieldNumber_Buffer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SKBuiltinBuffer_t__storage_, buffer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SKBuiltinBuffer_t class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SKBuiltinBuffer_t__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SKBuiltinString_t

@implementation SKBuiltinString_t

@dynamic hasString, string;

typedef struct SKBuiltinString_t__storage_ {
  uint32_t _has_storage_[1];
  NSString *string;
} SKBuiltinString_t__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "string",
        .dataTypeSpecific.className = NULL,
        .number = SKBuiltinString_t_FieldNumber_String,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SKBuiltinString_t__storage_, string),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SKBuiltinString_t class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SKBuiltinString_t__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BaseRequest

@implementation BaseRequest

@dynamic hasSessionKey, sessionKey;
@dynamic hasUin, uin;
@dynamic hasDeviceId, deviceId;
@dynamic hasClientVersion, clientVersion;
@dynamic hasDeviceType, deviceType;
@dynamic hasScene, scene;

typedef struct BaseRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t uin;
  int32_t clientVersion;
  int32_t scene;
  NSData *sessionKey;
  NSData *deviceId;
  NSString *deviceType;
} BaseRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionKey",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_SessionKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, sessionKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_Uin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, uin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_DeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_ClientVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, clientVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_DeviceType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_Scene,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, scene),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BaseRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BaseRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\n\000\003\010\000\004\r\000\005\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BaseResponse

@implementation BaseResponse

@dynamic hasRet, ret;
@dynamic hasErrMsg, errMsg;

typedef struct BaseResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  NSString *errMsg;
} BaseResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = BaseResponse_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BaseResponse__storage_, ret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "errMsg",
        .dataTypeSpecific.className = NULL,
        .number = BaseResponse_FieldNumber_ErrMsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BaseResponse__storage_, errMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BaseResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BaseResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLoginQRCodeRequest

@implementation GetLoginQRCodeRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasOpcode, opcode;
@dynamic hasDeviceName, deviceName;
@dynamic hasUserName, userName;
@dynamic hasHardwareExtra, hardwareExtra;
@dynamic hasSoftType, softType;
@dynamic hasExtDevLoginType, extDevLoginType;
@dynamic hasMsgContextPubKey, msgContextPubKey;

typedef struct GetLoginQRCodeRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t opcode;
  int32_t hardwareExtra;
  int32_t extDevLoginType;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *deviceName;
  NSString *userName;
  NSString *softType;
  SKBuiltinBuffer_t *msgContextPubKey;
} GetLoginQRCodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetLoginQRCodeRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_Opcode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, opcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_DeviceName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_UserName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hardwareExtra",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_HardwareExtra,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, hardwareExtra),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "softType",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_SoftType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, softType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extDevLoginType",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_ExtDevLoginType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, extDevLoginType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgContextPubKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeRequest_FieldNumber_MsgContextPubKey,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, msgContextPubKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLoginQRCodeRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLoginQRCodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001\013\000\002\016\000\004\n\000\005\010\000\006\r\000\007\010\000\010\017\000\t\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLoginQRCodeResponse

@implementation GetLoginQRCodeResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasQrcode, qrcode;
@dynamic hasUuid, uuid;
@dynamic hasCheckTime, checkTime;
@dynamic hasNotifyKey, notifyKey;
@dynamic hasExpiredTime, expiredTime;
@dynamic hasBlueToothBroadCastUuid, blueToothBroadCastUuid;
@dynamic hasBlueToothBroadCastContent, blueToothBroadCastContent;

typedef struct GetLoginQRCodeResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t checkTime;
  int32_t expiredTime;
  BaseResponse *baseResponse;
  SKBuiltinBuffer_t *qrcode;
  NSString *uuid;
  SKBuiltinBuffer_t *notifyKey;
  NSString *blueToothBroadCastUuid;
  SKBuiltinBuffer_t *blueToothBroadCastContent;
} GetLoginQRCodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetLoginQRCodeResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "qrcode",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeResponse_FieldNumber_Qrcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, qrcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_Uuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, uuid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checkTime",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_CheckTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, checkTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "notifyKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeResponse_FieldNumber_NotifyKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, notifyKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "expiredTime",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_ExpiredTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, expiredTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blueToothBroadCastUuid",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_BlueToothBroadCastUuid,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, blueToothBroadCastUuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blueToothBroadCastContent",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeResponse_FieldNumber_BlueToothBroadCastContent,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, blueToothBroadCastContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLoginQRCodeResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLoginQRCodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001\014\000\004\t\000\005\t\000\006\013\000\007\026\000\010\031\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckLoginQRCodeRequest

@implementation CheckLoginQRCodeRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasUuid, uuid;
@dynamic hasTimeStamp, timeStamp;
@dynamic hasOpcode, opcode;

typedef struct CheckLoginQRCodeRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t timeStamp;
  int32_t opcode;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *uuid;
} CheckLoginQRCodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = CheckLoginQRCodeRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = CheckLoginQRCodeRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeRequest_FieldNumber_Uuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, uuid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeRequest_FieldNumber_TimeStamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeRequest_FieldNumber_Opcode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, opcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckLoginQRCodeRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckLoginQRCodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\016\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckLoginQRCodeResponse

@implementation CheckLoginQRCodeResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasNotifyPkg, notifyPkg;

typedef struct CheckLoginQRCodeResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg *notifyPkg;
} CheckLoginQRCodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = CheckLoginQRCodeResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notifyPkg",
        .dataTypeSpecific.className = GPBStringifySymbol(CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg),
        .number = CheckLoginQRCodeResponse_FieldNumber_NotifyPkg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse__storage_, notifyPkg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckLoginQRCodeResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckLoginQRCodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\014\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg

@implementation CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg

@dynamic hasNotifyData, notifyData;
@dynamic hasOpcode, opcode;

typedef struct CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_ {
  uint32_t _has_storage_[1];
  int32_t opcode;
  SKBuiltinBuffer_t *notifyData;
} CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notifyData",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg_FieldNumber_NotifyData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_, notifyData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg_FieldNumber_Opcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CheckLoginQRCodeResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NotifyMsg

@implementation NotifyMsg

@dynamic hasUuid, uuid;
@dynamic hasState, state;
@dynamic hasWxid, wxid;
@dynamic hasWxnewpass, wxnewpass;
@dynamic hasAvatar, avatar;
@dynamic hasPushLoginURLExpiredTime, pushLoginURLExpiredTime;
@dynamic hasNickName, nickName;
@dynamic hasEffectiveTime, effectiveTime;
@dynamic hasT10, t10;
@dynamic hasDevices, devices;

typedef struct NotifyMsg__storage_ {
  uint32_t _has_storage_[1];
  int32_t state;
  int32_t pushLoginURLExpiredTime;
  int32_t effectiveTime;
  int32_t t10;
  NSString *uuid;
  NSString *wxid;
  NSString *wxnewpass;
  NSString *avatar;
  NSString *nickName;
  NSString *devices;
} NotifyMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wxid",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Wxid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, wxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wxnewpass",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Wxnewpass,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, wxnewpass),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Avatar,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushLoginURLExpiredTime",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_PushLoginURLExpiredTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, pushLoginURLExpiredTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_NickName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "effectiveTime",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_EffectiveTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, effectiveTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "t10",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_T10,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, t10),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "devices",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Devices,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, devices),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NotifyMsg class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NotifyMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\006\n!,\000\007\010\000\010\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ECDHKey

@implementation ECDHKey

@dynamic hasNid, nid;
@dynamic hasKey, key;

typedef struct ECDHKey__storage_ {
  uint32_t _has_storage_[1];
  int32_t nid;
  SKBuiltinBuffer_t *key;
} ECDHKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nid",
        .dataTypeSpecific.className = NULL,
        .number = ECDHKey_FieldNumber_Nid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ECDHKey__storage_, nid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ECDHKey_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ECDHKey__storage_, key),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ECDHKey class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ECDHKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthRsaReqData

@implementation ManualAuthRsaReqData

@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasCliPubEcdhkey, cliPubEcdhkey;
@dynamic hasUserName, userName;
@dynamic hasPwd, pwd;
@dynamic hasPwd2, pwd2;

typedef struct ManualAuthRsaReqData__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinBuffer_t *randomEncryKey;
  ECDHKey *cliPubEcdhkey;
  NSString *userName;
  NSString *pwd;
  NSString *pwd2;
} ManualAuthRsaReqData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ManualAuthRsaReqData_FieldNumber_RandomEncryKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliPubEcdhkey",
        .dataTypeSpecific.className = GPBStringifySymbol(ECDHKey),
        .number = ManualAuthRsaReqData_FieldNumber_CliPubEcdhkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, cliPubEcdhkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthRsaReqData_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthRsaReqData_FieldNumber_Pwd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, pwd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd2",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthRsaReqData_FieldNumber_Pwd2,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, pwd2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthRsaReqData class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthRsaReqData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\016\000\002\r\000\003\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BaseAuthReqInfo

@implementation BaseAuthReqInfo

@dynamic hasCliDbencryptInfo, cliDbencryptInfo;
@dynamic hasAuthReqFlag, authReqFlag;

typedef struct BaseAuthReqInfo__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinBuffer_t *cliDbencryptInfo;
  NSString *authReqFlag;
} BaseAuthReqInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cliDbencryptInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BaseAuthReqInfo_FieldNumber_CliDbencryptInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, cliDbencryptInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authReqFlag",
        .dataTypeSpecific.className = NULL,
        .number = BaseAuthReqInfo_FieldNumber_AuthReqFlag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, authReqFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BaseAuthReqInfo class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BaseAuthReqInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\005\020\000\007\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthAesReqData

@implementation ManualAuthAesReqData

@dynamic hasBaseRequest, baseRequest;
@dynamic hasBaseReqInfo, baseReqInfo;
@dynamic hasImei, imei;
@dynamic hasSoftType, softType;
@dynamic hasBuiltinIpseq, builtinIpseq;
@dynamic hasClientSeqId, clientSeqId;
@dynamic hasClientSeqIdsign, clientSeqIdsign;
@dynamic hasDeviceName, deviceName;
@dynamic hasDeviceType, deviceType;
@dynamic hasLanguage, language;
@dynamic hasTimeZone, timeZone;
@dynamic hasChannel, channel;
@dynamic hasTimeStamp, timeStamp;
@dynamic hasDeviceBrand, deviceBrand;
@dynamic hasDeviceModel, deviceModel;
@dynamic hasOstype, ostype;
@dynamic hasRealCountry, realCountry;
@dynamic hasBundleId, bundleId;
@dynamic hasAdSource, adSource;
@dynamic hasIphoneVer, iphoneVer;
@dynamic hasInputType, inputType;
@dynamic hasClientCheckData, clientCheckData;

typedef struct ManualAuthAesReqData__storage_ {
  uint32_t _has_storage_[1];
  int32_t builtinIpseq;
  int32_t channel;
  int32_t timeStamp;
  int32_t inputType;
  BaseRequest *baseRequest;
  BaseAuthReqInfo *baseReqInfo;
  NSString *imei;
  NSString *softType;
  NSString *clientSeqId;
  NSString *clientSeqIdsign;
  NSString *deviceName;
  NSString *deviceType;
  NSString *language;
  NSString *timeZone;
  NSString *deviceBrand;
  NSString *deviceModel;
  NSString *ostype;
  NSString *realCountry;
  NSString *bundleId;
  NSString *adSource;
  NSString *iphoneVer;
  SKBuiltinBuffer_t *clientCheckData;
} ManualAuthAesReqData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ManualAuthAesReqData_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "baseReqInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseAuthReqInfo),
        .number = ManualAuthAesReqData_FieldNumber_BaseReqInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, baseReqInfo),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imei",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_Imei,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, imei),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "softType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_SoftType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, softType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIpseq",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_BuiltinIpseq,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, builtinIpseq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_ClientSeqId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientSeqIdsign",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_ClientSeqIdsign,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, clientSeqIdsign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_DeviceName,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_DeviceType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_Language,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, language),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_TimeZone,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_Channel,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, channel),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_TimeStamp,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceBrand",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_DeviceBrand,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, deviceBrand),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModel",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_DeviceModel,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, deviceModel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ostype",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_Ostype,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, ostype),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realCountry",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_RealCountry,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, realCountry),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundleId",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_BundleId,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, bundleId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adSource",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_AdSource,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, adSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iphoneVer",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_IphoneVer,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, iphoneVer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_InputType,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, inputType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientCheckData",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ManualAuthAesReqData_FieldNumber_ClientCheckData,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, clientCheckData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthAesReqData class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthAesReqData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\022\001\013\000\002\013\000\004\010\000\005\014\000\006\013\000\007\nb\003\000\010\n\000\t\n\000\013\010\000\016\t\000\017\013\000\020\013\000\022"
        "\013\000\023\010\000\024\010\000\025\t\000\026\t\000\027\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthRequest

@implementation ManualAuthRequest

@dynamic hasRsaReqData, rsaReqData;
@dynamic hasAesReqData, aesReqData;

typedef struct ManualAuthRequest__storage_ {
  uint32_t _has_storage_[1];
  ManualAuthRsaReqData *rsaReqData;
  ManualAuthAesReqData *aesReqData;
} ManualAuthRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rsaReqData",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthRsaReqData),
        .number = ManualAuthRequest_FieldNumber_RsaReqData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthRequest__storage_, rsaReqData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "aesReqData",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthAesReqData),
        .number = ManualAuthRequest_FieldNumber_AesReqData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthRequest__storage_, aesReqData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkControl

@implementation NetworkControl

@dynamic hasPortList, portList;
@dynamic hasTimeoutList, timeoutList;
@dynamic hasMinNoopInterval, minNoopInterval;
@dynamic hasMaxNoopInterval, maxNoopInterval;
@dynamic hasTypingInterval, typingInterval;
@dynamic hasNoopIntervalTime, noopIntervalTime;

typedef struct NetworkControl__storage_ {
  uint32_t _has_storage_[1];
  int32_t minNoopInterval;
  int32_t maxNoopInterval;
  int32_t typingInterval;
  int32_t noopIntervalTime;
  NSString *portList;
  NSString *timeoutList;
} NetworkControl__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "portList",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_PortList,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, portList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeoutList",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_TimeoutList,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, timeoutList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minNoopInterval",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_MinNoopInterval,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, minNoopInterval),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxNoopInterval",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_MaxNoopInterval,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, maxNoopInterval),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "typingInterval",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_TypingInterval,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, typingInterval),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "noopIntervalTime",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_NoopIntervalTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, noopIntervalTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkControl class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkControl__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001\010\000\002\013\000\003\017\000\004\017\000\005\016\000\007\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BuiltinIPList

@implementation BuiltinIPList

@dynamic hasLongConnectIpcount, longConnectIpcount;
@dynamic hasShortConnectIpcount, shortConnectIpcount;
@dynamic longConnectIplistArray, longConnectIplistArray_Count;
@dynamic shortConnectIplistArray, shortConnectIplistArray_Count;
@dynamic hasSeq, seq;

typedef struct BuiltinIPList__storage_ {
  uint32_t _has_storage_[1];
  int32_t longConnectIpcount;
  int32_t shortConnectIpcount;
  int32_t seq;
  NSMutableArray *longConnectIplistArray;
  NSMutableArray *shortConnectIplistArray;
} BuiltinIPList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "longConnectIpcount",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_FieldNumber_LongConnectIpcount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, longConnectIpcount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "shortConnectIpcount",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_FieldNumber_ShortConnectIpcount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, shortConnectIpcount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "longConnectIplistArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList_BuiltinIP),
        .number = BuiltinIPList_FieldNumber_LongConnectIplistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, longConnectIplistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shortConnectIplistArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList_BuiltinIP),
        .number = BuiltinIPList_FieldNumber_ShortConnectIplistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, shortConnectIplistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "seq",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_FieldNumber_Seq,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, seq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BuiltinIPList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BuiltinIPList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\022\000\002\023\000\003\000longConnectIplist\000\004\000shortConnec"
        "tIplist\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BuiltinIPList_BuiltinIP

@implementation BuiltinIPList_BuiltinIP

@dynamic hasType, type;
@dynamic hasPort, port;
@dynamic hasIp, ip;
@dynamic hasDomain, domain;

typedef struct BuiltinIPList_BuiltinIP__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t port;
  NSString *ip;
  NSString *domain;
} BuiltinIPList_BuiltinIP__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_BuiltinIP_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BuiltinIPList_BuiltinIP__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_BuiltinIP_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BuiltinIPList_BuiltinIP__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_BuiltinIP_FieldNumber_Ip,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BuiltinIPList_BuiltinIP__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domain",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_BuiltinIP_FieldNumber_Domain,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BuiltinIPList_BuiltinIP__storage_, domain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BuiltinIPList_BuiltinIP class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BuiltinIPList_BuiltinIP__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(BuiltinIPList)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse

@implementation UnifyAuthResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasUnifyAuthSectFlag, unifyAuthSectFlag;
@dynamic hasAuthSectResp, authSectResp;
@dynamic hasAcctSectResp, acctSectResp;
@dynamic hasNetworkSectResp, networkSectResp;

typedef struct UnifyAuthResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t unifyAuthSectFlag;
  BaseResponse *baseResponse;
  UnifyAuthResponse_AuthSectResp *authSectResp;
  UnifyAuthResponse_AcctSectResp *acctSectResp;
  UnifyAuthResponse_NetworkSectResp *networkSectResp;
} UnifyAuthResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = UnifyAuthResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unifyAuthSectFlag",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_FieldNumber_UnifyAuthSectFlag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, unifyAuthSectFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "authSectResp",
        .dataTypeSpecific.className = GPBStringifySymbol(UnifyAuthResponse_AuthSectResp),
        .number = UnifyAuthResponse_FieldNumber_AuthSectResp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, authSectResp),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "acctSectResp",
        .dataTypeSpecific.className = GPBStringifySymbol(UnifyAuthResponse_AcctSectResp),
        .number = UnifyAuthResponse_FieldNumber_AcctSectResp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, acctSectResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkSectResp",
        .dataTypeSpecific.className = GPBStringifySymbol(UnifyAuthResponse_NetworkSectResp),
        .number = UnifyAuthResponse_FieldNumber_NetworkSectResp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, networkSectResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\014\000\002\021\000\003\014\000\004\014\000\005\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_AuthSectResp

@implementation UnifyAuthResponse_AuthSectResp

@dynamic hasUin, uin;
@dynamic hasSvrPubEcdhkey, svrPubEcdhkey;
@dynamic hasSessionKey, sessionKey;
@dynamic hasAutoAuthKey, autoAuthKey;
@dynamic hasWtloginRspBuffFlag, wtloginRspBuffFlag;
@dynamic hasShowStyle, showStyle;
@dynamic hasSmsTicket, smsTicket;
@dynamic hasAuthResultFlag, authResultFlag;
@dynamic hasFsurl, fsurl;
@dynamic hasServerTime, serverTime;

typedef struct UnifyAuthResponse_AuthSectResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t uin;
  int32_t wtloginRspBuffFlag;
  int32_t authResultFlag;
  int32_t serverTime;
  ECDHKey *svrPubEcdhkey;
  SKBuiltinBuffer_t *sessionKey;
  SKBuiltinBuffer_t *autoAuthKey;
  UnifyAuthResponse_AuthSectResp_ShowStyleKey *showStyle;
  NSData *smsTicket;
  NSString *fsurl;
} UnifyAuthResponse_AuthSectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_Uin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, uin),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "svrPubEcdhkey",
        .dataTypeSpecific.className = GPBStringifySymbol(ECDHKey),
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_SvrPubEcdhkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, svrPubEcdhkey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sessionKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_SessionKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, sessionKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoAuthKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_AutoAuthKey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, autoAuthKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wtloginRspBuffFlag",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_WtloginRspBuffFlag,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, wtloginRspBuffFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "showStyle",
        .dataTypeSpecific.className = GPBStringifySymbol(UnifyAuthResponse_AuthSectResp_ShowStyleKey),
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_ShowStyle,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, showStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "smsTicket",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_SmsTicket,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, smsTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "authResultFlag",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_AuthResultFlag,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, authResultFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fsurl",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_Fsurl,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, fsurl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serverTime",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_ServerTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, serverTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_AuthSectResp class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_AuthSectResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\002\r\000\003\n\000\004\013\000\005\022\000\017\t\000\020I\000\023\016\000\026\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_AuthSectResp_ShowStyleKey

@implementation UnifyAuthResponse_AuthSectResp_ShowStyleKey

@dynamic hasKeyCount, keyCount;

typedef struct UnifyAuthResponse_AuthSectResp_ShowStyleKey__storage_ {
  uint32_t _has_storage_[1];
  int32_t keyCount;
} UnifyAuthResponse_AuthSectResp_ShowStyleKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyCount",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_ShowStyleKey_FieldNumber_KeyCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp_ShowStyleKey__storage_, keyCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_AuthSectResp_ShowStyleKey class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_AuthSectResp_ShowStyleKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse_AuthSectResp)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal

@implementation UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal

@dynamic hasKey, key;
@dynamic hasVal, val;

typedef struct UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  NSString *val;
} UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "val",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal_FieldNumber_Val,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal__storage_, val),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse_AuthSectResp_ShowStyleKey)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_AcctSectResp

@implementation UnifyAuthResponse_AcctSectResp

@dynamic hasUserName, userName;
@dynamic hasNickName, nickName;
@dynamic hasBindUin, bindUin;
@dynamic hasBindMail, bindMail;
@dynamic hasBindMobile, bindMobile;
@dynamic hasAlias, alias;
@dynamic hasBindEmail, bindEmail;
@dynamic hasStatus, status;
@dynamic hasPluginFlag, pluginFlag;
@dynamic hasRegType, regType;
@dynamic hasDeviceInfoXml, deviceInfoXml;
@dynamic hasSafeDevice, safeDevice;
@dynamic hasOfficialUserName, officialUserName;
@dynamic hasOfficialNickName, officialNickName;
@dynamic hasPushMailStatus, pushMailStatus;
@dynamic hasFsURL, fsURL;

typedef struct UnifyAuthResponse_AcctSectResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t bindUin;
  int32_t status;
  int32_t pluginFlag;
  int32_t regType;
  int32_t safeDevice;
  int32_t pushMailStatus;
  NSString *userName;
  NSString *nickName;
  NSString *bindMail;
  NSString *bindMobile;
  NSString *alias;
  NSString *bindEmail;
  NSString *deviceInfoXml;
  NSString *officialUserName;
  NSString *officialNickName;
  NSString *fsURL;
} UnifyAuthResponse_AcctSectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindUin",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_BindUin,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, bindUin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "bindMail",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_BindMail,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, bindMail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindMobile",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_BindMobile,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, bindMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_Alias,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindEmail",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_BindEmail,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, bindEmail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_Status,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pluginFlag",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_PluginFlag,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, pluginFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "regType",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_RegType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, regType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceInfoXml",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_DeviceInfoXml,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, deviceInfoXml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "safeDevice",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_SafeDevice,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, safeDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "officialUserName",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_OfficialUserName,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, officialUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "officialNickName",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_OfficialNickName,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, officialNickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushMailStatus",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_PushMailStatus,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, pushMailStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fsURL",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_FsURL,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, fsURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_AcctSectResp class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_AcctSectResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\016\001\010\000\002\010\000\003\007\000\004\010\000\005\n\000\007\t\000\t\n\000\n\007\000\013\r\000\014\n\000\r\020\000\016\020\000\017\016\000"
        "\020\003!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_NetworkSectResp

@implementation UnifyAuthResponse_NetworkSectResp

@dynamic hasNewHostList, newHostList;
@dynamic hasNetworkControl, networkControl;
@dynamic hasBuiltinIplist, builtinIplist;

typedef struct UnifyAuthResponse_NetworkSectResp__storage_ {
  uint32_t _has_storage_[1];
  UnifyAuthResponse_NetworkSectResp_HostList *newHostList;
  NetworkControl *networkControl;
  BuiltinIPList *builtinIplist;
} UnifyAuthResponse_NetworkSectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "newHostList",
        .dataTypeSpecific.className = GPBStringifySymbol(UnifyAuthResponse_NetworkSectResp_HostList),
        .number = UnifyAuthResponse_NetworkSectResp_FieldNumber_NewHostList,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp__storage_, newHostList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkControl",
        .dataTypeSpecific.className = GPBStringifySymbol(NetworkControl),
        .number = UnifyAuthResponse_NetworkSectResp_FieldNumber_NetworkControl,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp__storage_, networkControl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "builtinIplist",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList),
        .number = UnifyAuthResponse_NetworkSectResp_FieldNumber_BuiltinIplist,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp__storage_, builtinIplist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_NetworkSectResp class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_NetworkSectResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\016\000\003\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_NetworkSectResp_HostList

@implementation UnifyAuthResponse_NetworkSectResp_HostList

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct UnifyAuthResponse_NetworkSectResp_HostList__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  NSMutableArray *listArray;
} UnifyAuthResponse_NetworkSectResp_HostList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_NetworkSectResp_HostList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp_HostList__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UnifyAuthResponse_NetworkSectResp_HostList_Host),
        .number = UnifyAuthResponse_NetworkSectResp_HostList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp_HostList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_NetworkSectResp_HostList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_NetworkSectResp_HostList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse_NetworkSectResp)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_NetworkSectResp_HostList_Host

@implementation UnifyAuthResponse_NetworkSectResp_HostList_Host

@dynamic hasOrigin, origin;
@dynamic hasSubstitute, substitute;
@dynamic hasPriority, priority;

typedef struct UnifyAuthResponse_NetworkSectResp_HostList_Host__storage_ {
  uint32_t _has_storage_[1];
  int32_t priority;
  NSString *origin;
  NSString *substitute;
} UnifyAuthResponse_NetworkSectResp_HostList_Host__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "origin",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_NetworkSectResp_HostList_Host_FieldNumber_Origin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp_HostList_Host__storage_, origin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "substitute",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_NetworkSectResp_HostList_Host_FieldNumber_Substitute,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp_HostList_Host__storage_, substitute),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priority",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_NetworkSectResp_HostList_Host_FieldNumber_Priority,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp_HostList_Host__storage_, priority),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_NetworkSectResp_HostList_Host class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_NetworkSectResp_HostList_Host__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse_NetworkSectResp_HostList)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewInitRequest

@implementation NewInitRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasCurrentSynckey, currentSynckey;
@dynamic hasMaxSynckey, maxSynckey;
@dynamic hasLanguage, language;

typedef struct NewInitRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *userName;
  NSData *currentSynckey;
  NSData *maxSynckey;
  NSString *language;
} NewInitRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = NewInitRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currentSynckey",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_CurrentSynckey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, currentSynckey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "maxSynckey",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_MaxSynckey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, maxSynckey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_Language,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, language),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewInitRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewInitRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\013\000\002\010\000\003\016\000\004\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Msg

@implementation Msg

@dynamic hasServerid, serverid;
@dynamic hasFromId, fromId;
@dynamic hasToId, toId;
@dynamic hasType, type;
@dynamic hasRaw, raw;
@dynamic hasStatus, status;
@dynamic hasTag7, tag7;
@dynamic hasTag8, tag8;
@dynamic hasCreateTime, createTime;
@dynamic hasExInfo, exInfo;
@dynamic hasXmlContent, xmlContent;
@dynamic hasSvrId, svrId;
@dynamic hasMsgKey, msgKey;

typedef struct Msg__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t status;
  int32_t tag7;
  int32_t createTime;
  int32_t msgKey;
  SKBuiltinString_t *fromId;
  SKBuiltinString_t *toId;
  Msg_RawContent *raw;
  NSData *tag8;
  NSString *exInfo;
  NSString *xmlContent;
  int64_t serverid;
  int64_t svrId;
} Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serverid",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_Serverid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Msg__storage_, serverid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fromId",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = Msg_FieldNumber_FromId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Msg__storage_, fromId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toId",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = Msg_FieldNumber_ToId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Msg__storage_, toId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Msg__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "raw",
        .dataTypeSpecific.className = GPBStringifySymbol(Msg_RawContent),
        .number = Msg_FieldNumber_Raw,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Msg__storage_, raw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Msg__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag7",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_Tag7,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Msg__storage_, tag7),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag8",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_Tag8,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Msg__storage_, tag8),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_CreateTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Msg__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "exInfo",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_ExInfo,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Msg__storage_, exInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "xmlContent",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_XmlContent,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Msg__storage_, xmlContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "svrId",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_SvrId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Msg__storage_, svrId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgKey",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_MsgKey,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Msg__storage_, msgKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Msg class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Msg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\t\n\000\013\n\000\014\005\000\r\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Msg_RawContent

@implementation Msg_RawContent

@dynamic hasContent, content;

typedef struct Msg_RawContent__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
} Msg_RawContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = Msg_RawContent_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Msg_RawContent__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Msg_RawContent class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Msg_RawContent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Msg)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info

@implementation contact_info

@dynamic hasWxid, wxid;
@dynamic hasNickname, nickname;
@dynamic hasShortPy, shortPy;
@dynamic hasQuanpin, quanpin;
@dynamic hasSex, sex;
@dynamic hasTag6, tag6;
@dynamic hasTag7, tag7;
@dynamic hasType, type;
@dynamic hasTag9, tag9;
@dynamic hasRemarkName, remarkName;
@dynamic hasRealShortPy, realShortPy;
@dynamic hasRealQuanpin, realQuanpin;
@dynamic hasTag13, tag13;
@dynamic hasTag14, tag14;
@dynamic hasTag16, tag16;
@dynamic hasBChatRoom, bChatRoom;
@dynamic hasTag18, tag18;
@dynamic hasSheng, sheng;
@dynamic hasShi, shi;
@dynamic hasQianming, qianming;
@dynamic hasTag22, tag22;
@dynamic hasTag23, tag23;
@dynamic hasRegisterBodyType, registerBodyType;
@dynamic hasRegisterBody, registerBody;
@dynamic hasTag26, tag26;
@dynamic hasSrc, src;
@dynamic hasLastMsgTime, lastMsgTime;
@dynamic hasAlias, alias;
@dynamic hasChatroomOwnerWxid, chatroomOwnerWxid;
@dynamic hasTag33, tag33;
@dynamic hasTag34, tag34;
@dynamic hasTag35, tag35;
@dynamic hasTag37, tag37;
@dynamic hasCountry, country;
@dynamic hasAvatarBig, avatarBig;
@dynamic hasAvatarSmall, avatarSmall;
@dynamic hasTag42, tag42;
@dynamic hasV1Name, v1Name;
@dynamic hasTag50, tag50;
@dynamic hasChatroomServerVer, chatroomServerVer;
@dynamic hasChatroomMaxMember, chatroomMaxMember;
@dynamic hasTag56, tag56;
@dynamic hasGroupMemberList, groupMemberList;
@dynamic hasTag58, tag58;
@dynamic hasTag62, tag62;
@dynamic hasTag64, tag64;
@dynamic hasTag65, tag65;
@dynamic hasTag66, tag66;
@dynamic hasTag67, tag67;

typedef struct contact_info__storage_ {
  uint32_t _has_storage_[2];
  int32_t sex;
  int32_t tag7;
  int32_t type;
  int32_t tag9;
  int32_t tag13;
  int32_t tag14;
  int32_t bChatRoom;
  int32_t tag18;
  int32_t tag22;
  int32_t tag23;
  int32_t registerBodyType;
  int32_t tag26;
  int32_t src;
  int32_t tag33;
  int32_t tag34;
  int32_t tag35;
  int32_t chatroomServerVer;
  int32_t chatroomMaxMember;
  int32_t tag56;
  int32_t tag58;
  int32_t tag64;
  int32_t tag65;
  int32_t tag66;
  int32_t tag67;
  SKBuiltinString_t *wxid;
  contact_info_NickName *nickname;
  contact_info_PY_SHORT *shortPy;
  contact_info_QuanPin *quanpin;
  NSString *tag6;
  contact_info_BeiZhu *remarkName;
  contact_info_REAL_PY_SHORT *realShortPy;
  contact_info_REAL_QuanPin *realQuanpin;
  NSString *tag16;
  NSString *sheng;
  NSString *shi;
  NSString *qianming;
  NSString *registerBody;
  NSString *lastMsgTime;
  NSString *alias;
  NSString *chatroomOwnerWxid;
  NSData *tag37;
  NSString *country;
  NSString *avatarBig;
  NSString *avatarSmall;
  NSData *tag42;
  NSString *v1Name;
  NSData *tag50;
  contact_info_GroupMemberList *groupMemberList;
  NSData *tag62;
} contact_info__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wxid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = contact_info_FieldNumber_Wxid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info__storage_, wxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_NickName),
        .number = contact_info_FieldNumber_Nickname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(contact_info__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shortPy",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_PY_SHORT),
        .number = contact_info_FieldNumber_ShortPy,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(contact_info__storage_, shortPy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "quanpin",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_QuanPin),
        .number = contact_info_FieldNumber_Quanpin,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(contact_info__storage_, quanpin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(contact_info__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag6",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag6,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag7",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag7,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag7),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Type,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(contact_info__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag9",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag9,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag9),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remarkName",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_BeiZhu),
        .number = contact_info_FieldNumber_RemarkName,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(contact_info__storage_, remarkName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "realShortPy",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_REAL_PY_SHORT),
        .number = contact_info_FieldNumber_RealShortPy,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(contact_info__storage_, realShortPy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "realQuanpin",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_REAL_QuanPin),
        .number = contact_info_FieldNumber_RealQuanpin,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(contact_info__storage_, realQuanpin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tag13",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag13,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag13),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag14",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag14,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag14),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag16",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag16,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag16),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bChatRoom",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_BChatRoom,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(contact_info__storage_, bChatRoom),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag18",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag18,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag18),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sheng",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Sheng,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(contact_info__storage_, sheng),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shi",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Shi,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(contact_info__storage_, shi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qianming",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Qianming,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(contact_info__storage_, qianming),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag22",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag22,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag22),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag23",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag23,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag23),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "registerBodyType",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_RegisterBodyType,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(contact_info__storage_, registerBodyType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "registerBody",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_RegisterBody,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(contact_info__storage_, registerBody),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag26",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag26,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag26),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "src",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Src,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(contact_info__storage_, src),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastMsgTime",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_LastMsgTime,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(contact_info__storage_, lastMsgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Alias,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(contact_info__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatroomOwnerWxid",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_ChatroomOwnerWxid,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(contact_info__storage_, chatroomOwnerWxid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag33",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag33,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag33),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag34",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag34,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag34),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag35",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag35,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag35),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag37",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag37,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag37),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Country,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(contact_info__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarBig",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_AvatarBig,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(contact_info__storage_, avatarBig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarSmall",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_AvatarSmall,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(contact_info__storage_, avatarSmall),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag42",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag42,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag42),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "v1Name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_V1Name,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(contact_info__storage_, v1Name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag50",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag50,
        .hasIndex = 38,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag50),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "chatroomServerVer",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_ChatroomServerVer,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(contact_info__storage_, chatroomServerVer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "chatroomMaxMember",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_ChatroomMaxMember,
        .hasIndex = 40,
        .offset = (uint32_t)offsetof(contact_info__storage_, chatroomMaxMember),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag56",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag56,
        .hasIndex = 41,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag56),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "groupMemberList",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_GroupMemberList),
        .number = contact_info_FieldNumber_GroupMemberList,
        .hasIndex = 42,
        .offset = (uint32_t)offsetof(contact_info__storage_, groupMemberList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tag58",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag58,
        .hasIndex = 43,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag58),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag62",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag62,
        .hasIndex = 44,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag62),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag64",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag64,
        .hasIndex = 45,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag65",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag65,
        .hasIndex = 46,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag65),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag66",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag66,
        .hasIndex = 47,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag66),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag67",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag67,
        .hasIndex = 48,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag67),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\003\007\000\013\004\247\000\021\t\000\035\013\000\037\021\0005\010\251\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_NickName

@implementation contact_info_NickName

@dynamic hasName, name;

typedef struct contact_info_NickName__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} contact_info_NickName__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_NickName_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_NickName__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_NickName class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_NickName__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_PY_SHORT

@implementation contact_info_PY_SHORT

@dynamic hasName, name;

typedef struct contact_info_PY_SHORT__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} contact_info_PY_SHORT__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_PY_SHORT_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_PY_SHORT__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_PY_SHORT class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_PY_SHORT__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_QuanPin

@implementation contact_info_QuanPin

@dynamic hasName, name;

typedef struct contact_info_QuanPin__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} contact_info_QuanPin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_QuanPin_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_QuanPin__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_QuanPin class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_QuanPin__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_BeiZhu

@implementation contact_info_BeiZhu

@dynamic hasName, name;

typedef struct contact_info_BeiZhu__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} contact_info_BeiZhu__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_BeiZhu_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_BeiZhu__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_BeiZhu class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_BeiZhu__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_REAL_PY_SHORT

@implementation contact_info_REAL_PY_SHORT

@dynamic hasName, name;

typedef struct contact_info_REAL_PY_SHORT__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} contact_info_REAL_PY_SHORT__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_REAL_PY_SHORT_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_REAL_PY_SHORT__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_REAL_PY_SHORT class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_REAL_PY_SHORT__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_REAL_QuanPin

@implementation contact_info_REAL_QuanPin

@dynamic hasName, name;

typedef struct contact_info_REAL_QuanPin__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} contact_info_REAL_QuanPin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_REAL_QuanPin_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_REAL_QuanPin__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_REAL_QuanPin class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_REAL_QuanPin__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_GroupMemberList

@implementation contact_info_GroupMemberList

@dynamic hasCnt, cnt;
@dynamic memberArray, memberArray_Count;
@dynamic hasTag3, tag3;
@dynamic hasTag4, tag4;

typedef struct contact_info_GroupMemberList__storage_ {
  uint32_t _has_storage_[1];
  int32_t cnt;
  int32_t tag3;
  NSMutableArray *memberArray;
  NSString *tag4;
} contact_info_GroupMemberList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cnt",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_FieldNumber_Cnt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList__storage_, cnt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "memberArray",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_GroupMemberList_MemberInfo),
        .number = contact_info_GroupMemberList_FieldNumber_MemberArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList__storage_, memberArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tag3",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_FieldNumber_Tag3,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList__storage_, tag3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag4",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_FieldNumber_Tag4,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList__storage_, tag4),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_GroupMemberList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_GroupMemberList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_GroupMemberList_MemberInfo

@implementation contact_info_GroupMemberList_MemberInfo

@dynamic hasWxid, wxid;
@dynamic hasNickName, nickName;
@dynamic hasTag6, tag6;
@dynamic hasInviteerWxid, inviteerWxid;
@dynamic hasTag8, tag8;

typedef struct contact_info_GroupMemberList_MemberInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t tag6;
  int32_t tag8;
  NSString *wxid;
  NSString *nickName;
  NSString *inviteerWxid;
} contact_info_GroupMemberList_MemberInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wxid",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_MemberInfo_FieldNumber_Wxid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList_MemberInfo__storage_, wxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_MemberInfo_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList_MemberInfo__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag6",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_MemberInfo_FieldNumber_Tag6,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList_MemberInfo__storage_, tag6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "inviteerWxid",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_MemberInfo_FieldNumber_InviteerWxid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList_MemberInfo__storage_, inviteerWxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag8",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_MemberInfo_FieldNumber_Tag8,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList_MemberInfo__storage_, tag8),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_GroupMemberList_MemberInfo class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_GroupMemberList_MemberInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info_GroupMemberList)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CmdItem

@implementation CmdItem

@dynamic hasCmdId, cmdId;
@dynamic hasCmdBuf, cmdBuf;

typedef struct CmdItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t cmdId;
  SKBuiltinBuffer_t *cmdBuf;
} CmdItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cmdId",
        .dataTypeSpecific.className = NULL,
        .number = CmdItem_FieldNumber_CmdId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CmdItem__storage_, cmdId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cmdBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = CmdItem_FieldNumber_CmdBuf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CmdItem__storage_, cmdBuf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CmdItem class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CmdItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\005\000\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewInitResponse

@implementation NewInitResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCurrentSynckey, currentSynckey;
@dynamic hasMaxSynckey, maxSynckey;
@dynamic hasContinueFlag, continueFlag;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct NewInitResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t continueFlag;
  int32_t count;
  BaseResponse *baseResponse;
  NSData *currentSynckey;
  NSData *maxSynckey;
  NSMutableArray *listArray;
} NewInitResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = NewInitResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "currentSynckey",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_CurrentSynckey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, currentSynckey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "maxSynckey",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_MaxSynckey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, maxSynckey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "continueFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_ContinueFlag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, continueFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_Count,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdItem),
        .number = NewInitResponse_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewInitResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewInitResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\014\000\002\016\000\003\n\000\004\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewSyncRequest

@implementation NewSyncRequest

@dynamic hasOplog, oplog;
@dynamic hasSelector, selector;
@dynamic hasKeyBuf, keyBuf;
@dynamic hasScene, scene;
@dynamic hasDeviceType, deviceType;
@dynamic hasSyncMsgDigest, syncMsgDigest;

typedef struct NewSyncRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t selector;
  int32_t scene;
  int32_t syncMsgDigest;
  NSString *oplog;
  NSData *keyBuf;
  NSString *deviceType;
} NewSyncRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oplog",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_Oplog,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, oplog),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selector",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_Selector,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, selector),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "keyBuf",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_KeyBuf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, keyBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, scene),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_DeviceType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "syncMsgDigest",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_SyncMsgDigest,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, syncMsgDigest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewSyncRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewSyncRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\006\000\005\n\000\006\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewSyncResponse

@implementation NewSyncResponse

@dynamic hasRet, ret;
@dynamic hasCmdList, cmdList;
@dynamic hasContinueFlag, continueFlag;
@dynamic hasKeyBuf, keyBuf;
@dynamic hasStatus, status;
@dynamic hasOnlineVersion, onlineVersion;
@dynamic hasSvrTime, svrTime;

typedef struct NewSyncResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  int32_t continueFlag;
  int32_t status;
  int32_t onlineVersion;
  int32_t svrTime;
  NewSyncResponse_CmdList *cmdList;
  NSData *keyBuf;
} NewSyncResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, ret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cmdList",
        .dataTypeSpecific.className = GPBStringifySymbol(NewSyncResponse_CmdList),
        .number = NewSyncResponse_FieldNumber_CmdList,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, cmdList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "continueFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_ContinueFlag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, continueFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "keyBuf",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_KeyBuf,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, keyBuf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "onlineVersion",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_OnlineVersion,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, onlineVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "svrTime",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_SvrTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, svrTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewSyncResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewSyncResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\002\007\000\003\014\000\004\006\000\006\r\000\007\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewSyncResponse_CmdList

@implementation NewSyncResponse_CmdList

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct NewSyncResponse_CmdList__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  NSMutableArray *listArray;
} NewSyncResponse_CmdList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_CmdList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewSyncResponse_CmdList__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdItem),
        .number = NewSyncResponse_CmdList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NewSyncResponse_CmdList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewSyncResponse_CmdList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewSyncResponse_CmdList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(NewSyncResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MicroMsgRequestNew

@implementation MicroMsgRequestNew

@dynamic hasToUserName, toUserName;
@dynamic hasContent, content;
@dynamic hasType, type;
@dynamic hasCreateTime, createTime;
@dynamic hasClientMsgId, clientMsgId;
@dynamic hasMsgSource, msgSource;

typedef struct MicroMsgRequestNew__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t createTime;
  SKBuiltinString_t *toUserName;
  NSString *content;
  NSString *msgSource;
  int64_t clientMsgId;
} MicroMsgRequestNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "toUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MicroMsgRequestNew_FieldNumber_ToUserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, toUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientMsgId",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_ClientMsgId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, clientMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSource",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_MsgSource,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, msgSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MicroMsgRequestNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MicroMsgRequestNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\n\000\004\n\000\005\013\000\006\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMsgRequestNew

@implementation SendMsgRequestNew

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct SendMsgRequestNew__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  NSMutableArray *listArray;
} SendMsgRequestNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = SendMsgRequestNew_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMsgRequestNew__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MicroMsgRequestNew),
        .number = SendMsgRequestNew_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendMsgRequestNew__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMsgRequestNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMsgRequestNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MicroMsgResponseNew

@implementation MicroMsgResponseNew

@dynamic hasRet, ret;
@dynamic hasToUserName, toUserName;
@dynamic hasMsgId, msgId;
@dynamic hasClientMsgId, clientMsgId;
@dynamic hasCreateTime, createTime;
@dynamic hasServerTime, serverTime;
@dynamic hasType, type;
@dynamic hasNewMsgId, newMsgId;

typedef struct MicroMsgResponseNew__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  int32_t msgId;
  int32_t clientMsgId;
  int32_t createTime;
  int32_t serverTime;
  int32_t type;
  SKBuiltinString_t *toUserName;
  int64_t newMsgId;
} MicroMsgResponseNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, ret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "toUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MicroMsgResponseNew_FieldNumber_ToUserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, toUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientMsgId",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_ClientMsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, clientMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_CreateTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "serverTime",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_ServerTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, serverTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_Type,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "newMsgId",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_NewMsgId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, newMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MicroMsgResponseNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MicroMsgResponseNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\002\n\000\003\005\000\004\013\000\005\n\000\006\n\000\010\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMsgResponseNew

@implementation SendMsgResponseNew

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct SendMsgResponseNew__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  BaseResponse *baseResponse;
  NSMutableArray *listArray;
} SendMsgResponseNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = SendMsgResponseNew_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMsgResponseNew__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = SendMsgResponseNew_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendMsgResponseNew__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MicroMsgResponseNew),
        .number = SendMsgResponseNew_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendMsgResponseNew__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMsgResponseNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMsgResponseNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckResUpdateRequest

@implementation CheckResUpdateRequest

@dynamic resIdArray, resIdArray_Count;

typedef struct CheckResUpdateRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *resIdArray;
} CheckResUpdateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resIdArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CheckResUpdateRequest_ResID),
        .number = CheckResUpdateRequest_FieldNumber_ResIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest__storage_, resIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckResUpdateRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckResUpdateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000resId\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckResUpdateRequest_ResID

@implementation CheckResUpdateRequest_ResID

@dynamic hasType, type;
@dynamic subTypeVectorArray, subTypeVectorArray_Count;

typedef struct CheckResUpdateRequest_ResID__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSMutableArray *subTypeVectorArray;
} CheckResUpdateRequest_ResID__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subTypeVectorArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CheckResUpdateRequest_ResID_SubTypeVector),
        .number = CheckResUpdateRequest_ResID_FieldNumber_SubTypeVectorArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID__storage_, subTypeVectorArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckResUpdateRequest_ResID class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckResUpdateRequest_ResID__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000subTypeVector\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CheckResUpdateRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckResUpdateRequest_ResID_SubTypeVector

@implementation CheckResUpdateRequest_ResID_SubTypeVector

@dynamic hasSubType, subType;
@dynamic hasKeyVersion, keyVersion;
@dynamic hasResVersion, resVersion;
@dynamic hasEid, eid;

typedef struct CheckResUpdateRequest_ResID_SubTypeVector__storage_ {
  uint32_t _has_storage_[1];
  int32_t subType;
  int32_t keyVersion;
  int32_t resVersion;
  int32_t eid;
} CheckResUpdateRequest_ResID_SubTypeVector__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subType",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_SubTypeVector_FieldNumber_SubType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID_SubTypeVector__storage_, subType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "keyVersion",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_SubTypeVector_FieldNumber_KeyVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID_SubTypeVector__storage_, keyVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "resVersion",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_SubTypeVector_FieldNumber_ResVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID_SubTypeVector__storage_, resVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "eid",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_SubTypeVector_FieldNumber_Eid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID_SubTypeVector__storage_, eid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckResUpdateRequest_ResID_SubTypeVector class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckResUpdateRequest_ResID_SubTypeVector__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\007\000\002\n\000\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CheckResUpdateRequest_ResID)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsObject

@implementation SnsObject

@dynamic hasId_p, id_p;
@dynamic hasUsername, username;
@dynamic hasNickname, nickname;
@dynamic hasCreateTime, createTime;
@dynamic hasObjectDesc, objectDesc;
@dynamic hasExtFlag, extFlag;
@dynamic hasObjectOperations, objectOperations;

typedef struct SnsObject__storage_ {
  uint32_t _has_storage_[1];
  int32_t createTime;
  int32_t extFlag;
  NSString *username;
  NSString *nickname;
  SKBuiltinBuffer_t *objectDesc;
  SKBuiltinString_t *objectOperations;
  uint64_t id_p;
} SnsObject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsObject__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_Username,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsObject__storage_, username),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_Nickname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SnsObject__storage_, nickname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SnsObject__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "objectDesc",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = SnsObject_FieldNumber_ObjectDesc,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SnsObject__storage_, objectDesc),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extFlag",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_ExtFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SnsObject__storage_, extFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "objectOperations",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = SnsObject_FieldNumber_ObjectOperations,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SnsObject__storage_, objectOperations),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsObject class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsObject__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\004\n\000\005\n\000\020\007\000\034\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsTimeLineRequest

@implementation SnsTimeLineRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasFirstPageMd5, firstPageMd5;
@dynamic hasMinFilterId, minFilterId;
@dynamic hasMaxId, maxId;
@dynamic hasLastRequestTime, lastRequestTime;
@dynamic hasClientLatestId, clientLatestId;
@dynamic hasSession, session;
@dynamic hasNetworkType, networkType;
@dynamic hasAdexpinfo, adexpinfo;

typedef struct SnsTimeLineRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t minFilterId;
  int32_t maxId;
  int32_t lastRequestTime;
  int32_t networkType;
  BaseRequest *baseRequest;
  NSString *firstPageMd5;
  SKBuiltinBuffer_t *session;
  NSString *adexpinfo;
  int64_t clientLatestId;
} SnsTimeLineRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = SnsTimeLineRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "firstPageMd5",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_FirstPageMd5,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, firstPageMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minFilterId",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_MinFilterId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, minFilterId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxId",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_MaxId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, maxId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastRequestTime",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_LastRequestTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, lastRequestTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientLatestId",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_ClientLatestId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, clientLatestId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = SnsTimeLineRequest_FieldNumber_Session,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkType",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_NetworkType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, networkType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "adexpinfo",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_Adexpinfo,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, adexpinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsTimeLineRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsTimeLineRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\013\000\002\014\000\003\013\000\004\005\000\005\017\000\006\016\000\010\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsTimeLineResponse

@implementation SnsTimeLineResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasFirstPageMd5, firstPageMd5;
@dynamic hasObjectCount, objectCount;
@dynamic objectListArray, objectListArray_Count;
@dynamic hasNewRequestTime, newRequestTime;
@dynamic hasObjectCountForSameMd5, objectCountForSameMd5;
@dynamic hasControlFlag, controlFlag;
@dynamic hasServerConfig, serverConfig;
@dynamic hasRecCount, recCount;
@dynamic hasSession, session;

typedef struct SnsTimeLineResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t objectCount;
  int32_t newRequestTime;
  int32_t objectCountForSameMd5;
  int32_t controlFlag;
  int32_t recCount;
  BaseResponse *baseResponse;
  NSString *firstPageMd5;
  NSMutableArray *objectListArray;
  SnsTimeLineResponse_SnsServerConfig *serverConfig;
  NSData *session;
} SnsTimeLineResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = SnsTimeLineResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "firstPageMd5",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_FirstPageMd5,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, firstPageMd5),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "objectCount",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_ObjectCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, objectCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "objectListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SnsObject),
        .number = SnsTimeLineResponse_FieldNumber_ObjectListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, objectListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newRequestTime",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_NewRequestTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, newRequestTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "objectCountForSameMd5",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_ObjectCountForSameMd5,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, objectCountForSameMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "controlFlag",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_ControlFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, controlFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "serverConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(SnsTimeLineResponse_SnsServerConfig),
        .number = SnsTimeLineResponse_FieldNumber_ServerConfig,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, serverConfig),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recCount",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_RecCount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, recCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_Session,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsTimeLineResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsTimeLineResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001\014\000\002\014\000\003\013\000\004\000objectList\000\005\016\000\006\025\000\007\013\000\010\014\000\t\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsTimeLineResponse_SnsServerConfig

@implementation SnsTimeLineResponse_SnsServerConfig

@dynamic hasPostMentionLimit, postMentionLimit;
@dynamic hasCopyAndPasteWordLimit, copyAndPasteWordLimit;

typedef struct SnsTimeLineResponse_SnsServerConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t postMentionLimit;
  int32_t copyAndPasteWordLimit;
} SnsTimeLineResponse_SnsServerConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "postMentionLimit",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_SnsServerConfig_FieldNumber_PostMentionLimit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse_SnsServerConfig__storage_, postMentionLimit),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "copyAndPasteWordLimit",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_SnsServerConfig_FieldNumber_CopyAndPasteWordLimit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse_SnsServerConfig__storage_, copyAndPasteWordLimit),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsTimeLineResponse_SnsServerConfig class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsTimeLineResponse_SnsServerConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\020\000\002\025\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SnsTimeLineResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindOpMobileRequest

@implementation BindOpMobileRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasMobile, mobile;
@dynamic hasOpcode, opcode;
@dynamic hasVerifycode, verifycode;
@dynamic hasDialFlag, dialFlag;
@dynamic hasDialLang, dialLang;
@dynamic hasAuthTicket, authTicket;
@dynamic hasForceReg, forceReg;
@dynamic hasSafeDeviceName, safeDeviceName;
@dynamic hasSafeDeviceType, safeDeviceType;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasLanguage, language;
@dynamic hasInputMobileRetrys, inputMobileRetrys;
@dynamic hasAdjustRet, adjustRet;
@dynamic hasClientSeqId, clientSeqId;
@dynamic hasMobileCheckType, mobileCheckType;
@dynamic hasUnkownString18, unkownString18;
@dynamic hasExtSpamInfo, extSpamInfo;

typedef struct BindOpMobileRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t opcode;
  int32_t dialFlag;
  int32_t forceReg;
  int32_t inputMobileRetrys;
  int32_t adjustRet;
  int32_t mobileCheckType;
  BaseRequest *baseRequest;
  NSString *userName;
  NSString *mobile;
  NSString *verifycode;
  NSString *dialLang;
  NSString *authTicket;
  NSString *safeDeviceName;
  NSString *safeDeviceType;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *language;
  NSString *clientSeqId;
  NSString *unkownString18;
  SKBuiltinBuffer_t *extSpamInfo;
} BindOpMobileRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BindOpMobileRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobile",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_Mobile,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, mobile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_Opcode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, opcode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "verifycode",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_Verifycode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, verifycode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dialFlag",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_DialFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, dialFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dialLang",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_DialLang,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, dialLang),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_AuthTicket,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, authTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "forceReg",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_ForceReg,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, forceReg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "safeDeviceName",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_SafeDeviceName,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, safeDeviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "safeDeviceType",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_SafeDeviceType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, safeDeviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindOpMobileRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_Language,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputMobileRetrys",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_InputMobileRetrys,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, inputMobileRetrys),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "adjustRet",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_AdjustRet,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, adjustRet),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_ClientSeqId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobileCheckType",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_MobileCheckType,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, mobileCheckType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "unkownString18",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_UnkownString18,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, unkownString18),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extSpamInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindOpMobileRequest_FieldNumber_ExtSpamInfo,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, extSpamInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindOpMobileRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindOpMobileRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\017\001\013\000\002\010\000\006\010\000\007\010\000\010\n\000\t\010\000\n\016\000\013\016\000\014\016\000\016\021\000\017\t\000\020\013\000\021\017\000"
        "\022\016\000\024\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindOpMobileResponse

@implementation BindOpMobileResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasTicket, ticket;
@dynamic hasSmsNo, smsNo;
@dynamic hasNeedSetPwd, needSetPwd;
@dynamic hasPwd, pwd;
@dynamic hasUsername, username;
@dynamic hasBuiltinIplist, builtinIplist;
@dynamic hasNewHostList, newHostList;
@dynamic hasNetworkControl, networkControl;
@dynamic hasAuthTicket, authTicket;
@dynamic hasSafeDevice, safeDevice;
@dynamic hasCc, cc;
@dynamic hasObsoleteItem1, obsoleteItem1;
@dynamic hasSafeDeviceList, safeDeviceList;
@dynamic hasPureMobile, pureMobile;
@dynamic hasFormatedMobile, formatedMobile;
@dynamic hasShowStyle, showStyle;
@dynamic hasMmtlsControlBitFlag, mmtlsControlBitFlag;
@dynamic hasSmsUpCode, smsUpCode;
@dynamic hasSmsUpMobile, smsUpMobile;
@dynamic hasMobileCheckType, mobileCheckType;
@dynamic hasRegSessionId, regSessionId;

typedef struct BindOpMobileResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t needSetPwd;
  int32_t safeDevice;
  int32_t obsoleteItem1;
  int32_t mmtlsControlBitFlag;
  int32_t mobileCheckType;
  BaseResponse *baseResponse;
  NSString *ticket;
  NSString *smsNo;
  NSString *pwd;
  NSString *username;
  BindOpMobileResponse_NewHostList *newHostList;
  BuiltinIPList *builtinIplist;
  NetworkControl *networkControl;
  NSString *authTicket;
  NSString *cc;
  BindOpMobileResponse_SafeDeviceList *safeDeviceList;
  NSString *pureMobile;
  NSString *formatedMobile;
  BindOpMobileResponse_ShowStyle *showStyle;
  NSString *smsUpCode;
  NSString *smsUpMobile;
  NSString *regSessionId;
} BindOpMobileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BindOpMobileResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_Ticket,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, ticket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smsNo",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_SmsNo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, smsNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "needSetPwd",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_NeedSetPwd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, needSetPwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_Pwd,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, pwd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_Username,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newHostList",
        .dataTypeSpecific.className = GPBStringifySymbol(BindOpMobileResponse_NewHostList),
        .number = BindOpMobileResponse_FieldNumber_NewHostList,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, newHostList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "builtinIplist",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList),
        .number = BindOpMobileResponse_FieldNumber_BuiltinIplist,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, builtinIplist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkControl",
        .dataTypeSpecific.className = GPBStringifySymbol(NetworkControl),
        .number = BindOpMobileResponse_FieldNumber_NetworkControl,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, networkControl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_AuthTicket,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, authTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "safeDevice",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_SafeDevice,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, safeDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cc",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_Cc,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, cc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "obsoleteItem1",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_ObsoleteItem1,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, obsoleteItem1),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "safeDeviceList",
        .dataTypeSpecific.className = GPBStringifySymbol(BindOpMobileResponse_SafeDeviceList),
        .number = BindOpMobileResponse_FieldNumber_SafeDeviceList,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, safeDeviceList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pureMobile",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_PureMobile,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, pureMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "formatedMobile",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_FormatedMobile,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, formatedMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "showStyle",
        .dataTypeSpecific.className = GPBStringifySymbol(BindOpMobileResponse_ShowStyle),
        .number = BindOpMobileResponse_FieldNumber_ShowStyle,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, showStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mmtlsControlBitFlag",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_MmtlsControlBitFlag,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, mmtlsControlBitFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "smsUpCode",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_SmsUpCode,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, smsUpCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smsUpMobile",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_SmsUpMobile,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, smsUpMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobileCheckType",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_MobileCheckType,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, mobileCheckType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "regSessionId",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_RegSessionId,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, regSessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindOpMobileResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindOpMobileResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\022\001\014\000\003\005\000\004\n\000\007\013\000\010\r\000\t\016\000\n\n\000\013\n\000\r\r\000\016\016\000\017\n\000\020\016\000\021\t\000"
        "\022\023\000\023\t\000\024\013\000\025\017\000\026\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindOpMobileResponse_NewHostList

@implementation BindOpMobileResponse_NewHostList

@dynamic hasCount, count;

typedef struct BindOpMobileResponse_NewHostList__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
} BindOpMobileResponse_NewHostList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_NewHostList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindOpMobileResponse_NewHostList__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindOpMobileResponse_NewHostList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindOpMobileResponse_NewHostList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(BindOpMobileResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindOpMobileResponse_SafeDeviceList

@implementation BindOpMobileResponse_SafeDeviceList

@dynamic hasCount, count;

typedef struct BindOpMobileResponse_SafeDeviceList__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
} BindOpMobileResponse_SafeDeviceList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_SafeDeviceList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindOpMobileResponse_SafeDeviceList__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindOpMobileResponse_SafeDeviceList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindOpMobileResponse_SafeDeviceList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(BindOpMobileResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindOpMobileResponse_ShowStyle

@implementation BindOpMobileResponse_ShowStyle

@dynamic hasKeyCount, keyCount;

typedef struct BindOpMobileResponse_ShowStyle__storage_ {
  uint32_t _has_storage_[1];
  int32_t keyCount;
} BindOpMobileResponse_ShowStyle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyCount",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_ShowStyle_FieldNumber_KeyCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindOpMobileResponse_ShowStyle__storage_, keyCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindOpMobileResponse_ShowStyle class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindOpMobileResponse_ShowStyle__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(BindOpMobileResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
