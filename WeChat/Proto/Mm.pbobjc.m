// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mm.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mm.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmRoot

@implementation MmRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - MmRoot_FileDescriptor

static GPBFileDescriptor *MmRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - SKBuiltinBuffer_t

@implementation SKBuiltinBuffer_t

@dynamic hasILen, iLen;
@dynamic hasBuffer, buffer;

typedef struct SKBuiltinBuffer_t__storage_ {
  uint32_t _has_storage_[1];
  uint32_t iLen;
  NSData *buffer;
} SKBuiltinBuffer_t__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "iLen",
        .dataTypeSpecific.className = NULL,
        .number = SKBuiltinBuffer_t_FieldNumber_ILen,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SKBuiltinBuffer_t__storage_, iLen),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "buffer",
        .dataTypeSpecific.className = NULL,
        .number = SKBuiltinBuffer_t_FieldNumber_Buffer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SKBuiltinBuffer_t__storage_, buffer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SKBuiltinBuffer_t class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SKBuiltinBuffer_t__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SKBuiltinString_t

@implementation SKBuiltinString_t

@dynamic hasString, string;

typedef struct SKBuiltinString_t__storage_ {
  uint32_t _has_storage_[1];
  NSString *string;
} SKBuiltinString_t__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "string",
        .dataTypeSpecific.className = NULL,
        .number = SKBuiltinString_t_FieldNumber_String,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SKBuiltinString_t__storage_, string),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SKBuiltinString_t class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SKBuiltinString_t__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BaseRequest

@implementation BaseRequest

@dynamic hasSessionKey, sessionKey;
@dynamic hasUin, uin;
@dynamic hasDeviceId, deviceId;
@dynamic hasClientVersion, clientVersion;
@dynamic hasDeviceType, deviceType;
@dynamic hasScene, scene;

typedef struct BaseRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t uin;
  uint32_t clientVersion;
  uint32_t scene;
  NSData *sessionKey;
  NSData *deviceId;
  NSData *deviceType;
} BaseRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionKey",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_SessionKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, sessionKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_Uin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, uin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_DeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_ClientVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, clientVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_DeviceType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_Scene,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, scene),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BaseRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BaseRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\n\000\003\010\000\004\r\000\005\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BaseResponse

@implementation BaseResponse

@dynamic hasRet, ret;
@dynamic hasErrMsg, errMsg;

typedef struct BaseResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  SKBuiltinString_t *errMsg;
} BaseResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = BaseResponse_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BaseResponse__storage_, ret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "errMsg",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = BaseResponse_FieldNumber_ErrMsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BaseResponse__storage_, errMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BaseResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BaseResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLoginQRCodeRequest

@implementation GetLoginQRCodeRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasOpcode, opcode;
@dynamic hasDeviceName, deviceName;
@dynamic hasUserName, userName;
@dynamic hasHardwareExtra, hardwareExtra;
@dynamic hasSoftType, softType;
@dynamic hasExtDevLoginType, extDevLoginType;
@dynamic hasMsgContextPubKey, msgContextPubKey;

typedef struct GetLoginQRCodeRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t opcode;
  int32_t hardwareExtra;
  int32_t extDevLoginType;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *deviceName;
  NSString *userName;
  NSString *softType;
  SKBuiltinBuffer_t *msgContextPubKey;
} GetLoginQRCodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetLoginQRCodeRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_Opcode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, opcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_DeviceName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_UserName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hardwareExtra",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_HardwareExtra,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, hardwareExtra),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "softType",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_SoftType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, softType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extDevLoginType",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_ExtDevLoginType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, extDevLoginType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgContextPubKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeRequest_FieldNumber_MsgContextPubKey,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, msgContextPubKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLoginQRCodeRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLoginQRCodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001\013\000\002\016\000\004\n\000\005\010\000\006\r\000\007\010\000\010\017\000\t\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLoginQRCodeResponse

@implementation GetLoginQRCodeResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasQrcode, qrcode;
@dynamic hasUuid, uuid;
@dynamic hasCheckTime, checkTime;
@dynamic hasNotifyKey, notifyKey;
@dynamic hasExpiredTime, expiredTime;
@dynamic hasBlueToothBroadCastUuid, blueToothBroadCastUuid;
@dynamic hasBlueToothBroadCastContent, blueToothBroadCastContent;

typedef struct GetLoginQRCodeResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t checkTime;
  int32_t expiredTime;
  BaseResponse *baseResponse;
  SKBuiltinBuffer_t *qrcode;
  NSString *uuid;
  SKBuiltinBuffer_t *notifyKey;
  NSString *blueToothBroadCastUuid;
  SKBuiltinBuffer_t *blueToothBroadCastContent;
} GetLoginQRCodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetLoginQRCodeResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "qrcode",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeResponse_FieldNumber_Qrcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, qrcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_Uuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, uuid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checkTime",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_CheckTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, checkTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "notifyKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeResponse_FieldNumber_NotifyKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, notifyKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "expiredTime",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_ExpiredTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, expiredTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blueToothBroadCastUuid",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_BlueToothBroadCastUuid,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, blueToothBroadCastUuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blueToothBroadCastContent",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeResponse_FieldNumber_BlueToothBroadCastContent,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, blueToothBroadCastContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLoginQRCodeResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLoginQRCodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001\014\000\004\t\000\005\t\000\006\013\000\007\026\000\010\031\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckLoginQRCodeRequest

@implementation CheckLoginQRCodeRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasUuid, uuid;
@dynamic hasTimeStamp, timeStamp;
@dynamic hasOpcode, opcode;

typedef struct CheckLoginQRCodeRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t timeStamp;
  int32_t opcode;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *uuid;
} CheckLoginQRCodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = CheckLoginQRCodeRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = CheckLoginQRCodeRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeRequest_FieldNumber_Uuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, uuid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeRequest_FieldNumber_TimeStamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeRequest_FieldNumber_Opcode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, opcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckLoginQRCodeRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckLoginQRCodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\016\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckLoginQRCodeResponse

@implementation CheckLoginQRCodeResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasNotifyPkg, notifyPkg;

typedef struct CheckLoginQRCodeResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg *notifyPkg;
} CheckLoginQRCodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = CheckLoginQRCodeResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notifyPkg",
        .dataTypeSpecific.className = GPBStringifySymbol(CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg),
        .number = CheckLoginQRCodeResponse_FieldNumber_NotifyPkg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse__storage_, notifyPkg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckLoginQRCodeResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckLoginQRCodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\014\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg

@implementation CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg

@dynamic hasNotifyData, notifyData;
@dynamic hasOpcode, opcode;

typedef struct CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_ {
  uint32_t _has_storage_[1];
  int32_t opcode;
  SKBuiltinBuffer_t *notifyData;
} CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notifyData",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg_FieldNumber_NotifyData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_, notifyData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg_FieldNumber_Opcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CheckLoginQRCodeResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NotifyMsg

@implementation NotifyMsg

@dynamic hasUuid, uuid;
@dynamic hasState, state;
@dynamic hasWxid, wxid;
@dynamic hasWxnewpass, wxnewpass;
@dynamic hasAvatar, avatar;
@dynamic hasPushLoginURLExpiredTime, pushLoginURLExpiredTime;
@dynamic hasNickName, nickName;
@dynamic hasEffectiveTime, effectiveTime;
@dynamic hasT10, t10;
@dynamic hasDevices, devices;

typedef struct NotifyMsg__storage_ {
  uint32_t _has_storage_[1];
  int32_t state;
  int32_t pushLoginURLExpiredTime;
  int32_t effectiveTime;
  int32_t t10;
  NSString *uuid;
  NSString *wxid;
  NSString *wxnewpass;
  NSString *avatar;
  NSString *nickName;
  NSString *devices;
} NotifyMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wxid",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Wxid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, wxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wxnewpass",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Wxnewpass,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, wxnewpass),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Avatar,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushLoginURLExpiredTime",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_PushLoginURLExpiredTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, pushLoginURLExpiredTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_NickName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "effectiveTime",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_EffectiveTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, effectiveTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "t10",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_T10,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, t10),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "devices",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Devices,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, devices),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NotifyMsg class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NotifyMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\006\n!,\000\007\010\000\010\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ECDHKey

@implementation ECDHKey

@dynamic hasNid, nid;
@dynamic hasKey, key;

typedef struct ECDHKey__storage_ {
  uint32_t _has_storage_[1];
  uint32_t nid;
  SKBuiltinBuffer_t *key;
} ECDHKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nid",
        .dataTypeSpecific.className = NULL,
        .number = ECDHKey_FieldNumber_Nid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ECDHKey__storage_, nid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ECDHKey_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ECDHKey__storage_, key),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ECDHKey class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ECDHKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthRsaReqData

@implementation ManualAuthRsaReqData

@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasCliPubEcdhkey, cliPubEcdhkey;
@dynamic hasUserName, userName;
@dynamic hasPwd, pwd;
@dynamic hasPwd2, pwd2;

typedef struct ManualAuthRsaReqData__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinBuffer_t *randomEncryKey;
  ECDHKey *cliPubEcdhkey;
  NSString *userName;
  NSString *pwd;
  NSString *pwd2;
} ManualAuthRsaReqData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ManualAuthRsaReqData_FieldNumber_RandomEncryKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliPubEcdhkey",
        .dataTypeSpecific.className = GPBStringifySymbol(ECDHKey),
        .number = ManualAuthRsaReqData_FieldNumber_CliPubEcdhkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, cliPubEcdhkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthRsaReqData_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthRsaReqData_FieldNumber_Pwd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, pwd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd2",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthRsaReqData_FieldNumber_Pwd2,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, pwd2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthRsaReqData class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthRsaReqData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\016\000\002\r\000\003\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthAesReqData

@implementation ManualAuthAesReqData

@dynamic hasBaseRequest, baseRequest;
@dynamic hasBaseReqInfo, baseReqInfo;
@dynamic hasImei, imei;
@dynamic hasSoftType, softType;
@dynamic hasBuiltinIpseq, builtinIpseq;
@dynamic hasClientSeqId, clientSeqId;
@dynamic hasClientSeqIdsign, clientSeqIdsign;
@dynamic hasDeviceName, deviceName;
@dynamic hasDeviceType, deviceType;
@dynamic hasLanguage, language;
@dynamic hasTimeZone, timeZone;
@dynamic hasChannel, channel;
@dynamic hasTimeStamp, timeStamp;
@dynamic hasDeviceBrand, deviceBrand;
@dynamic hasDeviceModel, deviceModel;
@dynamic hasOstype, ostype;
@dynamic hasRealCountry, realCountry;
@dynamic hasBundleId, bundleId;
@dynamic hasAdSource, adSource;
@dynamic hasIphoneVer, iphoneVer;
@dynamic hasInputType, inputType;
@dynamic hasClientCheckData, clientCheckData;

typedef struct ManualAuthAesReqData__storage_ {
  uint32_t _has_storage_[1];
  int32_t builtinIpseq;
  int32_t channel;
  int32_t timeStamp;
  int32_t inputType;
  BaseRequest *baseRequest;
  BaseAuthReqInfo *baseReqInfo;
  NSString *imei;
  NSString *softType;
  NSString *clientSeqId;
  NSString *clientSeqIdsign;
  NSString *deviceName;
  NSString *deviceType;
  NSString *language;
  NSString *timeZone;
  NSString *deviceBrand;
  NSString *deviceModel;
  NSString *ostype;
  NSString *realCountry;
  NSString *bundleId;
  NSString *adSource;
  NSString *iphoneVer;
  SKBuiltinBuffer_t *clientCheckData;
} ManualAuthAesReqData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ManualAuthAesReqData_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "baseReqInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseAuthReqInfo),
        .number = ManualAuthAesReqData_FieldNumber_BaseReqInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, baseReqInfo),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imei",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_Imei,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, imei),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "softType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_SoftType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, softType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIpseq",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_BuiltinIpseq,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, builtinIpseq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_ClientSeqId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientSeqIdsign",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_ClientSeqIdsign,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, clientSeqIdsign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_DeviceName,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_DeviceType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_Language,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, language),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_TimeZone,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_Channel,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, channel),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_TimeStamp,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceBrand",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_DeviceBrand,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, deviceBrand),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModel",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_DeviceModel,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, deviceModel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ostype",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_Ostype,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, ostype),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realCountry",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_RealCountry,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, realCountry),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundleId",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_BundleId,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, bundleId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adSource",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_AdSource,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, adSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iphoneVer",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_IphoneVer,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, iphoneVer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_InputType,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, inputType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientCheckData",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ManualAuthAesReqData_FieldNumber_ClientCheckData,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, clientCheckData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthAesReqData class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthAesReqData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\022\001\013\000\002\013\000\004\010\000\005\014\000\006\013\000\007\nb\003\000\010\n\000\t\n\000\013\010\000\016\t\000\017\013\000\020\013\000\022"
        "\013\000\023\010\000\024\010\000\025\t\000\026\t\000\027\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthRequest

@implementation ManualAuthRequest

@dynamic hasRsaReqData, rsaReqData;
@dynamic hasAesReqData, aesReqData;

typedef struct ManualAuthRequest__storage_ {
  uint32_t _has_storage_[1];
  ManualAuthRsaReqData *rsaReqData;
  ManualAuthAesReqData *aesReqData;
} ManualAuthRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rsaReqData",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthRsaReqData),
        .number = ManualAuthRequest_FieldNumber_RsaReqData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthRequest__storage_, rsaReqData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "aesReqData",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthAesReqData),
        .number = ManualAuthRequest_FieldNumber_AesReqData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthRequest__storage_, aesReqData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AutoAuthRsaReqData

@implementation AutoAuthRsaReqData

@dynamic hasAesEncryptKey, aesEncryptKey;
@dynamic hasCliPubEcdhkey, cliPubEcdhkey;

typedef struct AutoAuthRsaReqData__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinBuffer_t *aesEncryptKey;
  ECDHKey *cliPubEcdhkey;
} AutoAuthRsaReqData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aesEncryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AutoAuthRsaReqData_FieldNumber_AesEncryptKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AutoAuthRsaReqData__storage_, aesEncryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliPubEcdhkey",
        .dataTypeSpecific.className = GPBStringifySymbol(ECDHKey),
        .number = AutoAuthRsaReqData_FieldNumber_CliPubEcdhkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AutoAuthRsaReqData__storage_, cliPubEcdhkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutoAuthRsaReqData class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutoAuthRsaReqData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\r\000\003\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WTLoginImgReqInfo

@implementation WTLoginImgReqInfo

@dynamic hasImgSid, imgSid;
@dynamic hasImgCode, imgCode;
@dynamic hasImgEncryptKey, imgEncryptKey;
@dynamic hasKsid, ksid;

typedef struct WTLoginImgReqInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *imgSid;
  NSString *imgCode;
  NSString *imgEncryptKey;
  SKBuiltinBuffer_t *ksid;
} WTLoginImgReqInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imgSid",
        .dataTypeSpecific.className = NULL,
        .number = WTLoginImgReqInfo_FieldNumber_ImgSid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WTLoginImgReqInfo__storage_, imgSid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgCode",
        .dataTypeSpecific.className = NULL,
        .number = WTLoginImgReqInfo_FieldNumber_ImgCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WTLoginImgReqInfo__storage_, imgCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgEncryptKey",
        .dataTypeSpecific.className = NULL,
        .number = WTLoginImgReqInfo_FieldNumber_ImgEncryptKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WTLoginImgReqInfo__storage_, imgEncryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ksid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = WTLoginImgReqInfo_FieldNumber_Ksid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WTLoginImgReqInfo__storage_, ksid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WTLoginImgReqInfo class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WTLoginImgReqInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\006\000\002\007\000\003\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WxVerifyCodeReqInfo

@implementation WxVerifyCodeReqInfo

@dynamic hasVerifySignature, verifySignature;
@dynamic hasVerifyContent, verifyContent;

typedef struct WxVerifyCodeReqInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *verifySignature;
  NSString *verifyContent;
} WxVerifyCodeReqInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "verifySignature",
        .dataTypeSpecific.className = NULL,
        .number = WxVerifyCodeReqInfo_FieldNumber_VerifySignature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WxVerifyCodeReqInfo__storage_, verifySignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyContent",
        .dataTypeSpecific.className = NULL,
        .number = WxVerifyCodeReqInfo_FieldNumber_VerifyContent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WxVerifyCodeReqInfo__storage_, verifyContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WxVerifyCodeReqInfo class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WxVerifyCodeReqInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\017\000\002\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BaseAuthReqInfo

@implementation BaseAuthReqInfo

@dynamic hasWtloginReqBuff, wtloginReqBuff;
@dynamic hasWtloginImgReqInfo, wtloginImgReqInfo;
@dynamic hasWxVerifyCodeReqInfo, wxVerifyCodeReqInfo;
@dynamic hasCliDbencryptKey, cliDbencryptKey;
@dynamic hasCliDbencryptInfo, cliDbencryptInfo;
@dynamic hasAuthReqFlag, authReqFlag;
@dynamic hasAuthTicket, authTicket;

typedef struct BaseAuthReqInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t authReqFlag;
  SKBuiltinBuffer_t *wtloginReqBuff;
  WTLoginImgReqInfo *wtloginImgReqInfo;
  WxVerifyCodeReqInfo *wxVerifyCodeReqInfo;
  SKBuiltinBuffer_t *cliDbencryptKey;
  SKBuiltinBuffer_t *cliDbencryptInfo;
  NSString *authTicket;
} BaseAuthReqInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wtloginReqBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BaseAuthReqInfo_FieldNumber_WtloginReqBuff,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, wtloginReqBuff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wtloginImgReqInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(WTLoginImgReqInfo),
        .number = BaseAuthReqInfo_FieldNumber_WtloginImgReqInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, wtloginImgReqInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wxVerifyCodeReqInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(WxVerifyCodeReqInfo),
        .number = BaseAuthReqInfo_FieldNumber_WxVerifyCodeReqInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, wxVerifyCodeReqInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliDbencryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BaseAuthReqInfo_FieldNumber_CliDbencryptKey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, cliDbencryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliDbencryptInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BaseAuthReqInfo_FieldNumber_CliDbencryptInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, cliDbencryptInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authReqFlag",
        .dataTypeSpecific.className = NULL,
        .number = BaseAuthReqInfo_FieldNumber_AuthReqFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, authReqFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = NULL,
        .number = BaseAuthReqInfo_FieldNumber_AuthTicket,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, authTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BaseAuthReqInfo class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BaseAuthReqInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\016\000\002\021\000\003\023\000\004\017\000\005\020\000\006\013\000\007\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AutoAuthAesReqData

@implementation AutoAuthAesReqData

@dynamic hasBaseRequest, baseRequest;
@dynamic hasBaseReqInfo, baseReqInfo;
@dynamic hasAutoAuthKey, autoAuthKey;
@dynamic hasImei, imei;
@dynamic hasSoftType, softType;
@dynamic hasBuiltinIpseq, builtinIpseq;
@dynamic hasClientSeqId, clientSeqId;
@dynamic hasSignature, signature;
@dynamic hasDeviceName, deviceName;
@dynamic hasDeviceType, deviceType;
@dynamic hasLanguage, language;
@dynamic hasTimeZone, timeZone;
@dynamic hasChannel, channel;
@dynamic hasClientCheckData, clientCheckData;

typedef struct AutoAuthAesReqData__storage_ {
  uint32_t _has_storage_[1];
  uint32_t builtinIpseq;
  uint32_t channel;
  BaseRequest *baseRequest;
  BaseAuthReqInfo *baseReqInfo;
  SKBuiltinBuffer_t *autoAuthKey;
  NSString *imei;
  NSString *softType;
  NSString *clientSeqId;
  NSString *signature;
  NSString *deviceName;
  NSString *deviceType;
  NSString *language;
  NSString *timeZone;
  SKBuiltinBuffer_t *clientCheckData;
} AutoAuthAesReqData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = AutoAuthAesReqData_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "baseReqInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseAuthReqInfo),
        .number = AutoAuthAesReqData_FieldNumber_BaseReqInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, baseReqInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoAuthKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AutoAuthAesReqData_FieldNumber_AutoAuthKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, autoAuthKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imei",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_Imei,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, imei),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "softType",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_SoftType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, softType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIpseq",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_BuiltinIpseq,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, builtinIpseq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_ClientSeqId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_Signature,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_DeviceName,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_DeviceType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_Language,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_TimeZone,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_Channel,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, channel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientCheckData",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AutoAuthAesReqData_FieldNumber_ClientCheckData,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, clientCheckData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutoAuthAesReqData class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutoAuthAesReqData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\001\013\000\002\013\000\003\013\000\005\010\000\006\014\000\007\013\000\t\n\000\n\n\000\014\010\000\016\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AutoAuthRequest

@implementation AutoAuthRequest

@dynamic hasRsaReqData, rsaReqData;
@dynamic hasAesReqData, aesReqData;

typedef struct AutoAuthRequest__storage_ {
  uint32_t _has_storage_[1];
  AutoAuthRsaReqData *rsaReqData;
  AutoAuthAesReqData *aesReqData;
} AutoAuthRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rsaReqData",
        .dataTypeSpecific.className = GPBStringifySymbol(AutoAuthRsaReqData),
        .number = AutoAuthRequest_FieldNumber_RsaReqData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AutoAuthRequest__storage_, rsaReqData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "aesReqData",
        .dataTypeSpecific.className = GPBStringifySymbol(AutoAuthAesReqData),
        .number = AutoAuthRequest_FieldNumber_AesReqData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AutoAuthRequest__storage_, aesReqData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutoAuthRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutoAuthRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkControl

@implementation NetworkControl

@dynamic hasPortList, portList;
@dynamic hasTimeoutList, timeoutList;
@dynamic hasMinNoopInterval, minNoopInterval;
@dynamic hasMaxNoopInterval, maxNoopInterval;
@dynamic hasTypingInterval, typingInterval;
@dynamic hasNoopIntervalTime, noopIntervalTime;

typedef struct NetworkControl__storage_ {
  uint32_t _has_storage_[1];
  int32_t minNoopInterval;
  int32_t maxNoopInterval;
  int32_t typingInterval;
  int32_t noopIntervalTime;
  NSString *portList;
  NSString *timeoutList;
} NetworkControl__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "portList",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_PortList,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, portList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeoutList",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_TimeoutList,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, timeoutList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minNoopInterval",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_MinNoopInterval,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, minNoopInterval),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxNoopInterval",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_MaxNoopInterval,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, maxNoopInterval),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "typingInterval",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_TypingInterval,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, typingInterval),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "noopIntervalTime",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_NoopIntervalTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, noopIntervalTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkControl class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkControl__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001\010\000\002\013\000\003\017\000\004\017\000\005\016\000\007\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BuiltinIPList

@implementation BuiltinIPList

@dynamic hasLongConnectIpcount, longConnectIpcount;
@dynamic hasShortConnectIpcount, shortConnectIpcount;
@dynamic longConnectIplistArray, longConnectIplistArray_Count;
@dynamic shortConnectIplistArray, shortConnectIplistArray_Count;
@dynamic hasSeq, seq;

typedef struct BuiltinIPList__storage_ {
  uint32_t _has_storage_[1];
  int32_t longConnectIpcount;
  int32_t shortConnectIpcount;
  int32_t seq;
  NSMutableArray *longConnectIplistArray;
  NSMutableArray *shortConnectIplistArray;
} BuiltinIPList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "longConnectIpcount",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_FieldNumber_LongConnectIpcount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, longConnectIpcount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "shortConnectIpcount",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_FieldNumber_ShortConnectIpcount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, shortConnectIpcount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "longConnectIplistArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList_BuiltinIP),
        .number = BuiltinIPList_FieldNumber_LongConnectIplistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, longConnectIplistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shortConnectIplistArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList_BuiltinIP),
        .number = BuiltinIPList_FieldNumber_ShortConnectIplistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, shortConnectIplistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "seq",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_FieldNumber_Seq,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, seq),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BuiltinIPList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BuiltinIPList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\022\000\002\023\000\003\000longConnectIplist\000\004\000shortConnec"
        "tIplist\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BuiltinIPList_BuiltinIP

@implementation BuiltinIPList_BuiltinIP

@dynamic hasType, type;
@dynamic hasPort, port;
@dynamic hasIp, ip;
@dynamic hasDomain, domain;

typedef struct BuiltinIPList_BuiltinIP__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t port;
  NSString *ip;
  NSString *domain;
} BuiltinIPList_BuiltinIP__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_BuiltinIP_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BuiltinIPList_BuiltinIP__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_BuiltinIP_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BuiltinIPList_BuiltinIP__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_BuiltinIP_FieldNumber_Ip,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BuiltinIPList_BuiltinIP__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "domain",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_BuiltinIP_FieldNumber_Domain,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BuiltinIPList_BuiltinIP__storage_, domain),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BuiltinIPList_BuiltinIP class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BuiltinIPList_BuiltinIP__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(BuiltinIPList)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse

@implementation UnifyAuthResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasUnifyAuthSectFlag, unifyAuthSectFlag;
@dynamic hasAuthSectResp, authSectResp;
@dynamic hasAcctSectResp, acctSectResp;
@dynamic hasNetworkSectResp, networkSectResp;

typedef struct UnifyAuthResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t unifyAuthSectFlag;
  BaseResponse *baseResponse;
  UnifyAuthResponse_AuthSectResp *authSectResp;
  UnifyAuthResponse_AcctSectResp *acctSectResp;
  UnifyAuthResponse_NetworkSectResp *networkSectResp;
} UnifyAuthResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = UnifyAuthResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unifyAuthSectFlag",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_FieldNumber_UnifyAuthSectFlag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, unifyAuthSectFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "authSectResp",
        .dataTypeSpecific.className = GPBStringifySymbol(UnifyAuthResponse_AuthSectResp),
        .number = UnifyAuthResponse_FieldNumber_AuthSectResp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, authSectResp),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "acctSectResp",
        .dataTypeSpecific.className = GPBStringifySymbol(UnifyAuthResponse_AcctSectResp),
        .number = UnifyAuthResponse_FieldNumber_AcctSectResp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, acctSectResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkSectResp",
        .dataTypeSpecific.className = GPBStringifySymbol(UnifyAuthResponse_NetworkSectResp),
        .number = UnifyAuthResponse_FieldNumber_NetworkSectResp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, networkSectResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\014\000\002\021\000\003\014\000\004\014\000\005\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_AuthSectResp

@implementation UnifyAuthResponse_AuthSectResp

@dynamic hasUin, uin;
@dynamic hasSvrPubEcdhkey, svrPubEcdhkey;
@dynamic hasSessionKey, sessionKey;
@dynamic hasAutoAuthKey, autoAuthKey;
@dynamic hasWtloginRspBuffFlag, wtloginRspBuffFlag;
@dynamic hasShowStyle, showStyle;
@dynamic hasSmsTicket, smsTicket;
@dynamic hasAuthResultFlag, authResultFlag;
@dynamic hasFsurl, fsurl;
@dynamic hasServerTime, serverTime;

typedef struct UnifyAuthResponse_AuthSectResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t uin;
  int32_t wtloginRspBuffFlag;
  int32_t authResultFlag;
  int32_t serverTime;
  ECDHKey *svrPubEcdhkey;
  SKBuiltinBuffer_t *sessionKey;
  SKBuiltinBuffer_t *autoAuthKey;
  UnifyAuthResponse_AuthSectResp_ShowStyleKey *showStyle;
  NSData *smsTicket;
  NSString *fsurl;
} UnifyAuthResponse_AuthSectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_Uin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, uin),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "svrPubEcdhkey",
        .dataTypeSpecific.className = GPBStringifySymbol(ECDHKey),
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_SvrPubEcdhkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, svrPubEcdhkey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sessionKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_SessionKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, sessionKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoAuthKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_AutoAuthKey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, autoAuthKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wtloginRspBuffFlag",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_WtloginRspBuffFlag,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, wtloginRspBuffFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "showStyle",
        .dataTypeSpecific.className = GPBStringifySymbol(UnifyAuthResponse_AuthSectResp_ShowStyleKey),
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_ShowStyle,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, showStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "smsTicket",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_SmsTicket,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, smsTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "authResultFlag",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_AuthResultFlag,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, authResultFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fsurl",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_Fsurl,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, fsurl),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serverTime",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_FieldNumber_ServerTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp__storage_, serverTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_AuthSectResp class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_AuthSectResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\002\r\000\003\n\000\004\013\000\005\022\000\017\t\000\020I\000\023\016\000\026\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_AuthSectResp_ShowStyleKey

@implementation UnifyAuthResponse_AuthSectResp_ShowStyleKey

@dynamic hasKeyCount, keyCount;

typedef struct UnifyAuthResponse_AuthSectResp_ShowStyleKey__storage_ {
  uint32_t _has_storage_[1];
  int32_t keyCount;
} UnifyAuthResponse_AuthSectResp_ShowStyleKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyCount",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_ShowStyleKey_FieldNumber_KeyCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp_ShowStyleKey__storage_, keyCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_AuthSectResp_ShowStyleKey class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_AuthSectResp_ShowStyleKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse_AuthSectResp)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal

@implementation UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal

@dynamic hasKey, key;
@dynamic hasVal, val;

typedef struct UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal__storage_ {
  uint32_t _has_storage_[1];
  int32_t key;
  NSString *val;
} UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "val",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal_FieldNumber_Val,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal__storage_, val),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_AuthSectResp_ShowStyleKey_StyleKeyVal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse_AuthSectResp_ShowStyleKey)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_AcctSectResp

@implementation UnifyAuthResponse_AcctSectResp

@dynamic hasUserName, userName;
@dynamic hasNickName, nickName;
@dynamic hasBindUin, bindUin;
@dynamic hasBindMail, bindMail;
@dynamic hasBindMobile, bindMobile;
@dynamic hasAlias, alias;
@dynamic hasBindEmail, bindEmail;
@dynamic hasStatus, status;
@dynamic hasPluginFlag, pluginFlag;
@dynamic hasRegType, regType;
@dynamic hasDeviceInfoXml, deviceInfoXml;
@dynamic hasSafeDevice, safeDevice;
@dynamic hasOfficialUserName, officialUserName;
@dynamic hasOfficialNickName, officialNickName;
@dynamic hasPushMailStatus, pushMailStatus;
@dynamic hasFsURL, fsURL;

typedef struct UnifyAuthResponse_AcctSectResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t bindUin;
  int32_t status;
  int32_t pluginFlag;
  int32_t regType;
  int32_t safeDevice;
  int32_t pushMailStatus;
  NSString *userName;
  NSString *nickName;
  NSString *bindMail;
  NSString *bindMobile;
  NSString *alias;
  NSString *bindEmail;
  NSString *deviceInfoXml;
  NSString *officialUserName;
  NSString *officialNickName;
  NSString *fsURL;
} UnifyAuthResponse_AcctSectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindUin",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_BindUin,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, bindUin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "bindMail",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_BindMail,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, bindMail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindMobile",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_BindMobile,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, bindMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_Alias,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindEmail",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_BindEmail,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, bindEmail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_Status,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pluginFlag",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_PluginFlag,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, pluginFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "regType",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_RegType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, regType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceInfoXml",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_DeviceInfoXml,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, deviceInfoXml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "safeDevice",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_SafeDevice,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, safeDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "officialUserName",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_OfficialUserName,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, officialUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "officialNickName",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_OfficialNickName,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, officialNickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushMailStatus",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_PushMailStatus,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, pushMailStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fsURL",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_AcctSectResp_FieldNumber_FsURL,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_AcctSectResp__storage_, fsURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_AcctSectResp class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_AcctSectResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\016\001\010\000\002\010\000\003\007\000\004\010\000\005\n\000\007\t\000\t\n\000\n\007\000\013\r\000\014\n\000\r\020\000\016\020\000\017\016\000"
        "\020\003!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_NetworkSectResp

@implementation UnifyAuthResponse_NetworkSectResp

@dynamic hasNewHostList, newHostList;
@dynamic hasNetworkControl, networkControl;
@dynamic hasBuiltinIplist, builtinIplist;

typedef struct UnifyAuthResponse_NetworkSectResp__storage_ {
  uint32_t _has_storage_[1];
  UnifyAuthResponse_NetworkSectResp_HostList *newHostList;
  NetworkControl *networkControl;
  BuiltinIPList *builtinIplist;
} UnifyAuthResponse_NetworkSectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "newHostList",
        .dataTypeSpecific.className = GPBStringifySymbol(UnifyAuthResponse_NetworkSectResp_HostList),
        .number = UnifyAuthResponse_NetworkSectResp_FieldNumber_NewHostList,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp__storage_, newHostList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkControl",
        .dataTypeSpecific.className = GPBStringifySymbol(NetworkControl),
        .number = UnifyAuthResponse_NetworkSectResp_FieldNumber_NetworkControl,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp__storage_, networkControl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "builtinIplist",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList),
        .number = UnifyAuthResponse_NetworkSectResp_FieldNumber_BuiltinIplist,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp__storage_, builtinIplist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_NetworkSectResp class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_NetworkSectResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\016\000\003\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_NetworkSectResp_HostList

@implementation UnifyAuthResponse_NetworkSectResp_HostList

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct UnifyAuthResponse_NetworkSectResp_HostList__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  NSMutableArray *listArray;
} UnifyAuthResponse_NetworkSectResp_HostList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_NetworkSectResp_HostList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp_HostList__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UnifyAuthResponse_NetworkSectResp_HostList_Host),
        .number = UnifyAuthResponse_NetworkSectResp_HostList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp_HostList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_NetworkSectResp_HostList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_NetworkSectResp_HostList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse_NetworkSectResp)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse_NetworkSectResp_HostList_Host

@implementation UnifyAuthResponse_NetworkSectResp_HostList_Host

@dynamic hasOrigin, origin;
@dynamic hasSubstitute, substitute;
@dynamic hasPriority, priority;

typedef struct UnifyAuthResponse_NetworkSectResp_HostList_Host__storage_ {
  uint32_t _has_storage_[1];
  int32_t priority;
  NSString *origin;
  NSString *substitute;
} UnifyAuthResponse_NetworkSectResp_HostList_Host__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "origin",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_NetworkSectResp_HostList_Host_FieldNumber_Origin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp_HostList_Host__storage_, origin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "substitute",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_NetworkSectResp_HostList_Host_FieldNumber_Substitute,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp_HostList_Host__storage_, substitute),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priority",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_NetworkSectResp_HostList_Host_FieldNumber_Priority,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnifyAuthResponse_NetworkSectResp_HostList_Host__storage_, priority),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse_NetworkSectResp_HostList_Host class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse_NetworkSectResp_HostList_Host__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(UnifyAuthResponse_NetworkSectResp_HostList)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewInitRequest

@implementation NewInitRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasCurrentSynckey, currentSynckey;
@dynamic hasMaxSynckey, maxSynckey;
@dynamic hasLanguage, language;

typedef struct NewInitRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *userName;
  NSData *currentSynckey;
  NSData *maxSynckey;
  NSString *language;
} NewInitRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = NewInitRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currentSynckey",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_CurrentSynckey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, currentSynckey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "maxSynckey",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_MaxSynckey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, maxSynckey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_Language,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, language),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewInitRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewInitRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\013\000\002\010\000\003\016\000\004\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddMsg

@implementation AddMsg

@dynamic hasMsgId, msgId;
@dynamic hasFromUserName, fromUserName;
@dynamic hasToUserName, toUserName;
@dynamic hasMsgType, msgType;
@dynamic hasContent, content;
@dynamic hasStatus, status;
@dynamic hasImgStatus, imgStatus;
@dynamic hasImgBuf, imgBuf;
@dynamic hasCreateTime, createTime;
@dynamic hasMsgSource, msgSource;
@dynamic hasPushContent, pushContent;
@dynamic hasNewMsgId, newMsgId;
@dynamic hasMsgSeq, msgSeq;

typedef struct AddMsg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t msgId;
  int32_t msgType;
  int32_t status;
  int32_t imgStatus;
  int32_t createTime;
  int32_t msgSeq;
  SKBuiltinString_t *fromUserName;
  SKBuiltinString_t *toUserName;
  SKBuiltinString_t *content;
  SKBuiltinBuffer_t *imgBuf;
  NSString *msgSource;
  NSString *pushContent;
  int64_t newMsgId;
} AddMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddMsg__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fromUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = AddMsg_FieldNumber_FromUserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddMsg__storage_, fromUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = AddMsg_FieldNumber_ToUserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddMsg__storage_, toUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_MsgType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddMsg__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = AddMsg_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AddMsg__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AddMsg__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imgStatus",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_ImgStatus,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AddMsg__storage_, imgStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imgBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AddMsg_FieldNumber_ImgBuf,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AddMsg__storage_, imgBuf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_CreateTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AddMsg__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgSource",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_MsgSource,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AddMsg__storage_, msgSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushContent",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_PushContent,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AddMsg__storage_, pushContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newMsgId",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_NewMsgId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AddMsg__storage_, newMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSeq",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_MsgSeq,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AddMsg__storage_, msgSeq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddMsg class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\013\001\005\000\002\014\000\003\n\000\004\007\000\007\t\000\010\006\000\t\n\000\n\t\000\013\013\000\014\010\000\r\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsUserInfo

@implementation SnsUserInfo

@dynamic hasSnsFlag, snsFlag;
@dynamic hasSnsBgimgId, snsBgimgId;
@dynamic hasSnsBgobjectId, snsBgobjectId;
@dynamic hasSnsFlagEx, snsFlagEx;

typedef struct SnsUserInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t snsFlag;
  uint32_t snsFlagEx;
  NSString *snsBgimgId;
  uint64_t snsBgobjectId;
} SnsUserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "snsFlag",
        .dataTypeSpecific.className = NULL,
        .number = SnsUserInfo_FieldNumber_SnsFlag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsUserInfo__storage_, snsFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "snsBgimgId",
        .dataTypeSpecific.className = NULL,
        .number = SnsUserInfo_FieldNumber_SnsBgimgId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsUserInfo__storage_, snsBgimgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "snsBgobjectId",
        .dataTypeSpecific.className = NULL,
        .number = SnsUserInfo_FieldNumber_SnsBgobjectId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SnsUserInfo__storage_, snsBgobjectId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "snsFlagEx",
        .dataTypeSpecific.className = NULL,
        .number = SnsUserInfo_FieldNumber_SnsFlagEx,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SnsUserInfo__storage_, snsFlagEx),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsUserInfo class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsUserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\007\000\002\n\000\003\r\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CustomizedInfoNew

@implementation CustomizedInfoNew


typedef struct CustomizedInfoNew__storage_ {
  uint32_t _has_storage_[1];
} CustomizedInfoNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CustomizedInfoNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(CustomizedInfoNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LinkedinContactItem

@implementation LinkedinContactItem


typedef struct LinkedinContactItem__storage_ {
  uint32_t _has_storage_[1];
} LinkedinContactItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LinkedinContactItem class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(LinkedinContactItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatRoomMemberInfo

@implementation ChatRoomMemberInfo

@dynamic hasUserName, userName;
@dynamic hasNickName, nickName;
@dynamic hasDisplayName, displayName;
@dynamic hasBigHeadImgURL, bigHeadImgURL;
@dynamic hasSmallHeadImgURL, smallHeadImgURL;
@dynamic hasChatroomMemberFlag, chatroomMemberFlag;
@dynamic hasInviterUserName, inviterUserName;

typedef struct ChatRoomMemberInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t chatroomMemberFlag;
  NSString *userName;
  NSString *nickName;
  NSString *displayName;
  NSString *bigHeadImgURL;
  NSString *smallHeadImgURL;
  NSString *inviterUserName;
} ChatRoomMemberInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_DisplayName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, displayName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bigHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_BigHeadImgURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, bigHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smallHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_SmallHeadImgURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, smallHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatroomMemberFlag",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_ChatroomMemberFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, chatroomMemberFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "inviterUserName",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_InviterUserName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, inviterUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatRoomMemberInfo class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatRoomMemberInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\010\000\002\010\000\003\013\000\004\013!!\000\005\r!!\000\006\022\000\007\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PhoneNumItem

@implementation PhoneNumItem

@dynamic hasPhoneNum, phoneNum;

typedef struct PhoneNumItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *phoneNum;
} PhoneNumItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phoneNum",
        .dataTypeSpecific.className = NULL,
        .number = PhoneNumItem_FieldNumber_PhoneNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PhoneNumItem__storage_, phoneNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PhoneNumItem class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PhoneNumItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PhoneNumListInfo

@implementation PhoneNumListInfo

@dynamic hasCount, count;
@dynamic phoneNumListArray, phoneNumListArray_Count;

typedef struct PhoneNumListInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSMutableArray *phoneNumListArray;
} PhoneNumListInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PhoneNumListInfo_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PhoneNumListInfo__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "phoneNumListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PhoneNumItem),
        .number = PhoneNumListInfo_FieldNumber_PhoneNumListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PhoneNumListInfo__storage_, phoneNumListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PhoneNumListInfo class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PhoneNumListInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000phoneNumList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModContact

@implementation ModContact

@dynamic hasUserName, userName;
@dynamic hasNickName, nickName;
@dynamic hasPyinitial, pyinitial;
@dynamic hasQuanPin, quanPin;
@dynamic hasSex, sex;
@dynamic hasImgBuf, imgBuf;
@dynamic hasBitMask, bitMask;
@dynamic hasBitVal, bitVal;
@dynamic hasImgFlag, imgFlag;
@dynamic hasRemark, remark;
@dynamic hasRealShortPy, realShortPy;
@dynamic hasRealQuanpin, realQuanpin;
@dynamic hasContactType, contactType;
@dynamic hasRoomInfoCount, roomInfoCount;
@dynamic hasTag16, tag16;
@dynamic hasChatRoomNotify, chatRoomNotify;
@dynamic hasAddContactScene, addContactScene;
@dynamic hasProvince, province;
@dynamic hasCity, city;
@dynamic hasSignature, signature;
@dynamic hasPersonalCard, personalCard;
@dynamic hasTag23, tag23;
@dynamic hasVerifyFlag, verifyFlag;
@dynamic hasVerifyInfo, verifyInfo;
@dynamic hasLevel, level;
@dynamic hasSource, source;
@dynamic hasWeibo, weibo;
@dynamic hasVerifyContent, verifyContent;
@dynamic hasAlias, alias;
@dynamic hasChatRoomOwner, chatRoomOwner;
@dynamic hasWeiboNickname, weiboNickname;
@dynamic hasWeiboFlag, weiboFlag;
@dynamic hasAlbumStyle, albumStyle;
@dynamic hasAlbumFlag, albumFlag;
@dynamic hasAlbumBgimgId, albumBgimgId;
@dynamic hasSnsUserInfo, snsUserInfo;
@dynamic hasCountry, country;
@dynamic hasBigHeadImgURL, bigHeadImgURL;
@dynamic hasSmallHeadImgURL, smallHeadImgURL;
@dynamic hasMyBrandList, myBrandList;
@dynamic hasCustomizedInfo, customizedInfo;
@dynamic hasChatRoomData, chatRoomData;
@dynamic hasHeadImgMd5, headImgMd5;
@dynamic hasEncryptUserName, encryptUserName;
@dynamic hasRealName, realName;
@dynamic hasMobileFullHash, mobileFullHash;
@dynamic hasAdditionalContactList, additionalContactList;
@dynamic hasChatroomVersion, chatroomVersion;
@dynamic hasExtInfo, extInfo;
@dynamic hasChatroomMaxCount, chatroomMaxCount;
@dynamic hasChatroomAccessType, chatroomAccessType;
@dynamic hasNewChatroomData, newChatroomData;
@dynamic hasDeleteFlag, deleteFlag;
@dynamic hasDescription_p, description_p;
@dynamic hasCardImgURL, cardImgURL;
@dynamic hasLabelIdlist, labelIdlist;
@dynamic hasPhoneNumListInfo, phoneNumListInfo;
@dynamic hasWeiDianInfo, weiDianInfo;
@dynamic hasChatroomInfoVersion, chatroomInfoVersion;
@dynamic hasDeleteContactScene, deleteContactScene;
@dynamic hasChatroomStatus, chatroomStatus;
@dynamic hasExtFlag, extFlag;

typedef struct ModContact__storage_ {
  uint32_t _has_storage_[2];
  uint32_t sex;
  uint32_t bitMask;
  uint32_t bitVal;
  uint32_t imgFlag;
  uint32_t contactType;
  uint32_t roomInfoCount;
  uint32_t chatRoomNotify;
  uint32_t addContactScene;
  uint32_t personalCard;
  int32_t tag23;
  uint32_t verifyFlag;
  uint32_t level;
  uint32_t source;
  uint32_t weiboFlag;
  uint32_t albumStyle;
  uint32_t albumFlag;
  uint32_t chatroomVersion;
  uint32_t chatroomMaxCount;
  uint32_t chatroomAccessType;
  uint32_t deleteFlag;
  uint32_t chatroomInfoVersion;
  uint32_t deleteContactScene;
  uint32_t chatroomStatus;
  uint32_t extFlag;
  SKBuiltinString_t *userName;
  SKBuiltinString_t *nickName;
  SKBuiltinString_t *pyinitial;
  SKBuiltinString_t *quanPin;
  SKBuiltinBuffer_t *imgBuf;
  SKBuiltinString_t *remark;
  SKBuiltinString_t *realShortPy;
  SKBuiltinString_t *realQuanpin;
  NSString *tag16;
  NSString *province;
  NSString *city;
  NSString *signature;
  NSString *verifyInfo;
  NSString *weibo;
  NSString *verifyContent;
  NSString *alias;
  NSString *chatRoomOwner;
  NSString *weiboNickname;
  NSString *albumBgimgId;
  SnsUserInfo *snsUserInfo;
  NSString *country;
  NSString *bigHeadImgURL;
  NSString *smallHeadImgURL;
  NSString *myBrandList;
  CustomizedInfoNew *customizedInfo;
  NSString *chatRoomData;
  NSString *headImgMd5;
  NSString *encryptUserName;
  NSString *realName;
  NSString *mobileFullHash;
  NSData *additionalContactList;
  NSString *extInfo;
  ModContact_GroupMemberList *newChatroomData;
  NSString *description_p;
  NSString *cardImgURL;
  NSString *labelIdlist;
  PhoneNumListInfo *phoneNumListInfo;
  NSString *weiDianInfo;
} ModContact__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModContact__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModContact__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pyinitial",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_Pyinitial,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModContact__storage_, pyinitial),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "quanPin",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_QuanPin,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModContact__storage_, quanPin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ModContact__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ModContact_FieldNumber_ImgBuf,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ModContact__storage_, imgBuf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bitMask",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_BitMask,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ModContact__storage_, bitMask),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bitVal",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_BitVal,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ModContact__storage_, bitVal),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ImgFlag,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ModContact__storage_, imgFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_Remark,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ModContact__storage_, remark),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "realShortPy",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_RealShortPy,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ModContact__storage_, realShortPy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "realQuanpin",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_RealQuanpin,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ModContact__storage_, realQuanpin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contactType",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ContactType,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ModContact__storage_, contactType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "roomInfoCount",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_RoomInfoCount,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ModContact__storage_, roomInfoCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag16",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Tag16,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ModContact__storage_, tag16),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatRoomNotify",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatRoomNotify,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatRoomNotify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "addContactScene",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_AddContactScene,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ModContact__storage_, addContactScene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "province",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Province,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ModContact__storage_, province),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "city",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_City,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ModContact__storage_, city),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Signature,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ModContact__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "personalCard",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_PersonalCard,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ModContact__storage_, personalCard),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag23",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Tag23,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ModContact__storage_, tag23),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "verifyFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_VerifyFlag,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(ModContact__storage_, verifyFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "verifyInfo",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_VerifyInfo,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(ModContact__storage_, verifyInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Level,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(ModContact__storage_, level),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Source,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(ModContact__storage_, source),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "weibo",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Weibo,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(ModContact__storage_, weibo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyContent",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_VerifyContent,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(ModContact__storage_, verifyContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Alias,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(ModContact__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatRoomOwner",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatRoomOwner,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatRoomOwner),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weiboNickname",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_WeiboNickname,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(ModContact__storage_, weiboNickname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weiboFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_WeiboFlag,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(ModContact__storage_, weiboFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "albumStyle",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_AlbumStyle,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(ModContact__storage_, albumStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "albumFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_AlbumFlag,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(ModContact__storage_, albumFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "albumBgimgId",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_AlbumBgimgId,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(ModContact__storage_, albumBgimgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "snsUserInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SnsUserInfo),
        .number = ModContact_FieldNumber_SnsUserInfo,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(ModContact__storage_, snsUserInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Country,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(ModContact__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bigHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_BigHeadImgURL,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(ModContact__storage_, bigHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smallHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_SmallHeadImgURL,
        .hasIndex = 38,
        .offset = (uint32_t)offsetof(ModContact__storage_, smallHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "myBrandList",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_MyBrandList,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(ModContact__storage_, myBrandList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "customizedInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(CustomizedInfoNew),
        .number = ModContact_FieldNumber_CustomizedInfo,
        .hasIndex = 40,
        .offset = (uint32_t)offsetof(ModContact__storage_, customizedInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatRoomData",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatRoomData,
        .hasIndex = 41,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatRoomData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headImgMd5",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_HeadImgMd5,
        .hasIndex = 42,
        .offset = (uint32_t)offsetof(ModContact__storage_, headImgMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encryptUserName",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_EncryptUserName,
        .hasIndex = 43,
        .offset = (uint32_t)offsetof(ModContact__storage_, encryptUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realName",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_RealName,
        .hasIndex = 44,
        .offset = (uint32_t)offsetof(ModContact__storage_, realName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobileFullHash",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_MobileFullHash,
        .hasIndex = 45,
        .offset = (uint32_t)offsetof(ModContact__storage_, mobileFullHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "additionalContactList",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_AdditionalContactList,
        .hasIndex = 46,
        .offset = (uint32_t)offsetof(ModContact__storage_, additionalContactList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "chatroomVersion",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatroomVersion,
        .hasIndex = 47,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatroomVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extInfo",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ExtInfo,
        .hasIndex = 48,
        .offset = (uint32_t)offsetof(ModContact__storage_, extInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatroomMaxCount",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatroomMaxCount,
        .hasIndex = 49,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatroomMaxCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chatroomAccessType",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatroomAccessType,
        .hasIndex = 50,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatroomAccessType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "newChatroomData",
        .dataTypeSpecific.className = GPBStringifySymbol(ModContact_GroupMemberList),
        .number = ModContact_FieldNumber_NewChatroomData,
        .hasIndex = 51,
        .offset = (uint32_t)offsetof(ModContact__storage_, newChatroomData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deleteFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_DeleteFlag,
        .hasIndex = 52,
        .offset = (uint32_t)offsetof(ModContact__storage_, deleteFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Description_p,
        .hasIndex = 53,
        .offset = (uint32_t)offsetof(ModContact__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cardImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_CardImgURL,
        .hasIndex = 54,
        .offset = (uint32_t)offsetof(ModContact__storage_, cardImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "labelIdlist",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_LabelIdlist,
        .hasIndex = 55,
        .offset = (uint32_t)offsetof(ModContact__storage_, labelIdlist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phoneNumListInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PhoneNumListInfo),
        .number = ModContact_FieldNumber_PhoneNumListInfo,
        .hasIndex = 56,
        .offset = (uint32_t)offsetof(ModContact__storage_, phoneNumListInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "weiDianInfo",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_WeiDianInfo,
        .hasIndex = 57,
        .offset = (uint32_t)offsetof(ModContact__storage_, weiDianInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatroomInfoVersion",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatroomInfoVersion,
        .hasIndex = 58,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatroomInfoVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deleteContactScene",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_DeleteContactScene,
        .hasIndex = 59,
        .offset = (uint32_t)offsetof(ModContact__storage_, deleteContactScene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chatroomStatus",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatroomStatus,
        .hasIndex = 60,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatroomStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ExtFlag,
        .hasIndex = 61,
        .offset = (uint32_t)offsetof(ModContact__storage_, extFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModContact class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModContact__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "/\001\010\000\002\010\000\004\007\000\006\006\000\007\007\000\010\006\000\t\007\000\013\004\247\000\r\013\000\016\r\000\021\016\000\022\017\000\026\014"
        "\000\030\n\000\031\n\000\035\r\000\037\r\000 \r\000!\t\000\"\n\000#\t\000$\014\000%\013\000\'\013!!\000(\r!!"
        "\000)\013\000*\016\000+\014\000,\n\000-\017\000/\010\0001\016\0002\025\0005\017\0006\007\0007\020\0008\022\0009\017\000"
        ":\n\000<\010!!\000=\013\000>\020\000\?\013\000@\023\000A\022\000B\016\000C\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModContact_GroupMemberList

@implementation ModContact_GroupMemberList

@dynamic hasMemberCount, memberCount;
@dynamic chatRoomMemberArray, chatRoomMemberArray_Count;
@dynamic hasInfoMask, infoMask;
@dynamic hasTag4, tag4;

typedef struct ModContact_GroupMemberList__storage_ {
  uint32_t _has_storage_[1];
  uint32_t memberCount;
  uint32_t infoMask;
  NSMutableArray *chatRoomMemberArray;
  NSString *tag4;
} ModContact_GroupMemberList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberCount",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_GroupMemberList_FieldNumber_MemberCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModContact_GroupMemberList__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chatRoomMemberArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatRoomMemberInfo),
        .number = ModContact_GroupMemberList_FieldNumber_ChatRoomMemberArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ModContact_GroupMemberList__storage_, chatRoomMemberArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "infoMask",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_GroupMemberList_FieldNumber_InfoMask,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModContact_GroupMemberList__storage_, infoMask),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag4",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_GroupMemberList_FieldNumber_Tag4,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModContact_GroupMemberList__storage_, tag4),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModContact_GroupMemberList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModContact_GroupMemberList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\000chatRoomMember\000\003\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ModContact)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CmdItem

@implementation CmdItem

@dynamic hasCmdId, cmdId;
@dynamic hasCmdBuf, cmdBuf;

typedef struct CmdItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t cmdId;
  SKBuiltinBuffer_t *cmdBuf;
} CmdItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cmdId",
        .dataTypeSpecific.className = NULL,
        .number = CmdItem_FieldNumber_CmdId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CmdItem__storage_, cmdId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cmdBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = CmdItem_FieldNumber_CmdBuf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CmdItem__storage_, cmdBuf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CmdItem class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CmdItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\005\000\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewInitResponse

@implementation NewInitResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCurrentSynckey, currentSynckey;
@dynamic hasMaxSynckey, maxSynckey;
@dynamic hasContinueFlag, continueFlag;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct NewInitResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t continueFlag;
  int32_t count;
  BaseResponse *baseResponse;
  NSData *currentSynckey;
  NSData *maxSynckey;
  NSMutableArray *listArray;
} NewInitResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = NewInitResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "currentSynckey",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_CurrentSynckey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, currentSynckey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "maxSynckey",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_MaxSynckey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, maxSynckey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "continueFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_ContinueFlag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, continueFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_Count,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdItem),
        .number = NewInitResponse_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewInitResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewInitResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\014\000\002\016\000\003\n\000\004\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewSyncRequest

@implementation NewSyncRequest

@dynamic hasOplog, oplog;
@dynamic hasSelector, selector;
@dynamic hasKeyBuf, keyBuf;
@dynamic hasScene, scene;
@dynamic hasDeviceType, deviceType;
@dynamic hasSyncMsgDigest, syncMsgDigest;

typedef struct NewSyncRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t selector;
  int32_t scene;
  int32_t syncMsgDigest;
  NSString *oplog;
  NSData *keyBuf;
  NSString *deviceType;
} NewSyncRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oplog",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_Oplog,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, oplog),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selector",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_Selector,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, selector),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "keyBuf",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_KeyBuf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, keyBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, scene),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_DeviceType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "syncMsgDigest",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_SyncMsgDigest,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, syncMsgDigest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewSyncRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewSyncRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\006\000\005\n\000\006\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewSyncResponse

@implementation NewSyncResponse

@dynamic hasRet, ret;
@dynamic hasCmdList, cmdList;
@dynamic hasContinueFlag, continueFlag;
@dynamic hasKeyBuf, keyBuf;
@dynamic hasStatus, status;
@dynamic hasOnlineVersion, onlineVersion;
@dynamic hasSvrTime, svrTime;

typedef struct NewSyncResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  int32_t continueFlag;
  int32_t status;
  int32_t onlineVersion;
  int32_t svrTime;
  NewSyncResponse_CmdList *cmdList;
  NSData *keyBuf;
} NewSyncResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, ret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cmdList",
        .dataTypeSpecific.className = GPBStringifySymbol(NewSyncResponse_CmdList),
        .number = NewSyncResponse_FieldNumber_CmdList,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, cmdList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "continueFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_ContinueFlag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, continueFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "keyBuf",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_KeyBuf,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, keyBuf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "onlineVersion",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_OnlineVersion,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, onlineVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "svrTime",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_SvrTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, svrTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewSyncResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewSyncResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\002\007\000\003\014\000\004\006\000\006\r\000\007\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewSyncResponse_CmdList

@implementation NewSyncResponse_CmdList

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct NewSyncResponse_CmdList__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  NSMutableArray *listArray;
} NewSyncResponse_CmdList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_CmdList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewSyncResponse_CmdList__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdItem),
        .number = NewSyncResponse_CmdList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NewSyncResponse_CmdList__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewSyncResponse_CmdList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewSyncResponse_CmdList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(NewSyncResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MicroMsgRequestNew

@implementation MicroMsgRequestNew

@dynamic hasToUserName, toUserName;
@dynamic hasContent, content;
@dynamic hasType, type;
@dynamic hasCreateTime, createTime;
@dynamic hasClientMsgId, clientMsgId;
@dynamic hasMsgSource, msgSource;

typedef struct MicroMsgRequestNew__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t createTime;
  SKBuiltinString_t *toUserName;
  NSString *content;
  NSString *msgSource;
  int64_t clientMsgId;
} MicroMsgRequestNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "toUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MicroMsgRequestNew_FieldNumber_ToUserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, toUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientMsgId",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_ClientMsgId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, clientMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSource",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_MsgSource,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, msgSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MicroMsgRequestNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MicroMsgRequestNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\n\000\004\n\000\005\013\000\006\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMsgRequestNew

@implementation SendMsgRequestNew

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct SendMsgRequestNew__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  NSMutableArray *listArray;
} SendMsgRequestNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = SendMsgRequestNew_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMsgRequestNew__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MicroMsgRequestNew),
        .number = SendMsgRequestNew_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendMsgRequestNew__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMsgRequestNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMsgRequestNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MicroMsgResponseNew

@implementation MicroMsgResponseNew

@dynamic hasRet, ret;
@dynamic hasToUserName, toUserName;
@dynamic hasMsgId, msgId;
@dynamic hasClientMsgId, clientMsgId;
@dynamic hasCreateTime, createTime;
@dynamic hasServerTime, serverTime;
@dynamic hasType, type;
@dynamic hasNewMsgId, newMsgId;

typedef struct MicroMsgResponseNew__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  int32_t msgId;
  int32_t clientMsgId;
  int32_t createTime;
  int32_t serverTime;
  int32_t type;
  SKBuiltinString_t *toUserName;
  int64_t newMsgId;
} MicroMsgResponseNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, ret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "toUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MicroMsgResponseNew_FieldNumber_ToUserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, toUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientMsgId",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_ClientMsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, clientMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_CreateTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "serverTime",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_ServerTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, serverTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_Type,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "newMsgId",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_NewMsgId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, newMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MicroMsgResponseNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MicroMsgResponseNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\002\n\000\003\005\000\004\013\000\005\n\000\006\n\000\010\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMsgResponseNew

@implementation SendMsgResponseNew

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct SendMsgResponseNew__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  BaseResponse *baseResponse;
  NSMutableArray *listArray;
} SendMsgResponseNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = SendMsgResponseNew_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMsgResponseNew__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = SendMsgResponseNew_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendMsgResponseNew__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MicroMsgResponseNew),
        .number = SendMsgResponseNew_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendMsgResponseNew__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMsgResponseNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMsgResponseNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckResUpdateRequest

@implementation CheckResUpdateRequest

@dynamic resIdArray, resIdArray_Count;

typedef struct CheckResUpdateRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *resIdArray;
} CheckResUpdateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resIdArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CheckResUpdateRequest_ResID),
        .number = CheckResUpdateRequest_FieldNumber_ResIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest__storage_, resIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckResUpdateRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckResUpdateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000resId\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckResUpdateRequest_ResID

@implementation CheckResUpdateRequest_ResID

@dynamic hasType, type;
@dynamic subTypeVectorArray, subTypeVectorArray_Count;

typedef struct CheckResUpdateRequest_ResID__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSMutableArray *subTypeVectorArray;
} CheckResUpdateRequest_ResID__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subTypeVectorArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CheckResUpdateRequest_ResID_SubTypeVector),
        .number = CheckResUpdateRequest_ResID_FieldNumber_SubTypeVectorArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID__storage_, subTypeVectorArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckResUpdateRequest_ResID class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckResUpdateRequest_ResID__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000subTypeVector\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CheckResUpdateRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckResUpdateRequest_ResID_SubTypeVector

@implementation CheckResUpdateRequest_ResID_SubTypeVector

@dynamic hasSubType, subType;
@dynamic hasKeyVersion, keyVersion;
@dynamic hasResVersion, resVersion;
@dynamic hasEid, eid;

typedef struct CheckResUpdateRequest_ResID_SubTypeVector__storage_ {
  uint32_t _has_storage_[1];
  int32_t subType;
  int32_t keyVersion;
  int32_t resVersion;
  int32_t eid;
} CheckResUpdateRequest_ResID_SubTypeVector__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subType",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_SubTypeVector_FieldNumber_SubType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID_SubTypeVector__storage_, subType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "keyVersion",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_SubTypeVector_FieldNumber_KeyVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID_SubTypeVector__storage_, keyVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "resVersion",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_SubTypeVector_FieldNumber_ResVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID_SubTypeVector__storage_, resVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "eid",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_SubTypeVector_FieldNumber_Eid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID_SubTypeVector__storage_, eid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckResUpdateRequest_ResID_SubTypeVector class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckResUpdateRequest_ResID_SubTypeVector__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\007\000\002\n\000\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CheckResUpdateRequest_ResID)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsObject

@implementation SnsObject

@dynamic hasId_p, id_p;
@dynamic hasUsername, username;
@dynamic hasNickname, nickname;
@dynamic hasCreateTime, createTime;
@dynamic hasObjectDesc, objectDesc;
@dynamic hasExtFlag, extFlag;
@dynamic hasObjectOperations, objectOperations;

typedef struct SnsObject__storage_ {
  uint32_t _has_storage_[1];
  int32_t createTime;
  int32_t extFlag;
  NSString *username;
  NSString *nickname;
  SKBuiltinBuffer_t *objectDesc;
  SKBuiltinString_t *objectOperations;
  uint64_t id_p;
} SnsObject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsObject__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_Username,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsObject__storage_, username),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_Nickname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SnsObject__storage_, nickname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SnsObject__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "objectDesc",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = SnsObject_FieldNumber_ObjectDesc,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SnsObject__storage_, objectDesc),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extFlag",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_ExtFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SnsObject__storage_, extFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "objectOperations",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = SnsObject_FieldNumber_ObjectOperations,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SnsObject__storage_, objectOperations),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsObject class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsObject__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\004\n\000\005\n\000\020\007\000\034\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsTimeLineRequest

@implementation SnsTimeLineRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasFirstPageMd5, firstPageMd5;
@dynamic hasMinFilterId, minFilterId;
@dynamic hasMaxId, maxId;
@dynamic hasLastRequestTime, lastRequestTime;
@dynamic hasClientLatestId, clientLatestId;
@dynamic hasSession, session;
@dynamic hasNetworkType, networkType;
@dynamic hasAdexpinfo, adexpinfo;

typedef struct SnsTimeLineRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t minFilterId;
  int32_t maxId;
  int32_t lastRequestTime;
  int32_t networkType;
  BaseRequest *baseRequest;
  NSString *firstPageMd5;
  SKBuiltinBuffer_t *session;
  NSString *adexpinfo;
  int64_t clientLatestId;
} SnsTimeLineRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = SnsTimeLineRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "firstPageMd5",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_FirstPageMd5,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, firstPageMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minFilterId",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_MinFilterId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, minFilterId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxId",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_MaxId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, maxId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastRequestTime",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_LastRequestTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, lastRequestTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientLatestId",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_ClientLatestId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, clientLatestId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = SnsTimeLineRequest_FieldNumber_Session,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkType",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_NetworkType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, networkType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "adexpinfo",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_Adexpinfo,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, adexpinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsTimeLineRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsTimeLineRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\013\000\002\014\000\003\013\000\004\005\000\005\017\000\006\016\000\010\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsTimeLineResponse

@implementation SnsTimeLineResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasFirstPageMd5, firstPageMd5;
@dynamic hasObjectCount, objectCount;
@dynamic objectListArray, objectListArray_Count;
@dynamic hasNewRequestTime, newRequestTime;
@dynamic hasObjectCountForSameMd5, objectCountForSameMd5;
@dynamic hasControlFlag, controlFlag;
@dynamic hasServerConfig, serverConfig;
@dynamic hasRecCount, recCount;
@dynamic hasSession, session;

typedef struct SnsTimeLineResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t objectCount;
  int32_t newRequestTime;
  int32_t objectCountForSameMd5;
  int32_t controlFlag;
  int32_t recCount;
  BaseResponse *baseResponse;
  NSString *firstPageMd5;
  NSMutableArray *objectListArray;
  SnsTimeLineResponse_SnsServerConfig *serverConfig;
  NSData *session;
} SnsTimeLineResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = SnsTimeLineResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "firstPageMd5",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_FirstPageMd5,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, firstPageMd5),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "objectCount",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_ObjectCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, objectCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "objectListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SnsObject),
        .number = SnsTimeLineResponse_FieldNumber_ObjectListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, objectListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newRequestTime",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_NewRequestTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, newRequestTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "objectCountForSameMd5",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_ObjectCountForSameMd5,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, objectCountForSameMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "controlFlag",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_ControlFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, controlFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "serverConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(SnsTimeLineResponse_SnsServerConfig),
        .number = SnsTimeLineResponse_FieldNumber_ServerConfig,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, serverConfig),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recCount",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_RecCount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, recCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_Session,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsTimeLineResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsTimeLineResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001\014\000\002\014\000\003\013\000\004\000objectList\000\005\016\000\006\025\000\007\013\000\010\014\000\t\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsTimeLineResponse_SnsServerConfig

@implementation SnsTimeLineResponse_SnsServerConfig

@dynamic hasPostMentionLimit, postMentionLimit;
@dynamic hasCopyAndPasteWordLimit, copyAndPasteWordLimit;

typedef struct SnsTimeLineResponse_SnsServerConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t postMentionLimit;
  int32_t copyAndPasteWordLimit;
} SnsTimeLineResponse_SnsServerConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "postMentionLimit",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_SnsServerConfig_FieldNumber_PostMentionLimit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse_SnsServerConfig__storage_, postMentionLimit),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "copyAndPasteWordLimit",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_SnsServerConfig_FieldNumber_CopyAndPasteWordLimit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse_SnsServerConfig__storage_, copyAndPasteWordLimit),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsTimeLineResponse_SnsServerConfig class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsTimeLineResponse_SnsServerConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\020\000\002\025\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SnsTimeLineResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindOpMobileRequest

@implementation BindOpMobileRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasMobile, mobile;
@dynamic hasOpcode, opcode;
@dynamic hasVerifycode, verifycode;
@dynamic hasDialFlag, dialFlag;
@dynamic hasDialLang, dialLang;
@dynamic hasAuthTicket, authTicket;
@dynamic hasForceReg, forceReg;
@dynamic hasSafeDeviceName, safeDeviceName;
@dynamic hasSafeDeviceType, safeDeviceType;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasLanguage, language;
@dynamic hasInputMobileRetrys, inputMobileRetrys;
@dynamic hasAdjustRet, adjustRet;
@dynamic hasClientSeqId, clientSeqId;
@dynamic hasMobileCheckType, mobileCheckType;
@dynamic hasUnkownString18, unkownString18;
@dynamic hasExtSpamInfo, extSpamInfo;

typedef struct BindOpMobileRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t opcode;
  int32_t dialFlag;
  int32_t forceReg;
  int32_t inputMobileRetrys;
  int32_t adjustRet;
  int32_t mobileCheckType;
  BaseRequest *baseRequest;
  NSString *userName;
  NSString *mobile;
  NSString *verifycode;
  NSString *dialLang;
  NSString *authTicket;
  NSString *safeDeviceName;
  NSString *safeDeviceType;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *language;
  NSString *clientSeqId;
  NSString *unkownString18;
  SKBuiltinBuffer_t *extSpamInfo;
} BindOpMobileRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BindOpMobileRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobile",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_Mobile,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, mobile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_Opcode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, opcode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "verifycode",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_Verifycode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, verifycode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dialFlag",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_DialFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, dialFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dialLang",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_DialLang,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, dialLang),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_AuthTicket,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, authTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "forceReg",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_ForceReg,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, forceReg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "safeDeviceName",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_SafeDeviceName,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, safeDeviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "safeDeviceType",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_SafeDeviceType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, safeDeviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindOpMobileRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_Language,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, language),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputMobileRetrys",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_InputMobileRetrys,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, inputMobileRetrys),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "adjustRet",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_AdjustRet,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, adjustRet),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_ClientSeqId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobileCheckType",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_MobileCheckType,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, mobileCheckType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "unkownString18",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_UnkownString18,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, unkownString18),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extSpamInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindOpMobileRequest_FieldNumber_ExtSpamInfo,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, extSpamInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindOpMobileRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindOpMobileRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\017\001\013\000\002\010\000\006\010\000\007\010\000\010\n\000\t\010\000\n\016\000\013\016\000\014\016\000\016\021\000\017\t\000\020\013\000\021\017\000"
        "\022\016\000\024\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindOpMobileResponse

@implementation BindOpMobileResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasTicket, ticket;
@dynamic hasSmsNo, smsNo;
@dynamic hasNeedSetPwd, needSetPwd;
@dynamic hasPwd, pwd;
@dynamic hasUsername, username;
@dynamic hasBuiltinIplist, builtinIplist;
@dynamic hasNewHostList, newHostList;
@dynamic hasNetworkControl, networkControl;
@dynamic hasAuthTicket, authTicket;
@dynamic hasSafeDevice, safeDevice;
@dynamic hasCc, cc;
@dynamic hasObsoleteItem1, obsoleteItem1;
@dynamic hasSafeDeviceList, safeDeviceList;
@dynamic hasPureMobile, pureMobile;
@dynamic hasFormatedMobile, formatedMobile;
@dynamic hasShowStyle, showStyle;
@dynamic hasMmtlsControlBitFlag, mmtlsControlBitFlag;
@dynamic hasSmsUpCode, smsUpCode;
@dynamic hasSmsUpMobile, smsUpMobile;
@dynamic hasMobileCheckType, mobileCheckType;
@dynamic hasRegSessionId, regSessionId;

typedef struct BindOpMobileResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t needSetPwd;
  int32_t safeDevice;
  int32_t obsoleteItem1;
  int32_t mmtlsControlBitFlag;
  int32_t mobileCheckType;
  BaseResponse *baseResponse;
  NSString *ticket;
  NSString *smsNo;
  NSString *pwd;
  NSString *username;
  BindOpMobileResponse_NewHostList *newHostList;
  BuiltinIPList *builtinIplist;
  NetworkControl *networkControl;
  NSString *authTicket;
  NSString *cc;
  BindOpMobileResponse_SafeDeviceList *safeDeviceList;
  NSString *pureMobile;
  NSString *formatedMobile;
  BindOpMobileResponse_ShowStyle *showStyle;
  NSString *smsUpCode;
  NSString *smsUpMobile;
  NSString *regSessionId;
} BindOpMobileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BindOpMobileResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_Ticket,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, ticket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smsNo",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_SmsNo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, smsNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "needSetPwd",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_NeedSetPwd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, needSetPwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_Pwd,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, pwd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_Username,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, username),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newHostList",
        .dataTypeSpecific.className = GPBStringifySymbol(BindOpMobileResponse_NewHostList),
        .number = BindOpMobileResponse_FieldNumber_NewHostList,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, newHostList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "builtinIplist",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList),
        .number = BindOpMobileResponse_FieldNumber_BuiltinIplist,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, builtinIplist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkControl",
        .dataTypeSpecific.className = GPBStringifySymbol(NetworkControl),
        .number = BindOpMobileResponse_FieldNumber_NetworkControl,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, networkControl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_AuthTicket,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, authTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "safeDevice",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_SafeDevice,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, safeDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cc",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_Cc,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, cc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "obsoleteItem1",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_ObsoleteItem1,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, obsoleteItem1),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "safeDeviceList",
        .dataTypeSpecific.className = GPBStringifySymbol(BindOpMobileResponse_SafeDeviceList),
        .number = BindOpMobileResponse_FieldNumber_SafeDeviceList,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, safeDeviceList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pureMobile",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_PureMobile,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, pureMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "formatedMobile",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_FormatedMobile,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, formatedMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "showStyle",
        .dataTypeSpecific.className = GPBStringifySymbol(BindOpMobileResponse_ShowStyle),
        .number = BindOpMobileResponse_FieldNumber_ShowStyle,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, showStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mmtlsControlBitFlag",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_MmtlsControlBitFlag,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, mmtlsControlBitFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "smsUpCode",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_SmsUpCode,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, smsUpCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smsUpMobile",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_SmsUpMobile,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, smsUpMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobileCheckType",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_MobileCheckType,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, mobileCheckType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "regSessionId",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_RegSessionId,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, regSessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindOpMobileResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindOpMobileResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\022\001\014\000\003\005\000\004\n\000\007\013\000\010\r\000\t\016\000\n\n\000\013\n\000\r\r\000\016\016\000\017\n\000\020\016\000\021\t\000"
        "\022\023\000\023\t\000\024\013\000\025\017\000\026\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindOpMobileResponse_NewHostList

@implementation BindOpMobileResponse_NewHostList

@dynamic hasCount, count;

typedef struct BindOpMobileResponse_NewHostList__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
} BindOpMobileResponse_NewHostList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_NewHostList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindOpMobileResponse_NewHostList__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindOpMobileResponse_NewHostList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindOpMobileResponse_NewHostList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(BindOpMobileResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindOpMobileResponse_SafeDeviceList

@implementation BindOpMobileResponse_SafeDeviceList

@dynamic hasCount, count;

typedef struct BindOpMobileResponse_SafeDeviceList__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
} BindOpMobileResponse_SafeDeviceList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_SafeDeviceList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindOpMobileResponse_SafeDeviceList__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindOpMobileResponse_SafeDeviceList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindOpMobileResponse_SafeDeviceList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(BindOpMobileResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindOpMobileResponse_ShowStyle

@implementation BindOpMobileResponse_ShowStyle

@dynamic hasKeyCount, keyCount;

typedef struct BindOpMobileResponse_ShowStyle__storage_ {
  uint32_t _has_storage_[1];
  int32_t keyCount;
} BindOpMobileResponse_ShowStyle__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyCount",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_ShowStyle_FieldNumber_KeyCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindOpMobileResponse_ShowStyle__storage_, keyCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindOpMobileResponse_ShowStyle class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindOpMobileResponse_ShowStyle__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(BindOpMobileResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
