syntax = "proto2";

package micromsg;

import "mmbuiltintype.proto";

// encryptchecktinkerupdate(180)
// encryptcheckresupdate(722) CheckResUpdateRequest CheckResUpdateResponse

message SubTypeVector
{
    optional int32 subType              = 1;
    optional int32 keyVersion           = 2;
    optional int32 resVersion           = 3;
    optional int32 eid                  = 4;
}

message ResID
{
    optional int32 type                     = 1;
    repeated SubTypeVector subTypeVector    = 2;
}

message ResIDWrap {
    repeated ResID resId                        = 1;
}

// cgi: 721
message CheckResUpdateRequest {
    required BaseRequest baseRequest            = 1;
    optional ResIDWrap wrap = 2;
}

message CheckResUpdateResponse {
    required BaseResponse baseResponse = 1;
}

message EncryptKey {
    optional SKBuiltinBuffer_t key = 1;
}

// sec
message SecEncryptCheckResUpdateRequest {
    optional EncryptKey aesEncryptKey = 1;
    optional CheckResUpdateRequest req = 2;
}

message ResourceMeta {
    optional string md5 = 1;
    optional uint32 resVersion = 2;
    optional string url = 3;
    optional uint32 fileFlag = 4;
    //        eccmd5SignatureList = 5;
    optional bytes data = 6;
    optional string originalMd5 = 7;
    optional uint32 fileSize = 8;
}

message Resource {
    optional uint32 subType = 1;
    optional ResourceMeta info = 2;
    
    message ResourceKey {
        optional uint32 keyVersion = 1;
        optional string resKey = 2;
    }
    
    optional ResourceKey key = 3;
    optional uint32 oper = 4;
    optional uint32 reportId = 5;
    optional string sampleId = 6;
    optional uint32 expireTime = 7;
    optional uint32 retryTime = 8;
    optional uint32 eid = 9;
    optional uint32 downloadNetType = 10;
    optional uint32 retryInterval = 11;
    optional uint32 priority = 12;
}

message ResourceType
{
    required uint32 type = 1;
    repeated Resource resources = 2;
}

message SecEncryptCheckResUpdateResponse {
    required BaseResponse BaseResponse = 1;
    repeated ResourceType ResourceType = 2;
}

message TinkerCondition {
    optional string key = 1;
    optional string value = 2;
    optional string op = 3;
//    repeated values = 4;
}

message CheckTinkerUpdateRequest {
    optional string baseid = 1;
    optional string patchid = 2;
    repeated TinkerCondition condition = 3;
}

message TinkerPatchNode {
    optional string patchid = 1;
    optional uint32 state = 2;
    optional uint32 packagetype = 4;
    optional uint32 network = 5;
    optional ResourceMeta info = 6;
    optional uint32 maxdown = 7;
//    repeated custom = 8;
    optional bool releaseall = 9;
}

message CheckTinkerUpdateResponse {
    required BaseResponse BaseResponse = 1;
    optional TinkerPatchNode patch = 2;
}
