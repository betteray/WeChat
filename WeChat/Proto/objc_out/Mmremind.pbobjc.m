// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmremind.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mmremind.pbobjc.h"
#import "Mmbuiltintype.pbobjc.h"
#import "Mmbase.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmremindRoot

@implementation MmremindRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MmremindRoot_FileDescriptor

static GPBFileDescriptor *MmremindRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"micromsg"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - RemindSyncRequest

@implementation RemindSyncRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasSelector, selector;
@dynamic hasKeyBuff, keyBuff;

typedef struct RemindSyncRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t selector;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *keyBuff;
} RemindSyncRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = RemindSyncRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemindSyncRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "selector",
        .dataTypeSpecific.className = NULL,
        .number = RemindSyncRequest_FieldNumber_Selector,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RemindSyncRequest__storage_, selector),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "keyBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = RemindSyncRequest_FieldNumber_KeyBuff,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RemindSyncRequest__storage_, keyBuff),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemindSyncRequest class]
                                     rootClass:[MmremindRoot class]
                                          file:MmremindRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemindSyncRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002H\000\003G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemindSyncResponse

@implementation RemindSyncResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCmdList, cmdList;
@dynamic hasKeyBuff, keyBuff;
@dynamic hasContinueFlag, continueFlag;

typedef struct RemindSyncResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t continueFlag;
  BaseResponse *baseResponse;
  CmdList *cmdList;
  SKBuiltinBuffer_t *keyBuff;
} RemindSyncResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = RemindSyncResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemindSyncResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cmdList",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdList),
        .number = RemindSyncResponse_FieldNumber_CmdList,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RemindSyncResponse__storage_, cmdList),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "keyBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = RemindSyncResponse_FieldNumber_KeyBuff,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RemindSyncResponse__storage_, keyBuff),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "continueFlag",
        .dataTypeSpecific.className = NULL,
        .number = RemindSyncResponse_FieldNumber_ContinueFlag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RemindSyncResponse__storage_, continueFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemindSyncResponse class]
                                     rootClass:[MmremindRoot class]
                                          file:MmremindRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemindSyncResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001L\000\002G\000\003G\000\004L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModRemindCmd

@implementation ModRemindCmd

@dynamic hasRemindId, remindId;
@dynamic hasRemindTime, remindTime;
@dynamic hasFlag, flag;

typedef struct ModRemindCmd__storage_ {
  uint32_t _has_storage_[1];
  uint32_t remindId;
  uint32_t flag;
  uint64_t remindTime;
} ModRemindCmd__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "remindId",
        .dataTypeSpecific.className = NULL,
        .number = ModRemindCmd_FieldNumber_RemindId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModRemindCmd__storage_, remindId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "remindTime",
        .dataTypeSpecific.className = NULL,
        .number = ModRemindCmd_FieldNumber_RemindTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModRemindCmd__storage_, remindTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = ModRemindCmd_FieldNumber_Flag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModRemindCmd__storage_, flag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModRemindCmd class]
                                     rootClass:[MmremindRoot class]
                                          file:MmremindRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModRemindCmd__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001GA\000\002J\000\003D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemindMember

@implementation RemindMember

@dynamic hasUserName, userName;

typedef struct RemindMember__storage_ {
  uint32_t _has_storage_[1];
  NSString *userName;
} RemindMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = RemindMember_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemindMember__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemindMember class]
                                     rootClass:[MmremindRoot class]
                                          file:MmremindRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemindMember__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemindItem

@implementation RemindItem

@dynamic hasRemindId, remindId;
@dynamic hasCreateTime, createTime;
@dynamic hasRemindTime, remindTime;
@dynamic hasFromUser, fromUser;
@dynamic hasToUserCount, toUserCount;
@dynamic toUserListArray, toUserListArray_Count;
@dynamic hasFlag, flag;
@dynamic hasContent, content;

typedef struct RemindItem__storage_ {
  uint32_t _has_storage_[1];
  uint32_t remindId;
  uint32_t createTime;
  uint32_t toUserCount;
  uint32_t flag;
  NSString *fromUser;
  NSMutableArray *toUserListArray;
  NSString *content;
  uint64_t remindTime;
} RemindItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "remindId",
        .dataTypeSpecific.className = NULL,
        .number = RemindItem_FieldNumber_RemindId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemindItem__storage_, remindId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = RemindItem_FieldNumber_CreateTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RemindItem__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "remindTime",
        .dataTypeSpecific.className = NULL,
        .number = RemindItem_FieldNumber_RemindTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RemindItem__storage_, remindTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fromUser",
        .dataTypeSpecific.className = NULL,
        .number = RemindItem_FieldNumber_FromUser,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RemindItem__storage_, fromUser),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "toUserCount",
        .dataTypeSpecific.className = NULL,
        .number = RemindItem_FieldNumber_ToUserCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RemindItem__storage_, toUserCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "toUserListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RemindMember),
        .number = RemindItem_FieldNumber_ToUserListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RemindItem__storage_, toUserListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = RemindItem_FieldNumber_Flag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RemindItem__storage_, flag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = RemindItem_FieldNumber_Content,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RemindItem__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemindItem class]
                                     rootClass:[MmremindRoot class]
                                          file:MmremindRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemindItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001GA\000\002J\000\003J\000\004H\000\005K\000\006\000ToUserList\000\007D\000\010G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchGetRemindInfoRequest

@implementation BatchGetRemindInfoRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRemindIdcount, remindIdcount;
@dynamic remindIdlistArray, remindIdlistArray_Count;

typedef struct BatchGetRemindInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t remindIdcount;
  BaseRequest *baseRequest;
  GPBUInt32Array *remindIdlistArray;
} BatchGetRemindInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BatchGetRemindInfoRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchGetRemindInfoRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remindIdcount",
        .dataTypeSpecific.className = NULL,
        .number = BatchGetRemindInfoRequest_FieldNumber_RemindIdcount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BatchGetRemindInfoRequest__storage_, remindIdcount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "remindIdlistArray",
        .dataTypeSpecific.className = NULL,
        .number = BatchGetRemindInfoRequest_FieldNumber_RemindIdlistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchGetRemindInfoRequest__storage_, remindIdlistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchGetRemindInfoRequest class]
                                     rootClass:[MmremindRoot class]
                                          file:MmremindRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchGetRemindInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002Gb\004\000\003\000RemindIDList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchGetRemindInfoResponse

@implementation BatchGetRemindInfoResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasRemindInfoCount, remindInfoCount;
@dynamic remindInfoListArray, remindInfoListArray_Count;

typedef struct BatchGetRemindInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t remindInfoCount;
  BaseResponse *baseResponse;
  NSMutableArray *remindInfoListArray;
} BatchGetRemindInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BatchGetRemindInfoResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchGetRemindInfoResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remindInfoCount",
        .dataTypeSpecific.className = NULL,
        .number = BatchGetRemindInfoResponse_FieldNumber_RemindInfoCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BatchGetRemindInfoResponse__storage_, remindInfoCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "remindInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RemindItem),
        .number = BatchGetRemindInfoResponse_FieldNumber_RemindInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchGetRemindInfoResponse__storage_, remindInfoListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchGetRemindInfoResponse class]
                                     rootClass:[MmremindRoot class]
                                          file:MmremindRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchGetRemindInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002O\000\003\000RemindInfoList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddRemindRequest

@implementation AddRemindRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasClientId, clientId;
@dynamic hasRemindTime, remindTime;
@dynamic hasToUserCount, toUserCount;
@dynamic toUserListArray, toUserListArray_Count;
@dynamic hasContent, content;

typedef struct AddRemindRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t toUserCount;
  BaseRequest *baseRequest;
  NSString *clientId;
  NSMutableArray *toUserListArray;
  NSString *content;
  uint64_t remindTime;
} AddRemindRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = AddRemindRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddRemindRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientId",
        .dataTypeSpecific.className = NULL,
        .number = AddRemindRequest_FieldNumber_ClientId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddRemindRequest__storage_, clientId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remindTime",
        .dataTypeSpecific.className = NULL,
        .number = AddRemindRequest_FieldNumber_RemindTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddRemindRequest__storage_, remindTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "toUserCount",
        .dataTypeSpecific.className = NULL,
        .number = AddRemindRequest_FieldNumber_ToUserCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddRemindRequest__storage_, toUserCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "toUserListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RemindMember),
        .number = AddRemindRequest_FieldNumber_ToUserListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddRemindRequest__storage_, toUserListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = AddRemindRequest_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AddRemindRequest__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddRemindRequest class]
                                     rootClass:[MmremindRoot class]
                                          file:MmremindRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddRemindRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001K\000\002GA\000\003J\000\004K\000\005\000ToUserList\000\006G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddRemindResponse

@implementation AddRemindResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct AddRemindResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} AddRemindResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = AddRemindResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddRemindResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddRemindResponse class]
                                     rootClass:[MmremindRoot class]
                                          file:MmremindRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddRemindResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelRemindRequest

@implementation DelRemindRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRemindId, remindId;

typedef struct DelRemindRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t remindId;
  BaseRequest *baseRequest;
} DelRemindRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = DelRemindRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelRemindRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remindId",
        .dataTypeSpecific.className = NULL,
        .number = DelRemindRequest_FieldNumber_RemindId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelRemindRequest__storage_, remindId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelRemindRequest class]
                                     rootClass:[MmremindRoot class]
                                          file:MmremindRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelRemindRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002GA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelRemindResponse

@implementation DelRemindResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct DelRemindResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} DelRemindResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = DelRemindResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelRemindResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelRemindResponse class]
                                     rootClass:[MmremindRoot class]
                                          file:MmremindRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelRemindResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
