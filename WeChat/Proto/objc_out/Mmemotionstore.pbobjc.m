// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmemotionstore.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mmemotionstore.pbobjc.h"
#import "Mmbuiltintype.pbobjc.h"
#import "Mmbase.pbobjc.h"
#import "Mmemotion.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmemotionstoreRoot

@implementation MmemotionstoreRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MmemotionstoreRoot_FileDescriptor

static GPBFileDescriptor *MmemotionstoreRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"micromsg"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - JumpEmotionDetailRequest

@implementation JumpEmotionDetailRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasURL, URL;

typedef struct JumpEmotionDetailRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *URL;
} JumpEmotionDetailRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = JumpEmotionDetailRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(JumpEmotionDetailRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = JumpEmotionDetailRequest_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(JumpEmotionDetailRequest__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JumpEmotionDetailRequest class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(JumpEmotionDetailRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002\001!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - JumpEmotionDetailResponse

@implementation JumpEmotionDetailResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasProductId, productId;

typedef struct JumpEmotionDetailResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *productId;
} JumpEmotionDetailResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = JumpEmotionDetailResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(JumpEmotionDetailResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = JumpEmotionDetailResponse_FieldNumber_ProductId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(JumpEmotionDetailResponse__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JumpEmotionDetailResponse class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(JumpEmotionDetailResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002HA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchEmojiBackupRequest

@implementation BatchEmojiBackupRequest

@dynamic md5ListArray, md5ListArray_Count;

typedef struct BatchEmojiBackupRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *md5ListArray;
} BatchEmojiBackupRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "md5ListArray",
        .dataTypeSpecific.className = NULL,
        .number = BatchEmojiBackupRequest_FieldNumber_Md5ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchEmojiBackupRequest__storage_, md5ListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchEmojiBackupRequest class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchEmojiBackupRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000Md5List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchEmojiBackupResponse

@implementation BatchEmojiBackupResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic needUploadMd5ListArray, needUploadMd5ListArray_Count;

typedef struct BatchEmojiBackupResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSMutableArray *needUploadMd5ListArray;
} BatchEmojiBackupResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BatchEmojiBackupResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchEmojiBackupResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "needUploadMd5ListArray",
        .dataTypeSpecific.className = NULL,
        .number = BatchEmojiBackupResponse_FieldNumber_NeedUploadMd5ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchEmojiBackupResponse__storage_, needUploadMd5ListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchEmojiBackupResponse class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchEmojiBackupResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002\000NeedUploadMd5List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchEmojiDownLoadRequest

@implementation BatchEmojiDownLoadRequest

@dynamic hasIndex, index;

typedef struct BatchEmojiDownLoadRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
} BatchEmojiDownLoadRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = BatchEmojiDownLoadRequest_FieldNumber_Index,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchEmojiDownLoadRequest__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchEmojiDownLoadRequest class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchEmojiDownLoadRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmojiInfo

@implementation EmojiInfo

@dynamic hasMd5, md5;
@dynamic hasURL, URL;

typedef struct EmojiInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *md5;
  NSString *URL;
} EmojiInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "md5",
        .dataTypeSpecific.className = NULL,
        .number = EmojiInfo_FieldNumber_Md5,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmojiInfo__storage_, md5),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = EmojiInfo_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmojiInfo__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmojiInfo class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmojiInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001C\000\002\001!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchEmojiDownLoadResponse

@implementation BatchEmojiDownLoadResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasIndex, index;
@dynamic md5ListArray, md5ListArray_Count;
@dynamic hasEndFlag, endFlag;
@dynamic emojiListArray, emojiListArray_Count;

typedef struct BatchEmojiDownLoadResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t index;
  uint32_t endFlag;
  BaseResponse *baseResponse;
  NSMutableArray *md5ListArray;
  NSMutableArray *emojiListArray;
} BatchEmojiDownLoadResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BatchEmojiDownLoadResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchEmojiDownLoadResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "index",
        .dataTypeSpecific.className = NULL,
        .number = BatchEmojiDownLoadResponse_FieldNumber_Index,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BatchEmojiDownLoadResponse__storage_, index),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "md5ListArray",
        .dataTypeSpecific.className = NULL,
        .number = BatchEmojiDownLoadResponse_FieldNumber_Md5ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchEmojiDownLoadResponse__storage_, md5ListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endFlag",
        .dataTypeSpecific.className = NULL,
        .number = BatchEmojiDownLoadResponse_FieldNumber_EndFlag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BatchEmojiDownLoadResponse__storage_, endFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "emojiListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EmojiInfo),
        .number = BatchEmojiDownLoadResponse_FieldNumber_EmojiListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchEmojiDownLoadResponse__storage_, emojiListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchEmojiDownLoadResponse class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchEmojiDownLoadResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001L\000\002E\000\003\000Md5List\000\004G\000\005\000EmojiList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupEmojiOperateRequest

@implementation BackupEmojiOperateRequest

@dynamic md5ListArray, md5ListArray_Count;
@dynamic hasOpcode, opcode;

typedef struct BackupEmojiOperateRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opcode;
  NSMutableArray *md5ListArray;
} BackupEmojiOperateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "md5ListArray",
        .dataTypeSpecific.className = NULL,
        .number = BackupEmojiOperateRequest_FieldNumber_Md5ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BackupEmojiOperateRequest__storage_, md5ListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = BackupEmojiOperateRequest_FieldNumber_Opcode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupEmojiOperateRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupEmojiOperateRequest class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupEmojiOperateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000Md5List\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupEmojiOperateResponse

@implementation BackupEmojiOperateResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic needUploadMd5ListArray, needUploadMd5ListArray_Count;

typedef struct BackupEmojiOperateResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSMutableArray *needUploadMd5ListArray;
} BackupEmojiOperateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BackupEmojiOperateResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupEmojiOperateResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "needUploadMd5ListArray",
        .dataTypeSpecific.className = NULL,
        .number = BackupEmojiOperateResponse_FieldNumber_NeedUploadMd5ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BackupEmojiOperateResponse__storage_, needUploadMd5ListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupEmojiOperateResponse class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupEmojiOperateResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002\000NeedUploadMd5List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UploadEmojiInfoReq

@implementation UploadEmojiInfoReq

@dynamic hasMd5, md5;
@dynamic hasStartPos, startPos;
@dynamic hasTotalLen, totalLen;
@dynamic hasEmojiBuffer, emojiBuffer;

typedef struct UploadEmojiInfoReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t startPos;
  int32_t totalLen;
  NSString *md5;
  NSData *emojiBuffer;
} UploadEmojiInfoReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "md5",
        .dataTypeSpecific.className = NULL,
        .number = UploadEmojiInfoReq_FieldNumber_Md5,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UploadEmojiInfoReq__storage_, md5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startPos",
        .dataTypeSpecific.className = NULL,
        .number = UploadEmojiInfoReq_FieldNumber_StartPos,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UploadEmojiInfoReq__storage_, startPos),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "totalLen",
        .dataTypeSpecific.className = NULL,
        .number = UploadEmojiInfoReq_FieldNumber_TotalLen,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UploadEmojiInfoReq__storage_, totalLen),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "emojiBuffer",
        .dataTypeSpecific.className = NULL,
        .number = UploadEmojiInfoReq_FieldNumber_EmojiBuffer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UploadEmojiInfoReq__storage_, emojiBuffer),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UploadEmojiInfoReq class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UploadEmojiInfoReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001b\001\000\002H\000\003H\000\004K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmojiUploadRequest

@implementation EmojiUploadRequest

@dynamic emojiItemArray, emojiItemArray_Count;
@dynamic hasReqTime, reqTime;

typedef struct EmojiUploadRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t reqTime;
  NSMutableArray *emojiItemArray;
} EmojiUploadRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "emojiItemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UploadEmojiInfoReq),
        .number = EmojiUploadRequest_FieldNumber_EmojiItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EmojiUploadRequest__storage_, emojiItemArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reqTime",
        .dataTypeSpecific.className = NULL,
        .number = EmojiUploadRequest_FieldNumber_ReqTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmojiUploadRequest__storage_, reqTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmojiUploadRequest class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmojiUploadRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000EmojiItem\000\002G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UploadEmojiInfoResp

@implementation UploadEmojiInfoResp

@dynamic hasRet, ret;
@dynamic hasStartPos, startPos;
@dynamic hasTotalLen, totalLen;
@dynamic hasMd5, md5;

typedef struct UploadEmojiInfoResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  int32_t startPos;
  int32_t totalLen;
  NSString *md5;
} UploadEmojiInfoResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = UploadEmojiInfoResp_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UploadEmojiInfoResp__storage_, ret),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startPos",
        .dataTypeSpecific.className = NULL,
        .number = UploadEmojiInfoResp_FieldNumber_StartPos,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UploadEmojiInfoResp__storage_, startPos),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "totalLen",
        .dataTypeSpecific.className = NULL,
        .number = UploadEmojiInfoResp_FieldNumber_TotalLen,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UploadEmojiInfoResp__storage_, totalLen),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "md5",
        .dataTypeSpecific.className = NULL,
        .number = UploadEmojiInfoResp_FieldNumber_Md5,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UploadEmojiInfoResp__storage_, md5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UploadEmojiInfoResp class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UploadEmojiInfoResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001C\000\002H\000\003H\000\004b\001\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmojiUploadResponse

@implementation EmojiUploadResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic emojiItemArray, emojiItemArray_Count;

typedef struct EmojiUploadResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSMutableArray *emojiItemArray;
} EmojiUploadResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = EmojiUploadResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmojiUploadResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "emojiItemArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UploadEmojiInfoResp),
        .number = EmojiUploadResponse_FieldNumber_EmojiItemArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EmojiUploadResponse__storage_, emojiItemArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmojiUploadResponse class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmojiUploadResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002\000EmojiItem\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UploadMyPanelListRequest

@implementation UploadMyPanelListRequest

@dynamic hasOpCode, opCode;
@dynamic productIdlistArray, productIdlistArray_Count;

typedef struct UploadMyPanelListRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opCode;
  NSMutableArray *productIdlistArray;
} UploadMyPanelListRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "opCode",
        .dataTypeSpecific.className = NULL,
        .number = UploadMyPanelListRequest_FieldNumber_OpCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UploadMyPanelListRequest__storage_, opCode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "productIdlistArray",
        .dataTypeSpecific.className = NULL,
        .number = UploadMyPanelListRequest_FieldNumber_ProductIdlistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(UploadMyPanelListRequest__storage_, productIdlistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UploadMyPanelListRequest class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UploadMyPanelListRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001F\000\002\000ProductIDList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UploadMyPanelListResponse

@implementation UploadMyPanelListResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct UploadMyPanelListResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} UploadMyPanelListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = UploadMyPanelListResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UploadMyPanelListResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UploadMyPanelListResponse class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UploadMyPanelListResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPersonalDesignerRequest

@implementation GetPersonalDesignerRequest

@dynamic hasDesignerUin, designerUin;
@dynamic hasReqBuf, reqBuf;

typedef struct GetPersonalDesignerRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t designerUin;
  SKBuiltinBuffer_t *reqBuf;
} GetPersonalDesignerRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "designerUin",
        .dataTypeSpecific.className = NULL,
        .number = GetPersonalDesignerRequest_FieldNumber_DesignerUin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPersonalDesignerRequest__storage_, designerUin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "reqBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetPersonalDesignerRequest_FieldNumber_ReqBuf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetPersonalDesignerRequest__storage_, reqBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPersonalDesignerRequest class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPersonalDesignerRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPersonalDesignerResponse

@implementation GetPersonalDesignerResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasBannerURL, bannerURL;
@dynamic hasName, name;
@dynamic hasDesc, desc;
@dynamic hasHeadURL, headURL;
@dynamic hasBizName, bizName;
@dynamic emotionListArray, emotionListArray_Count;
@dynamic hasReqBuf, reqBuf;

typedef struct GetPersonalDesignerResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *bannerURL;
  NSString *name;
  NSString *desc;
  NSString *headURL;
  NSString *bizName;
  NSMutableArray *emotionListArray;
  SKBuiltinBuffer_t *reqBuf;
} GetPersonalDesignerResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetPersonalDesignerResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPersonalDesignerResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bannerURL",
        .dataTypeSpecific.className = NULL,
        .number = GetPersonalDesignerResponse_FieldNumber_BannerURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetPersonalDesignerResponse__storage_, bannerURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GetPersonalDesignerResponse_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetPersonalDesignerResponse__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = GetPersonalDesignerResponse_FieldNumber_Desc,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetPersonalDesignerResponse__storage_, desc),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headURL",
        .dataTypeSpecific.className = NULL,
        .number = GetPersonalDesignerResponse_FieldNumber_HeadURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetPersonalDesignerResponse__storage_, headURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bizName",
        .dataTypeSpecific.className = NULL,
        .number = GetPersonalDesignerResponse_FieldNumber_BizName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetPersonalDesignerResponse__storage_, bizName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "emotionListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionSummary),
        .number = GetPersonalDesignerResponse_FieldNumber_EmotionListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetPersonalDesignerResponse__storage_, emotionListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reqBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetPersonalDesignerResponse_FieldNumber_ReqBuf,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetPersonalDesignerResponse__storage_, reqBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPersonalDesignerResponse class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPersonalDesignerResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001L\000\002G!!\000\003D\000\004D\000\005E!!\000\006G\000\007\000EmotionList\000\010F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEmotionRewardRequest

@implementation GetEmotionRewardRequest

@dynamic hasProductId, productId;
@dynamic hasOpCode, opCode;

typedef struct GetEmotionRewardRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opCode;
  NSString *productId;
} GetEmotionRewardRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionRewardRequest_FieldNumber_ProductId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEmotionRewardRequest__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opCode",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionRewardRequest_FieldNumber_OpCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetEmotionRewardRequest__storage_, opCode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEmotionRewardRequest class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEmotionRewardRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001HA\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionPrice

@implementation EmotionPrice

@dynamic hasLabel, label;
@dynamic hasNumber, number;
@dynamic hasType, type;

typedef struct EmotionPrice__storage_ {
  uint32_t _has_storage_[1];
  NSString *label;
  NSString *number;
  NSString *type;
} EmotionPrice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "label",
        .dataTypeSpecific.className = NULL,
        .number = EmotionPrice_FieldNumber_Label,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionPrice__storage_, label),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = EmotionPrice_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmotionPrice__storage_, number),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = EmotionPrice_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EmotionPrice__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionPrice class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionPrice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001E\000\002F\000\003D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionDonor

@implementation EmotionDonor

@dynamic hasHeadURL, headURL;

typedef struct EmotionDonor__storage_ {
  uint32_t _has_storage_[1];
  NSString *headURL;
} EmotionDonor__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "headURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDonor_FieldNumber_HeadURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionDonor__storage_, headURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionDonor class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionDonor__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001E!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionReward

@implementation EmotionReward

@dynamic hasBegWord, begWord;
@dynamic hasBegPicURL, begPicURL;
@dynamic hasThanksPicURL, thanksPicURL;
@dynamic hasMagicURL, magicURL;
@dynamic hasMagicWord, magicWord;
@dynamic hasMagicExpire, magicExpire;
@dynamic hasMagicLimit, magicLimit;
@dynamic hasMagicMd5, magicMd5;

typedef struct EmotionReward__storage_ {
  uint32_t _has_storage_[1];
  uint32_t magicExpire;
  uint32_t magicLimit;
  NSString *begWord;
  NSString *begPicURL;
  NSString *thanksPicURL;
  NSString *magicURL;
  NSString *magicWord;
  NSString *magicMd5;
} EmotionReward__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "begWord",
        .dataTypeSpecific.className = NULL,
        .number = EmotionReward_FieldNumber_BegWord,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionReward__storage_, begWord),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "begPicURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionReward_FieldNumber_BegPicURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmotionReward__storage_, begPicURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thanksPicURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionReward_FieldNumber_ThanksPicURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EmotionReward__storage_, thanksPicURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "magicURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionReward_FieldNumber_MagicURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EmotionReward__storage_, magicURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "magicWord",
        .dataTypeSpecific.className = NULL,
        .number = EmotionReward_FieldNumber_MagicWord,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EmotionReward__storage_, magicWord),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "magicExpire",
        .dataTypeSpecific.className = NULL,
        .number = EmotionReward_FieldNumber_MagicExpire,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EmotionReward__storage_, magicExpire),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "magicLimit",
        .dataTypeSpecific.className = NULL,
        .number = EmotionReward_FieldNumber_MagicLimit,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EmotionReward__storage_, magicLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "magicMd5",
        .dataTypeSpecific.className = NULL,
        .number = EmotionReward_FieldNumber_MagicMd5,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(EmotionReward__storage_, magicMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionReward class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionReward__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001G\000\002G!!\000\003J!!\000\004F!!\000\005I\000\006K\000\007J\000\010H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEmotionRewardResponse

@implementation GetEmotionRewardResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic priceArray, priceArray_Count;
@dynamic hasDonorNum, donorNum;
@dynamic donorsArray, donorsArray_Count;
@dynamic hasReward, reward;

typedef struct GetEmotionRewardResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t donorNum;
  BaseResponse *baseResponse;
  NSMutableArray *priceArray;
  NSMutableArray *donorsArray;
  EmotionReward *reward;
} GetEmotionRewardResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetEmotionRewardResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEmotionRewardResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "priceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionPrice),
        .number = GetEmotionRewardResponse_FieldNumber_PriceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetEmotionRewardResponse__storage_, priceArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "donorNum",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionRewardResponse_FieldNumber_DonorNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetEmotionRewardResponse__storage_, donorNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "donorsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionDonor),
        .number = GetEmotionRewardResponse_FieldNumber_DonorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetEmotionRewardResponse__storage_, donorsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reward",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionReward),
        .number = GetEmotionRewardResponse_FieldNumber_Reward,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetEmotionRewardResponse__storage_, reward),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEmotionRewardResponse class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEmotionRewardResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001L\000\002\000Price\000\003H\000\004\000Donors\000\005F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEmotionDonorListRequest

@implementation GetEmotionDonorListRequest

@dynamic hasProductId, productId;
@dynamic hasReqBuf, reqBuf;

typedef struct GetEmotionDonorListRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *productId;
  SKBuiltinBuffer_t *reqBuf;
} GetEmotionDonorListRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionDonorListRequest_FieldNumber_ProductId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEmotionDonorListRequest__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reqBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetEmotionDonorListRequest_FieldNumber_ReqBuf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetEmotionDonorListRequest__storage_, reqBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEmotionDonorListRequest class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEmotionDonorListRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001HA\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEmotionDonorListResponse

@implementation GetEmotionDonorListResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasDonorNum, donorNum;
@dynamic donorsArray, donorsArray_Count;
@dynamic hasRespBuf, respBuf;

typedef struct GetEmotionDonorListResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t donorNum;
  BaseResponse *baseResponse;
  NSMutableArray *donorsArray;
  SKBuiltinBuffer_t *respBuf;
} GetEmotionDonorListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetEmotionDonorListResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEmotionDonorListResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "donorNum",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionDonorListResponse_FieldNumber_DonorNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetEmotionDonorListResponse__storage_, donorNum),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "donorsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionDonor),
        .number = GetEmotionDonorListResponse_FieldNumber_DonorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetEmotionDonorListResponse__storage_, donorsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "respBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetEmotionDonorListResponse_FieldNumber_RespBuf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetEmotionDonorListResponse__storage_, respBuf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEmotionDonorListResponse class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEmotionDonorListResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001L\000\002H\000\003\000Donors\000\004G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AskForRewardRequest

@implementation AskForRewardRequest

@dynamic hasProductId, productId;
@dynamic hasPrice, price;

typedef struct AskForRewardRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *productId;
  EmotionPrice *price;
} AskForRewardRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = AskForRewardRequest_FieldNumber_ProductId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AskForRewardRequest__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionPrice),
        .number = AskForRewardRequest_FieldNumber_Price,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AskForRewardRequest__storage_, price),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AskForRewardRequest class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AskForRewardRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001HA\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AskForRewardResponse

@implementation AskForRewardResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasReqKey, reqKey;
@dynamic hasAppId, appId;

typedef struct AskForRewardResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *reqKey;
  NSString *appId;
} AskForRewardResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = AskForRewardResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AskForRewardResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reqKey",
        .dataTypeSpecific.className = NULL,
        .number = AskForRewardResponse_FieldNumber_ReqKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AskForRewardResponse__storage_, reqKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appId",
        .dataTypeSpecific.className = NULL,
        .number = AskForRewardResponse_FieldNumber_AppId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AskForRewardResponse__storage_, appId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AskForRewardResponse class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AskForRewardResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002F\000\003DA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRewardMagicListRequest

@implementation GetRewardMagicListRequest

@dynamic hasScene, scene;

typedef struct GetRewardMagicListRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t scene;
} GetRewardMagicListRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = GetRewardMagicListRequest_FieldNumber_Scene,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetRewardMagicListRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRewardMagicListRequest class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRewardMagicListRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RewardMagic

@implementation RewardMagic

@dynamic hasMagicWord, magicWord;
@dynamic hasMagicURL, magicURL;
@dynamic hasMagicExpire, magicExpire;
@dynamic hasMagicLimit, magicLimit;
@dynamic hasProductId, productId;
@dynamic hasMd5, md5;

typedef struct RewardMagic__storage_ {
  uint32_t _has_storage_[1];
  uint32_t magicExpire;
  uint32_t magicLimit;
  NSString *magicWord;
  NSString *magicURL;
  NSString *productId;
  NSString *md5;
} RewardMagic__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "magicWord",
        .dataTypeSpecific.className = NULL,
        .number = RewardMagic_FieldNumber_MagicWord,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RewardMagic__storage_, magicWord),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "magicURL",
        .dataTypeSpecific.className = NULL,
        .number = RewardMagic_FieldNumber_MagicURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RewardMagic__storage_, magicURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "magicExpire",
        .dataTypeSpecific.className = NULL,
        .number = RewardMagic_FieldNumber_MagicExpire,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RewardMagic__storage_, magicExpire),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "magicLimit",
        .dataTypeSpecific.className = NULL,
        .number = RewardMagic_FieldNumber_MagicLimit,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RewardMagic__storage_, magicLimit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = RewardMagic_FieldNumber_ProductId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RewardMagic__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "md5",
        .dataTypeSpecific.className = NULL,
        .number = RewardMagic_FieldNumber_Md5,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RewardMagic__storage_, md5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RewardMagic class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RewardMagic__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001I\000\002F!!\000\003K\000\004J\000\005HA\000\006C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetRewardMagicListResponse

@implementation GetRewardMagicListResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic magicArray, magicArray_Count;

typedef struct GetRewardMagicListResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSMutableArray *magicArray;
} GetRewardMagicListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetRewardMagicListResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetRewardMagicListResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "magicArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RewardMagic),
        .number = GetRewardMagicListResponse_FieldNumber_MagicArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetRewardMagicListResponse__storage_, magicArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetRewardMagicListResponse class]
                                     rootClass:[MmemotionstoreRoot class]
                                          file:MmemotionstoreRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetRewardMagicListResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002\000Magic\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
