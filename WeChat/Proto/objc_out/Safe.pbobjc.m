// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safe.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Safe.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - SafeRoot

@implementation SafeRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - SafeRoot_FileDescriptor

static GPBFileDescriptor *SafeRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - InstalledPackageInfo

@implementation InstalledPackageInfo

@dynamic hasPackageName, packageName;
@dynamic hasLabel, label;
@dynamic hasSigMd5, sigMd5;
@dynamic hasFileSize, fileSize;
@dynamic hasApplicationFlag, applicationFlag;

typedef struct InstalledPackageInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fileSize;
  uint32_t applicationFlag;
  NSString *packageName;
  NSString *label;
  NSString *sigMd5;
} InstalledPackageInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "packageName",
        .dataTypeSpecific.className = NULL,
        .number = InstalledPackageInfo_FieldNumber_PackageName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InstalledPackageInfo__storage_, packageName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.className = NULL,
        .number = InstalledPackageInfo_FieldNumber_Label,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InstalledPackageInfo__storage_, label),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sigMd5",
        .dataTypeSpecific.className = NULL,
        .number = InstalledPackageInfo_FieldNumber_SigMd5,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InstalledPackageInfo__storage_, sigMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.className = NULL,
        .number = InstalledPackageInfo_FieldNumber_FileSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InstalledPackageInfo__storage_, fileSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "applicationFlag",
        .dataTypeSpecific.className = NULL,
        .number = InstalledPackageInfo_FieldNumber_ApplicationFlag,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(InstalledPackageInfo__storage_, applicationFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InstalledPackageInfo class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InstalledPackageInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\013\000\002E\000\003\004B\000\004\010\000\005\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ST

@implementation ST

@dynamic hasIsMorkLocOpen, isMorkLocOpen;
@dynamic hasMsgLevel, msgLevel;
@dynamic hasIsDbgConnected, isDbgConnected;
@dynamic hasPkgHash3, pkgHash3;
@dynamic hasRatioFwVer, ratioFwVer;
@dynamic hasOsRelVer, osRelVer;
@dynamic hasImei, imei;
@dynamic hasAndroidId, androidId;
@dynamic hasPhoneSerial, phoneSerial;
@dynamic hasPhoneModel, phoneModel;
@dynamic hasCpuCoreCount, cpuCoreCount;
@dynamic hasCpuHw, cpuHw;
@dynamic hasCpuFeatures, cpuFeatures;
@dynamic hasSelfMac, selfMac;
@dynamic hasSsid, ssid;
@dynamic hasBssid, bssid;
@dynamic hasSpInfo, spInfo;
@dynamic hasApninfo, apninfo;
@dynamic hasBuildFp, buildFp;
@dynamic hasBuildBoard, buildBoard;
@dynamic hasBuildBootloader, buildBootloader;
@dynamic hasBuildBrand, buildBrand;
@dynamic hasBuildDevice, buildDevice;
@dynamic hasBuildHw, buildHw;
@dynamic hasBuildProduct, buildProduct;
@dynamic hasManufacturer, manufacturer;
@dynamic hasPhoneNum, phoneNum;
@dynamic hasNetType, netType;
@dynamic hasIsQemuEnv, isQemuEnv;
@dynamic hasHasDupPkg, hasDupPkg;
@dynamic hasHasQikuShadow, hasQikuShadow;
@dynamic hasPkgName, pkgName;
@dynamic hasAppName, appName;
@dynamic hasDataRoot, dataRoot;
@dynamic hasEntranceClassLoaderName, entranceClassLoaderName;
@dynamic mmprocLoadedFilesArray, mmprocLoadedFilesArray_Count;
@dynamic hasRiskScanReqBuffer, riskScanReqBuffer;
@dynamic hasEnvBits, envBits;
@dynamic installedPackageInfosArray, installedPackageInfosArray_Count;
@dynamic hasAccessibilityClickCount, accessibilityClickCount;
@dynamic hasApkleadingMd5, apkleadingMd5;
@dynamic hasClientVersion, clientVersion;
@dynamic hasWxtag, wxtag;
@dynamic hasClientIp, clientIp;
@dynamic hasLanguage, language;
@dynamic hasIsInCalling, isInCalling;
@dynamic hasIsSetScreenLock, isSetScreenLock;
@dynamic neighborBssidlistArray, neighborBssidlistArray_Count;
@dynamic hasIsWifiOpen, isWifiOpen;
@dynamic hasHasXposedStackTrace, hasXposedStackTrace;
@dynamic hasXposedHookedMethods, xposedHookedMethods;
@dynamic hasIsAdbswitchEnabled, isAdbswitchEnabled;
@dynamic hasIsRunningByMonkey, isRunningByMonkey;
@dynamic hasAppInstrumentationClassName, appInstrumentationClassName;
@dynamic hasAmsbinderClassName, amsbinderClassName;
@dynamic hasAmssingletonClassName, amssingletonClassName;
@dynamic hasIsVpnused, isVpnused;
@dynamic hasIsVpnconnected, isVpnconnected;
@dynamic hasPcodes, pcodes;
@dynamic hasHasQcodes, hasQcodes;
@dynamic hasRcodes0, rcodes0;
@dynamic hasRcodes1, rcodes1;
@dynamic hasStid, stid;
@dynamic hasKernelReleaseNumber, kernelReleaseNumber;
@dynamic hasUsbState, usbState;
@dynamic hasApkSignatureMd5, apkSignatureMd5;
@dynamic hasGoogleServiceState, googleServiceState;
@dynamic hasTimeval1, timeval1;
@dynamic hasSpamInfoVersionSeq, spamInfoVersionSeq;
@dynamic hasTbVersionCrc, tbVersionCrc;
@dynamic hasSystemFrameworkMd5, systemFrameworkMd5;
@dynamic hasSystemFrameworkArmMd5, systemFrameworkArmMd5;
@dynamic hasSystemFrameworkArm64Md5, systemFrameworkArm64Md5;
@dynamic hasSystemBinMd5, systemBinMd5;
@dynamic hasSoterUid, soterUid;
@dynamic hasWidevineDeviceId, widevineDeviceId;
@dynamic hasStorageId, storageId;
@dynamic hasOaid, oaid;
@dynamic hasUnknownTag80, unknownTag80;
@dynamic hasMagiskBitCheck, magiskBitCheck;
@dynamic filesModifiedInFrameworkArray, filesModifiedInFrameworkArray_Count;
@dynamic hasWeChatInstallTime, weChatInstallTime;
@dynamic hasSoftConfig, softConfig;
@dynamic hasSoftData, softData;
@dynamic hasTag86, tag86;
@dynamic hasNetWorkInterface, netWorkInterface;
@dynamic hasTag88, tag88;
@dynamic hasTag89, tag89;
@dynamic hasTag90, tag90;
@dynamic hasTag91, tag91;
@dynamic hasTag92, tag92;
@dynamic hasTag93, tag93;
@dynamic hasTag94, tag94;
@dynamic hasTag95, tag95;
@dynamic hasTag96, tag96;
@dynamic hasTag97, tag97;
@dynamic hasTag98, tag98;
@dynamic hasTag99, tag99;
@dynamic hasTag100, tag100;
@dynamic hasTag101, tag101;
@dynamic hasTag102, tag102;
@dynamic hasTag103, tag103;
@dynamic hasTag104, tag104;
@dynamic hasTag105, tag105;
@dynamic hasTag106, tag106;
@dynamic hasTag107, tag107;
@dynamic hasTag108, tag108;
@dynamic hasTag109, tag109;
@dynamic hasTag110, tag110;
@dynamic hasTag111, tag111;
@dynamic hasTag112, tag112;
@dynamic hasTag113, tag113;
@dynamic hasTag114, tag114;
@dynamic hasTag115, tag115;
@dynamic hasUid, uid;
@dynamic hasTag117, tag117;

typedef struct ST__storage_ {
  uint32_t _has_storage_[4];
  uint32_t isMorkLocOpen;
  uint32_t msgLevel;
  uint32_t isDbgConnected;
  uint32_t cpuCoreCount;
  uint32_t isQemuEnv;
  uint32_t hasDupPkg;
  uint32_t hasQikuShadow;
  uint32_t envBits;
  uint32_t accessibilityClickCount;
  uint32_t isInCalling;
  uint32_t isSetScreenLock;
  uint32_t isWifiOpen;
  uint32_t hasXposedStackTrace;
  uint32_t isAdbswitchEnabled;
  uint32_t isRunningByMonkey;
  uint32_t isVpnused;
  uint32_t isVpnconnected;
  uint32_t usbState;
  uint32_t googleServiceState;
  uint32_t timeval1;
  uint32_t spamInfoVersionSeq;
  uint32_t tbVersionCrc;
  uint32_t unknownTag80;
  uint32_t magiskBitCheck;
  uint32_t weChatInstallTime;
  uint32_t tag86;
  uint32_t tag88;
  uint32_t tag89;
  uint32_t tag90;
  uint32_t tag92;
  uint32_t tag94;
  uint32_t tag96;
  uint32_t tag98;
  uint32_t tag100;
  uint32_t tag102;
  uint32_t tag104;
  uint32_t tag106;
  uint32_t tag108;
  uint32_t tag110;
  uint32_t tag112;
  uint32_t tag114;
  uint32_t tag115;
  uint32_t uid;
  uint32_t tag117;
  NSString *pkgHash3;
  NSString *ratioFwVer;
  NSString *osRelVer;
  NSString *imei;
  NSString *androidId;
  NSString *phoneSerial;
  NSString *phoneModel;
  NSString *cpuHw;
  NSString *cpuFeatures;
  NSString *selfMac;
  NSString *ssid;
  NSString *bssid;
  NSString *spInfo;
  NSString *apninfo;
  NSString *buildFp;
  NSString *buildBoard;
  NSString *buildBootloader;
  NSString *buildBrand;
  NSString *buildDevice;
  NSString *buildHw;
  NSString *buildProduct;
  NSString *manufacturer;
  NSString *phoneNum;
  NSString *netType;
  NSString *pkgName;
  NSString *appName;
  NSString *dataRoot;
  NSString *entranceClassLoaderName;
  NSMutableArray *mmprocLoadedFilesArray;
  NSString *riskScanReqBuffer;
  NSMutableArray *installedPackageInfosArray;
  NSString *apkleadingMd5;
  NSString *clientVersion;
  NSString *wxtag;
  NSString *clientIp;
  NSString *language;
  NSMutableArray *neighborBssidlistArray;
  NSString *xposedHookedMethods;
  NSString *appInstrumentationClassName;
  NSString *amsbinderClassName;
  NSString *amssingletonClassName;
  NSString *pcodes;
  NSString *hasQcodes;
  NSString *rcodes0;
  NSString *rcodes1;
  NSString *stid;
  NSString *kernelReleaseNumber;
  NSString *apkSignatureMd5;
  NSString *systemFrameworkMd5;
  NSString *systemFrameworkArmMd5;
  NSString *systemFrameworkArm64Md5;
  NSString *systemBinMd5;
  NSString *soterUid;
  NSString *widevineDeviceId;
  NSString *storageId;
  NSString *oaid;
  NSMutableArray *filesModifiedInFrameworkArray;
  NSData *softConfig;
  NSData *softData;
  NSString *netWorkInterface;
  NSData *tag91;
  NSData *tag93;
  NSData *tag95;
  NSData *tag97;
  NSData *tag99;
  NSData *tag101;
  NSData *tag103;
  NSData *tag105;
  NSData *tag107;
  NSData *tag109;
  NSData *tag111;
  NSData *tag113;
} ST__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isMorkLocOpen",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsMorkLocOpen,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ST__storage_, isMorkLocOpen),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgLevel",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_MsgLevel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ST__storage_, msgLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isDbgConnected",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsDbgConnected,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ST__storage_, isDbgConnected),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pkgHash3",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PkgHash3,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ST__storage_, pkgHash3),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ratioFwVer",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_RatioFwVer,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ST__storage_, ratioFwVer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "osRelVer",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_OsRelVer,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ST__storage_, osRelVer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imei",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Imei,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ST__storage_, imei),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidId",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_AndroidId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ST__storage_, androidId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phoneSerial",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PhoneSerial,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ST__storage_, phoneSerial),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phoneModel",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PhoneModel,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ST__storage_, phoneModel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cpuCoreCount",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_CpuCoreCount,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ST__storage_, cpuCoreCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cpuHw",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_CpuHw,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ST__storage_, cpuHw),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cpuFeatures",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_CpuFeatures,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ST__storage_, cpuFeatures),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selfMac",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SelfMac,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ST__storage_, selfMac),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ssid",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Ssid,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ST__storage_, ssid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bssid",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Bssid,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ST__storage_, bssid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "spInfo",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SpInfo,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ST__storage_, spInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "apninfo",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Apninfo,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ST__storage_, apninfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildFp",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildFp,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ST__storage_, buildFp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildBoard",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildBoard,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ST__storage_, buildBoard),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildBootloader",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildBootloader,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ST__storage_, buildBootloader),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildBrand",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildBrand,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ST__storage_, buildBrand),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildDevice",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildDevice,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(ST__storage_, buildDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildHw",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildHw,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(ST__storage_, buildHw),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildProduct",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildProduct,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(ST__storage_, buildProduct),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "manufacturer",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Manufacturer,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(ST__storage_, manufacturer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phoneNum",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PhoneNum,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(ST__storage_, phoneNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "netType",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_NetType,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(ST__storage_, netType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isQemuEnv",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsQemuEnv,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(ST__storage_, isQemuEnv),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hasDupPkg",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_HasDupPkg,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(ST__storage_, hasDupPkg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hasQikuShadow",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_HasQikuShadow,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(ST__storage_, hasQikuShadow),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pkgName",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PkgName,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(ST__storage_, pkgName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appName",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_AppName,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(ST__storage_, appName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dataRoot",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_DataRoot,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(ST__storage_, dataRoot),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "entranceClassLoaderName",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_EntranceClassLoaderName,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(ST__storage_, entranceClassLoaderName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mmprocLoadedFilesArray",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_MmprocLoadedFilesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ST__storage_, mmprocLoadedFilesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "riskScanReqBuffer",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_RiskScanReqBuffer,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(ST__storage_, riskScanReqBuffer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "envBits",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_EnvBits,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(ST__storage_, envBits),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "installedPackageInfosArray",
        .dataTypeSpecific.className = GPBStringifySymbol(InstalledPackageInfo),
        .number = ST_FieldNumber_InstalledPackageInfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ST__storage_, installedPackageInfosArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accessibilityClickCount",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_AccessibilityClickCount,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(ST__storage_, accessibilityClickCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "apkleadingMd5",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_ApkleadingMd5,
        .hasIndex = 38,
        .offset = (uint32_t)offsetof(ST__storage_, apkleadingMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_ClientVersion,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(ST__storage_, clientVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wxtag",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Wxtag,
        .hasIndex = 40,
        .offset = (uint32_t)offsetof(ST__storage_, wxtag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientIp",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_ClientIp,
        .hasIndex = 41,
        .offset = (uint32_t)offsetof(ST__storage_, clientIp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Language,
        .hasIndex = 42,
        .offset = (uint32_t)offsetof(ST__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isInCalling",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsInCalling,
        .hasIndex = 43,
        .offset = (uint32_t)offsetof(ST__storage_, isInCalling),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isSetScreenLock",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsSetScreenLock,
        .hasIndex = 44,
        .offset = (uint32_t)offsetof(ST__storage_, isSetScreenLock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "neighborBssidlistArray",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_NeighborBssidlistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ST__storage_, neighborBssidlistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isWifiOpen",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsWifiOpen,
        .hasIndex = 45,
        .offset = (uint32_t)offsetof(ST__storage_, isWifiOpen),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hasXposedStackTrace",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_HasXposedStackTrace,
        .hasIndex = 46,
        .offset = (uint32_t)offsetof(ST__storage_, hasXposedStackTrace),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "xposedHookedMethods",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_XposedHookedMethods,
        .hasIndex = 47,
        .offset = (uint32_t)offsetof(ST__storage_, xposedHookedMethods),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAdbswitchEnabled",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsAdbswitchEnabled,
        .hasIndex = 48,
        .offset = (uint32_t)offsetof(ST__storage_, isAdbswitchEnabled),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isRunningByMonkey",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsRunningByMonkey,
        .hasIndex = 49,
        .offset = (uint32_t)offsetof(ST__storage_, isRunningByMonkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "appInstrumentationClassName",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_AppInstrumentationClassName,
        .hasIndex = 50,
        .offset = (uint32_t)offsetof(ST__storage_, appInstrumentationClassName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amsbinderClassName",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_AmsbinderClassName,
        .hasIndex = 51,
        .offset = (uint32_t)offsetof(ST__storage_, amsbinderClassName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amssingletonClassName",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_AmssingletonClassName,
        .hasIndex = 52,
        .offset = (uint32_t)offsetof(ST__storage_, amssingletonClassName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isVpnused",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsVpnused,
        .hasIndex = 53,
        .offset = (uint32_t)offsetof(ST__storage_, isVpnused),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isVpnconnected",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsVpnconnected,
        .hasIndex = 54,
        .offset = (uint32_t)offsetof(ST__storage_, isVpnconnected),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pcodes",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Pcodes,
        .hasIndex = 55,
        .offset = (uint32_t)offsetof(ST__storage_, pcodes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hasQcodes",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_HasQcodes,
        .hasIndex = 56,
        .offset = (uint32_t)offsetof(ST__storage_, hasQcodes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rcodes0",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Rcodes0,
        .hasIndex = 57,
        .offset = (uint32_t)offsetof(ST__storage_, rcodes0),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rcodes1",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Rcodes1,
        .hasIndex = 58,
        .offset = (uint32_t)offsetof(ST__storage_, rcodes1),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stid",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Stid,
        .hasIndex = 59,
        .offset = (uint32_t)offsetof(ST__storage_, stid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "kernelReleaseNumber",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_KernelReleaseNumber,
        .hasIndex = 60,
        .offset = (uint32_t)offsetof(ST__storage_, kernelReleaseNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "usbState",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_UsbState,
        .hasIndex = 61,
        .offset = (uint32_t)offsetof(ST__storage_, usbState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "apkSignatureMd5",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_ApkSignatureMd5,
        .hasIndex = 62,
        .offset = (uint32_t)offsetof(ST__storage_, apkSignatureMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "googleServiceState",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_GoogleServiceState,
        .hasIndex = 63,
        .offset = (uint32_t)offsetof(ST__storage_, googleServiceState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "timeval1",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Timeval1,
        .hasIndex = 64,
        .offset = (uint32_t)offsetof(ST__storage_, timeval1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "spamInfoVersionSeq",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SpamInfoVersionSeq,
        .hasIndex = 65,
        .offset = (uint32_t)offsetof(ST__storage_, spamInfoVersionSeq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tbVersionCrc",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_TbVersionCrc,
        .hasIndex = 66,
        .offset = (uint32_t)offsetof(ST__storage_, tbVersionCrc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "systemFrameworkMd5",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SystemFrameworkMd5,
        .hasIndex = 67,
        .offset = (uint32_t)offsetof(ST__storage_, systemFrameworkMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "systemFrameworkArmMd5",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SystemFrameworkArmMd5,
        .hasIndex = 68,
        .offset = (uint32_t)offsetof(ST__storage_, systemFrameworkArmMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "systemFrameworkArm64Md5",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SystemFrameworkArm64Md5,
        .hasIndex = 69,
        .offset = (uint32_t)offsetof(ST__storage_, systemFrameworkArm64Md5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "systemBinMd5",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SystemBinMd5,
        .hasIndex = 70,
        .offset = (uint32_t)offsetof(ST__storage_, systemBinMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "soterUid",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SoterUid,
        .hasIndex = 71,
        .offset = (uint32_t)offsetof(ST__storage_, soterUid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "widevineDeviceId",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_WidevineDeviceId,
        .hasIndex = 72,
        .offset = (uint32_t)offsetof(ST__storage_, widevineDeviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "storageId",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_StorageId,
        .hasIndex = 73,
        .offset = (uint32_t)offsetof(ST__storage_, storageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oaid",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Oaid,
        .hasIndex = 74,
        .offset = (uint32_t)offsetof(ST__storage_, oaid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unknownTag80",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_UnknownTag80,
        .hasIndex = 75,
        .offset = (uint32_t)offsetof(ST__storage_, unknownTag80),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "magiskBitCheck",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_MagiskBitCheck,
        .hasIndex = 76,
        .offset = (uint32_t)offsetof(ST__storage_, magiskBitCheck),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "filesModifiedInFrameworkArray",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_FilesModifiedInFrameworkArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ST__storage_, filesModifiedInFrameworkArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weChatInstallTime",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_WeChatInstallTime,
        .hasIndex = 77,
        .offset = (uint32_t)offsetof(ST__storage_, weChatInstallTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "softConfig",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SoftConfig,
        .hasIndex = 78,
        .offset = (uint32_t)offsetof(ST__storage_, softConfig),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "softData",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SoftData,
        .hasIndex = 79,
        .offset = (uint32_t)offsetof(ST__storage_, softData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag86",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag86,
        .hasIndex = 80,
        .offset = (uint32_t)offsetof(ST__storage_, tag86),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "netWorkInterface",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_NetWorkInterface,
        .hasIndex = 81,
        .offset = (uint32_t)offsetof(ST__storage_, netWorkInterface),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag88",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag88,
        .hasIndex = 82,
        .offset = (uint32_t)offsetof(ST__storage_, tag88),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag89",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag89,
        .hasIndex = 83,
        .offset = (uint32_t)offsetof(ST__storage_, tag89),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag90",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag90,
        .hasIndex = 84,
        .offset = (uint32_t)offsetof(ST__storage_, tag90),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag91",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag91,
        .hasIndex = 85,
        .offset = (uint32_t)offsetof(ST__storage_, tag91),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag92",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag92,
        .hasIndex = 86,
        .offset = (uint32_t)offsetof(ST__storage_, tag92),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag93",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag93,
        .hasIndex = 87,
        .offset = (uint32_t)offsetof(ST__storage_, tag93),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag94",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag94,
        .hasIndex = 88,
        .offset = (uint32_t)offsetof(ST__storage_, tag94),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag95",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag95,
        .hasIndex = 89,
        .offset = (uint32_t)offsetof(ST__storage_, tag95),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag96",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag96,
        .hasIndex = 90,
        .offset = (uint32_t)offsetof(ST__storage_, tag96),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag97",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag97,
        .hasIndex = 91,
        .offset = (uint32_t)offsetof(ST__storage_, tag97),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag98",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag98,
        .hasIndex = 92,
        .offset = (uint32_t)offsetof(ST__storage_, tag98),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag99",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag99,
        .hasIndex = 93,
        .offset = (uint32_t)offsetof(ST__storage_, tag99),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag100",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag100,
        .hasIndex = 94,
        .offset = (uint32_t)offsetof(ST__storage_, tag100),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag101",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag101,
        .hasIndex = 95,
        .offset = (uint32_t)offsetof(ST__storage_, tag101),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag102",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag102,
        .hasIndex = 96,
        .offset = (uint32_t)offsetof(ST__storage_, tag102),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag103",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag103,
        .hasIndex = 97,
        .offset = (uint32_t)offsetof(ST__storage_, tag103),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag104",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag104,
        .hasIndex = 98,
        .offset = (uint32_t)offsetof(ST__storage_, tag104),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag105",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag105,
        .hasIndex = 99,
        .offset = (uint32_t)offsetof(ST__storage_, tag105),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag106",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag106,
        .hasIndex = 100,
        .offset = (uint32_t)offsetof(ST__storage_, tag106),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag107",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag107,
        .hasIndex = 101,
        .offset = (uint32_t)offsetof(ST__storage_, tag107),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag108",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag108,
        .hasIndex = 102,
        .offset = (uint32_t)offsetof(ST__storage_, tag108),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag109",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag109,
        .hasIndex = 103,
        .offset = (uint32_t)offsetof(ST__storage_, tag109),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag110",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag110,
        .hasIndex = 104,
        .offset = (uint32_t)offsetof(ST__storage_, tag110),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag111",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag111,
        .hasIndex = 105,
        .offset = (uint32_t)offsetof(ST__storage_, tag111),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag112",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag112,
        .hasIndex = 106,
        .offset = (uint32_t)offsetof(ST__storage_, tag112),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag113",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag113,
        .hasIndex = 107,
        .offset = (uint32_t)offsetof(ST__storage_, tag113),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag114",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag114,
        .hasIndex = 108,
        .offset = (uint32_t)offsetof(ST__storage_, tag114),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag115",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag115,
        .hasIndex = 109,
        .offset = (uint32_t)offsetof(ST__storage_, tag115),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Uid,
        .hasIndex = 110,
        .offset = (uint32_t)offsetof(ST__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag117",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Tag117,
        .hasIndex = 111,
        .offset = (uint32_t)offsetof(ST__storage_, tag117),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ST class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ST__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "r\001M\000\002H\000\003N\000\004H\000\005J\000\006H\000\007d\000\010HA\000\tK\000\nJ\000\013L\000\014DA\000\r"
        "K\000\016Eb\000\017d\000\020e\000\021F\000\022d\003\000\023FA\000\024J\000\025O\000\026J\000\027K\000\030FA\000\031"
        "L\000\032L\000\033H\000\034G\000\035I\000\036I\000\037M\000 G\000!G\000\"H\000#W\000$\000MMProc"
        "LoadedFiles\000%Q\000&G\000(\000InstalledPackageInfo"
        "s\000)W\000*d\007B\000+M\000,c\002\000-GA\000.H\000/K\0000O\0001\000Neighbor"
        "BSSIDList\0002J\0003S\0004S\0005Cc\014\0006Q\0007[\0008d\016\0009d\021\000:C"
        "c\003\000;Cc\010\000<b\004\000=DE\000>b\005\000\?b\005\000@d\000AS\000BH\000CO\000DR\000F"
        "R\000GL\000HPB\000ISB\000JUB\000KJB\000LH\000MOA\000NHA\000Od\000PL\000QN"
        "\000R\000FilesModifiedInFramework\000SQ\000TJ\000UH\000VE\000"
        "WP\000XE\000YE\000ZE\000[E\000\\E\000]E\000^E\000_E\000`E\000aE\000bE\000cE\000d"
        "F\000eF\000fF\000gF\000hF\000iF\000jF\000kF\000lF\000mF\000nF\000oF\000pF\000qF"
        "\000rF\000sF\000uF\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClientSpamInfo

@implementation ClientSpamInfo

@dynamic hasCcdcc, ccdcc;
@dynamic hasCcdts, ccdts;
@dynamic hasSt, st;

typedef struct ClientSpamInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t ccdcc;
  uint32_t ccdts;
  ST *st;
} ClientSpamInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ccdcc",
        .dataTypeSpecific.className = NULL,
        .number = ClientSpamInfo_FieldNumber_Ccdcc,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClientSpamInfo__storage_, ccdcc),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ccdts",
        .dataTypeSpecific.className = NULL,
        .number = ClientSpamInfo_FieldNumber_Ccdts,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClientSpamInfo__storage_, ccdts),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "st",
        .dataTypeSpecific.className = GPBStringifySymbol(ST),
        .number = ClientSpamInfo_FieldNumber_St,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ClientSpamInfo__storage_, st),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClientSpamInfo class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClientSpamInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WCSTF

@implementation WCSTF

@dynamic hasSt, st;
@dynamic hasEt, et;
@dynamic hasCc, cc;
@dynamic ctArray, ctArray_Count;

typedef struct WCSTF__storage_ {
  uint32_t _has_storage_[1];
  uint32_t et;
  GPBUInt64Array *ctArray;
  uint64_t st;
  uint64_t cc;
} WCSTF__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "st",
        .dataTypeSpecific.className = NULL,
        .number = WCSTF_FieldNumber_St,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WCSTF__storage_, st),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "et",
        .dataTypeSpecific.className = NULL,
        .number = WCSTF_FieldNumber_Et,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WCSTF__storage_, et),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cc",
        .dataTypeSpecific.className = NULL,
        .number = WCSTF_FieldNumber_Cc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WCSTF__storage_, cc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "ctArray",
        .dataTypeSpecific.className = NULL,
        .number = WCSTF_FieldNumber_CtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(WCSTF__storage_, ctArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WCSTF class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WCSTF__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WCSTE

@implementation WCSTE

@dynamic hasContext, context;
@dynamic hasSt, st;
@dynamic hasEt, et;
@dynamic hasIec, iec;
@dynamic hasTec, tec;
@dynamic hasAsst, asst;
@dynamic hasPss, pss;
@dynamic hasTlmj, tlmj;
@dynamic hasTlmn, tlmn;
@dynamic hasThmj, thmj;
@dynamic hasThmn, thmn;
@dynamic hasSz, sz;

typedef struct WCSTE__storage_ {
  uint32_t _has_storage_[1];
  uint32_t st;
  uint32_t et;
  uint32_t iec;
  uint32_t tec;
  uint32_t asst;
  NSString *context;
  uint64_t pss;
  uint64_t tlmj;
  uint64_t tlmn;
  uint64_t thmj;
  uint64_t thmn;
  uint64_t sz;
} WCSTE__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WCSTE__storage_, context),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "st",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_St,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WCSTE__storage_, st),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "et",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Et,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WCSTE__storage_, et),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "iec",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Iec,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WCSTE__storage_, iec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tec",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Tec,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(WCSTE__storage_, tec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "asst",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Asst,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(WCSTE__storage_, asst),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pss",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Pss,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(WCSTE__storage_, pss),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tlmj",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Tlmj,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(WCSTE__storage_, tlmj),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tlmn",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Tlmn,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(WCSTE__storage_, tlmn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "thmj",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Thmj,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(WCSTE__storage_, thmj),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "thmn",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Thmn,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(WCSTE__storage_, thmn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "sz",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Sz,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(WCSTE__storage_, sz),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WCSTE class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WCSTE__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPKeyVal

@implementation FPKeyVal

@dynamic hasKey, key;
@dynamic hasValue, value;

typedef struct FPKeyVal__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} FPKeyVal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = FPKeyVal_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPKeyVal__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = FPKeyVal_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPKeyVal__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPKeyVal class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPKeyVal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPKeyVals

@implementation FPKeyVals

@dynamic keyValArray, keyValArray_Count;

typedef struct FPKeyVals__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *keyValArray;
} FPKeyVals__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyValArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FPKeyVal),
        .number = FPKeyVals_FieldNumber_KeyValArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPKeyVals__storage_, keyValArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPKeyVals class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPKeyVals__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000keyVal\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPDevice

@implementation FPDevice

@dynamic hasKeyvals, keyvals;
@dynamic hasUnknown2, unknown2;

typedef struct FPDevice__storage_ {
  uint32_t _has_storage_[1];
  FPKeyVals *keyvals;
  NSString *unknown2;
} FPDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyvals",
        .dataTypeSpecific.className = GPBStringifySymbol(FPKeyVals),
        .number = FPDevice_FieldNumber_Keyvals,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPDevice__storage_, keyvals),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unknown2",
        .dataTypeSpecific.className = NULL,
        .number = FPDevice_FieldNumber_Unknown2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPDevice__storage_, unknown2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPDevice class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPDevice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpamInfoEncrypedResult

@implementation SpamInfoEncrypedResult

@dynamic hasVersion, version;
@dynamic hasType, type;
@dynamic hasEncrypedData, encrypedData;
@dynamic hasTimestamp, timestamp;
@dynamic hasTag5, tag5;
@dynamic hasTag6, tag6;

typedef struct SpamInfoEncrypedResult__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t timestamp;
  uint32_t tag5;
  uint32_t tag6;
  NSString *version;
  NSData *encrypedData;
} SpamInfoEncrypedResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = SpamInfoEncrypedResult_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpamInfoEncrypedResult__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = SpamInfoEncrypedResult_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpamInfoEncrypedResult__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "encrypedData",
        .dataTypeSpecific.className = NULL,
        .number = SpamInfoEncrypedResult_FieldNumber_EncrypedData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SpamInfoEncrypedResult__storage_, encrypedData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = SpamInfoEncrypedResult_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SpamInfoEncrypedResult__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag5",
        .dataTypeSpecific.className = NULL,
        .number = SpamInfoEncrypedResult_FieldNumber_Tag5,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SpamInfoEncrypedResult__storage_, tag5),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag6",
        .dataTypeSpecific.className = NULL,
        .number = SpamInfoEncrypedResult_FieldNumber_Tag6,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SpamInfoEncrypedResult__storage_, tag6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpamInfoEncrypedResult class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpamInfoEncrypedResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CryptoData

@implementation CryptoData

@dynamic hasVersion, version;
@dynamic hasType, type;
@dynamic hasEncryptData, encryptData;
@dynamic hasTimestamp, timestamp;
@dynamic hasUnknown5, unknown5;
@dynamic hasUnknown6, unknown6;

typedef struct CryptoData__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t timestamp;
  uint32_t unknown5;
  uint32_t unknown6;
  NSData *version;
  NSData *encryptData;
} CryptoData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = CryptoData_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CryptoData__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = CryptoData_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CryptoData__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "encryptData",
        .dataTypeSpecific.className = NULL,
        .number = CryptoData_FieldNumber_EncryptData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CryptoData__storage_, encryptData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = CryptoData_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CryptoData__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "unknown5",
        .dataTypeSpecific.className = NULL,
        .number = CryptoData_FieldNumber_Unknown5,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CryptoData__storage_, unknown5),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "unknown6",
        .dataTypeSpecific.className = NULL,
        .number = CryptoData_FieldNumber_Unknown6,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CryptoData__storage_, unknown6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CryptoData class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CryptoData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpamBuff

@implementation SpamBuff

@dynamic hasSoft, soft;
@dynamic hasDevicetoken, devicetoken;
@dynamic hasTimestamp, timestamp;

typedef struct SpamBuff__storage_ {
  uint32_t _has_storage_[1];
  uint32_t timestamp;
  SpamBuff_Soft *soft;
  NSString *devicetoken;
} SpamBuff__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "soft",
        .dataTypeSpecific.className = GPBStringifySymbol(SpamBuff_Soft),
        .number = SpamBuff_FieldNumber_Soft,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpamBuff__storage_, soft),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "devicetoken",
        .dataTypeSpecific.className = NULL,
        .number = SpamBuff_FieldNumber_Devicetoken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpamBuff__storage_, devicetoken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = SpamBuff_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SpamBuff__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpamBuff class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpamBuff__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpamBuff_Soft

@implementation SpamBuff_Soft

@dynamic hasSoftData, softData;
@dynamic hasSoftConfig, softConfig;

typedef struct SpamBuff_Soft__storage_ {
  uint32_t _has_storage_[1];
  NSData *softData;
  NSData *softConfig;
} SpamBuff_Soft__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "softData",
        .dataTypeSpecific.className = NULL,
        .number = SpamBuff_Soft_FieldNumber_SoftData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpamBuff_Soft__storage_, softData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "softConfig",
        .dataTypeSpecific.className = NULL,
        .number = SpamBuff_Soft_FieldNumber_SoftConfig,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpamBuff_Soft__storage_, softConfig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpamBuff_Soft class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpamBuff_Soft__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SpamBuff)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceToken

@implementation DeviceToken

@dynamic hasTag1, tag1;
@dynamic hasTag2, tag2;
@dynamic hasToken, token;
@dynamic hasTimestamp, timestamp;
@dynamic hasTag5, tag5;
@dynamic hasTag6, tag6;

typedef struct DeviceToken__storage_ {
  uint32_t _has_storage_[1];
  uint32_t tag2;
  uint32_t timestamp;
  uint32_t tag5;
  uint32_t tag6;
  NSString *tag1;
  DeviceToken_Token *token;
} DeviceToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tag1",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_Tag1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, tag1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag2",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_Tag2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, tag2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = GPBStringifySymbol(DeviceToken_Token),
        .number = DeviceToken_FieldNumber_Token,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag5",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_Tag5,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, tag5),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag6",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_Tag6,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, tag6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceToken class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceToken_Token

@implementation DeviceToken_Token

@dynamic hasDevicetoken, devicetoken;

typedef struct DeviceToken_Token__storage_ {
  uint32_t _has_storage_[1];
  NSString *devicetoken;
} DeviceToken_Token__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "devicetoken",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_Token_FieldNumber_Devicetoken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceToken_Token__storage_, devicetoken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceToken_Token class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceToken_Token__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DeviceToken)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClientSpamInfo_IOS

@implementation ClientSpamInfo_IOS

@dynamic hasCcdcc, ccdcc;
@dynamic hasCcdts, ccdts;
@dynamic hasContent, content;

typedef struct ClientSpamInfo_IOS__storage_ {
  uint32_t _has_storage_[1];
  uint32_t ccdcc;
  uint32_t ccdts;
  ClientSpamInfo_IOS_Content *content;
} ClientSpamInfo_IOS__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ccdcc",
        .dataTypeSpecific.className = NULL,
        .number = ClientSpamInfo_IOS_FieldNumber_Ccdcc,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClientSpamInfo_IOS__storage_, ccdcc),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ccdts",
        .dataTypeSpecific.className = NULL,
        .number = ClientSpamInfo_IOS_FieldNumber_Ccdts,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClientSpamInfo_IOS__storage_, ccdts),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = GPBStringifySymbol(ClientSpamInfo_IOS_Content),
        .number = ClientSpamInfo_IOS_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ClientSpamInfo_IOS__storage_, content),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClientSpamInfo_IOS class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClientSpamInfo_IOS__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClientSpamInfo_IOS_Content

@implementation ClientSpamInfo_IOS_Content

@dynamic hasTag3, tag3;
@dynamic hasTag51, tag51;

typedef struct ClientSpamInfo_IOS_Content__storage_ {
  uint32_t _has_storage_[1];
  NSData *tag3;
  NSData *tag51;
} ClientSpamInfo_IOS_Content__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tag3",
        .dataTypeSpecific.className = NULL,
        .number = ClientSpamInfo_IOS_Content_FieldNumber_Tag3,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClientSpamInfo_IOS_Content__storage_, tag3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag51",
        .dataTypeSpecific.className = NULL,
        .number = ClientSpamInfo_IOS_Content_FieldNumber_Tag51,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClientSpamInfo_IOS_Content__storage_, tag51),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClientSpamInfo_IOS_Content class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClientSpamInfo_IOS_Content__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ClientSpamInfo_IOS)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - wcaes

@implementation wcaes

@dynamic hasType, type;
@dynamic hasIv, iv;
@dynamic hasLen, len;
@dynamic hasMztkey, mztkey;
@dynamic hasMztkeyvalue, mztkeyvalue;
@dynamic hasUnkown6, unkown6;
@dynamic hasUnkown7, unkown7;
@dynamic hasUnkown8, unkown8;
@dynamic hasUnkown9, unkown9;
@dynamic hasTablekey, tablekey;
@dynamic hasUnkown11, unkown11;
@dynamic hasTablevalue, tablevalue;
@dynamic hasUnkown13, unkown13;
@dynamic hasUnkown14, unkown14;
@dynamic hasUnkown15, unkown15;
@dynamic hasUnkown16, unkown16;
@dynamic hasUnkown17, unkown17;
@dynamic hasUnkown18, unkown18;
@dynamic hasUnkown19, unkown19;
@dynamic hasUnkown20, unkown20;
@dynamic hasUnkown21, unkown21;
@dynamic hasUnkown22, unkown22;
@dynamic hasUnkown23, unkown23;
@dynamic hasUnkown24, unkown24;
@dynamic hasUnkown25, unkown25;

typedef struct wcaes__storage_ {
  uint32_t _has_storage_[1];
  int32_t len;
  NSData *type;
  NSData *iv;
  NSData *mztkey;
  NSData *mztkeyvalue;
  NSData *unkown6;
  NSData *unkown7;
  NSData *unkown8;
  NSData *unkown9;
  NSData *tablekey;
  NSData *unkown11;
  NSData *tablevalue;
  NSData *unkown13;
  NSData *unkown14;
  NSData *unkown15;
  NSData *unkown16;
  NSData *unkown17;
  NSData *unkown18;
  NSData *unkown19;
  NSData *unkown20;
  NSData *unkown21;
  NSData *unkown22;
  NSData *unkown23;
  NSData *unkown24;
  NSData *unkown25;
} wcaes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(wcaes__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "iv",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Iv,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(wcaes__storage_, iv),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "len",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Len,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(wcaes__storage_, len),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "mztkey",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Mztkey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(wcaes__storage_, mztkey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "mztkeyvalue",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Mztkeyvalue,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(wcaes__storage_, mztkeyvalue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown6",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown6,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown7",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown7,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown7),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown8",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown8,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown8),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown9",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown9,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown9),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tablekey",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Tablekey,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(wcaes__storage_, tablekey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown11",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown11,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown11),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tablevalue",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Tablevalue,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(wcaes__storage_, tablevalue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown13",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown13,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown13),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown14",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown14,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown14),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown15",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown15,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown15),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown16",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown16,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown16),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown17",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown17,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown17),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown18",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown18,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown18),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown19",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown19,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown19),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown20",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown20,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown20),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown21",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown21,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown21),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown22",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown22,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown22),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown23",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown23,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown23),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown24",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown24,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown24),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unkown25",
        .dataTypeSpecific.className = NULL,
        .number = wcaes_FieldNumber_Unkown25,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(wcaes__storage_, unkown25),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[wcaes class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(wcaes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002b\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
