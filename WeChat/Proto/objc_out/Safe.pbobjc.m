// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safe.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Safe.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - SafeRoot

@implementation SafeRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - SafeRoot_FileDescriptor

static GPBFileDescriptor *SafeRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - InstalledPackageInfo

@implementation InstalledPackageInfo

@dynamic hasPackageName, packageName;
@dynamic hasLabel, label;
@dynamic hasSigMd5, sigMd5;
@dynamic hasFileSize, fileSize;
@dynamic hasApplicationFlag, applicationFlag;

typedef struct InstalledPackageInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fileSize;
  uint32_t applicationFlag;
  NSString *packageName;
  NSString *label;
  NSString *sigMd5;
} InstalledPackageInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "packageName",
        .dataTypeSpecific.className = NULL,
        .number = InstalledPackageInfo_FieldNumber_PackageName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InstalledPackageInfo__storage_, packageName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "label",
        .dataTypeSpecific.className = NULL,
        .number = InstalledPackageInfo_FieldNumber_Label,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InstalledPackageInfo__storage_, label),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sigMd5",
        .dataTypeSpecific.className = NULL,
        .number = InstalledPackageInfo_FieldNumber_SigMd5,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InstalledPackageInfo__storage_, sigMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.className = NULL,
        .number = InstalledPackageInfo_FieldNumber_FileSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InstalledPackageInfo__storage_, fileSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "applicationFlag",
        .dataTypeSpecific.className = NULL,
        .number = InstalledPackageInfo_FieldNumber_ApplicationFlag,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(InstalledPackageInfo__storage_, applicationFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InstalledPackageInfo class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InstalledPackageInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\013\000\002E\000\003\004B\000\004\010\000\005\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ST

@implementation ST

@dynamic hasIsMorkLocOpen, isMorkLocOpen;
@dynamic hasMsgLevel, msgLevel;
@dynamic hasIsDbgConnected, isDbgConnected;
@dynamic hasPkgHash3, pkgHash3;
@dynamic hasRatioFwVer, ratioFwVer;
@dynamic hasOsRelVer, osRelVer;
@dynamic hasImei, imei;
@dynamic hasAndroidId, androidId;
@dynamic hasPhoneSerial, phoneSerial;
@dynamic hasPhoneModel, phoneModel;
@dynamic hasCpuCoreCount, cpuCoreCount;
@dynamic hasCpuHw, cpuHw;
@dynamic hasCpuFeatures, cpuFeatures;
@dynamic hasSelfMac, selfMac;
@dynamic hasSsid, ssid;
@dynamic hasBssid, bssid;
@dynamic hasSpInfo, spInfo;
@dynamic hasApninfo, apninfo;
@dynamic hasBuildFp, buildFp;
@dynamic hasBuildBoard, buildBoard;
@dynamic hasBuildBootloader, buildBootloader;
@dynamic hasBuildBrand, buildBrand;
@dynamic hasBuildDevice, buildDevice;
@dynamic hasBuildHw, buildHw;
@dynamic hasBuildProduct, buildProduct;
@dynamic hasManufacturer, manufacturer;
@dynamic hasPhoneNum, phoneNum;
@dynamic hasNetType, netType;
@dynamic hasIsQemuEnv, isQemuEnv;
@dynamic hasHasDupPkg, hasDupPkg;
@dynamic hasHasQikuShadow, hasQikuShadow;
@dynamic hasPkgName, pkgName;
@dynamic hasAppName, appName;
@dynamic hasDataRoot, dataRoot;
@dynamic hasEntranceClassLoaderName, entranceClassLoaderName;
@dynamic mmprocLoadedFilesArray, mmprocLoadedFilesArray_Count;
@dynamic hasRiskScanReqBuffer, riskScanReqBuffer;
@dynamic hasEnvBits, envBits;
@dynamic installedPackageInfosArray, installedPackageInfosArray_Count;
@dynamic hasAccessibilityClickCount, accessibilityClickCount;
@dynamic hasApkleadingMd5, apkleadingMd5;
@dynamic hasClientVersion, clientVersion;
@dynamic hasWxtag, wxtag;
@dynamic hasClientIp, clientIp;
@dynamic hasLanguage, language;
@dynamic hasIsInCalling, isInCalling;
@dynamic hasIsSetScreenLock, isSetScreenLock;
@dynamic hasNeighborBssidlist, neighborBssidlist;
@dynamic hasIsWifiOpen, isWifiOpen;
@dynamic hasHasXposedStackTrace, hasXposedStackTrace;
@dynamic hasXposedHookedMethods, xposedHookedMethods;
@dynamic hasIsAdbswitchEnabled, isAdbswitchEnabled;
@dynamic hasIsRunningByMonkey, isRunningByMonkey;
@dynamic hasAppInstrumentationClassName, appInstrumentationClassName;
@dynamic hasAmsbinderClassName, amsbinderClassName;
@dynamic hasAmssingletonClassName, amssingletonClassName;
@dynamic hasIsVpnused, isVpnused;
@dynamic hasIsVpnconnected, isVpnconnected;
@dynamic hasPcodes, pcodes;
@dynamic hasHasQcodes, hasQcodes;
@dynamic hasRcodes0, rcodes0;
@dynamic hasRcodes1, rcodes1;
@dynamic hasStid, stid;
@dynamic hasKernelReleaseNumber, kernelReleaseNumber;
@dynamic hasUsbState, usbState;
@dynamic hasApkSignatureMd5, apkSignatureMd5;
@dynamic hasGoogleServiceState, googleServiceState;
@dynamic hasTimeval1, timeval1;
@dynamic hasSpamInfoVersionSeq, spamInfoVersionSeq;
@dynamic hasInitialSeq, initialSeq;
@dynamic hasPathMd51, pathMd51;
@dynamic hasPathMd52, pathMd52;
@dynamic hasPathMd53, pathMd53;
@dynamic hasPathMd54, pathMd54;
@dynamic hasSoteruid, soteruid;
@dynamic hasWidevineDeviceId, widevineDeviceId;
@dynamic hasStorageId, storageId;
@dynamic hasOaid, oaid;
@dynamic hasUnkonwTag80, unkonwTag80;
@dynamic hasTimeval2, timeval2;
@dynamic hasFileModifiedInframework, fileModifiedInframework;

typedef struct ST__storage_ {
  uint32_t _has_storage_[3];
  uint32_t isMorkLocOpen;
  uint32_t msgLevel;
  uint32_t isDbgConnected;
  uint32_t cpuCoreCount;
  uint32_t isQemuEnv;
  uint32_t hasDupPkg;
  uint32_t hasQikuShadow;
  uint32_t envBits;
  uint32_t accessibilityClickCount;
  uint32_t isInCalling;
  uint32_t isSetScreenLock;
  uint32_t isWifiOpen;
  uint32_t hasXposedStackTrace;
  uint32_t isAdbswitchEnabled;
  uint32_t isRunningByMonkey;
  uint32_t isVpnused;
  uint32_t isVpnconnected;
  uint32_t usbState;
  uint32_t googleServiceState;
  uint32_t timeval1;
  uint32_t spamInfoVersionSeq;
  uint32_t initialSeq;
  uint32_t unkonwTag80;
  uint32_t timeval2;
  NSString *pkgHash3;
  NSString *ratioFwVer;
  NSString *osRelVer;
  NSString *imei;
  NSString *androidId;
  NSString *phoneSerial;
  NSString *phoneModel;
  NSString *cpuHw;
  NSString *cpuFeatures;
  NSString *selfMac;
  NSString *ssid;
  NSString *bssid;
  NSString *spInfo;
  NSString *apninfo;
  NSString *buildFp;
  NSString *buildBoard;
  NSString *buildBootloader;
  NSString *buildBrand;
  NSString *buildDevice;
  NSString *buildHw;
  NSString *buildProduct;
  NSString *manufacturer;
  NSString *phoneNum;
  NSString *netType;
  NSString *pkgName;
  NSString *appName;
  NSString *dataRoot;
  NSString *entranceClassLoaderName;
  NSMutableArray *mmprocLoadedFilesArray;
  NSString *riskScanReqBuffer;
  NSMutableArray *installedPackageInfosArray;
  NSString *apkleadingMd5;
  NSString *clientVersion;
  NSString *wxtag;
  NSString *clientIp;
  NSString *language;
  NSString *neighborBssidlist;
  NSString *xposedHookedMethods;
  NSString *appInstrumentationClassName;
  NSString *amsbinderClassName;
  NSString *amssingletonClassName;
  NSString *pcodes;
  NSString *hasQcodes;
  NSString *rcodes0;
  NSString *rcodes1;
  NSString *stid;
  NSString *kernelReleaseNumber;
  NSString *apkSignatureMd5;
  NSString *pathMd51;
  NSString *pathMd52;
  NSString *pathMd53;
  NSString *pathMd54;
  NSString *soteruid;
  NSString *widevineDeviceId;
  NSString *storageId;
  NSString *oaid;
  NSString *fileModifiedInframework;
} ST__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isMorkLocOpen",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsMorkLocOpen,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ST__storage_, isMorkLocOpen),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgLevel",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_MsgLevel,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ST__storage_, msgLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isDbgConnected",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsDbgConnected,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ST__storage_, isDbgConnected),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pkgHash3",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PkgHash3,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ST__storage_, pkgHash3),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ratioFwVer",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_RatioFwVer,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ST__storage_, ratioFwVer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "osRelVer",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_OsRelVer,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ST__storage_, osRelVer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imei",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Imei,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ST__storage_, imei),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidId",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_AndroidId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ST__storage_, androidId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phoneSerial",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PhoneSerial,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ST__storage_, phoneSerial),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phoneModel",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PhoneModel,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ST__storage_, phoneModel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cpuCoreCount",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_CpuCoreCount,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ST__storage_, cpuCoreCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cpuHw",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_CpuHw,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ST__storage_, cpuHw),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cpuFeatures",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_CpuFeatures,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ST__storage_, cpuFeatures),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selfMac",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SelfMac,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ST__storage_, selfMac),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ssid",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Ssid,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ST__storage_, ssid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bssid",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Bssid,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ST__storage_, bssid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "spInfo",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SpInfo,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ST__storage_, spInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "apninfo",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Apninfo,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ST__storage_, apninfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildFp",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildFp,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ST__storage_, buildFp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildBoard",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildBoard,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ST__storage_, buildBoard),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildBootloader",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildBootloader,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ST__storage_, buildBootloader),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildBrand",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildBrand,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ST__storage_, buildBrand),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildDevice",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildDevice,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(ST__storage_, buildDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildHw",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildHw,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(ST__storage_, buildHw),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "buildProduct",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_BuildProduct,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(ST__storage_, buildProduct),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "manufacturer",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Manufacturer,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(ST__storage_, manufacturer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phoneNum",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PhoneNum,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(ST__storage_, phoneNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "netType",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_NetType,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(ST__storage_, netType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isQemuEnv",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsQemuEnv,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(ST__storage_, isQemuEnv),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hasDupPkg",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_HasDupPkg,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(ST__storage_, hasDupPkg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hasQikuShadow",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_HasQikuShadow,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(ST__storage_, hasQikuShadow),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pkgName",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PkgName,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(ST__storage_, pkgName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appName",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_AppName,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(ST__storage_, appName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dataRoot",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_DataRoot,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(ST__storage_, dataRoot),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "entranceClassLoaderName",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_EntranceClassLoaderName,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(ST__storage_, entranceClassLoaderName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mmprocLoadedFilesArray",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_MmprocLoadedFilesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ST__storage_, mmprocLoadedFilesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "riskScanReqBuffer",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_RiskScanReqBuffer,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(ST__storage_, riskScanReqBuffer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "envBits",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_EnvBits,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(ST__storage_, envBits),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "installedPackageInfosArray",
        .dataTypeSpecific.className = GPBStringifySymbol(InstalledPackageInfo),
        .number = ST_FieldNumber_InstalledPackageInfosArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ST__storage_, installedPackageInfosArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accessibilityClickCount",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_AccessibilityClickCount,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(ST__storage_, accessibilityClickCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "apkleadingMd5",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_ApkleadingMd5,
        .hasIndex = 38,
        .offset = (uint32_t)offsetof(ST__storage_, apkleadingMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_ClientVersion,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(ST__storage_, clientVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wxtag",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Wxtag,
        .hasIndex = 40,
        .offset = (uint32_t)offsetof(ST__storage_, wxtag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientIp",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_ClientIp,
        .hasIndex = 41,
        .offset = (uint32_t)offsetof(ST__storage_, clientIp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Language,
        .hasIndex = 42,
        .offset = (uint32_t)offsetof(ST__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isInCalling",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsInCalling,
        .hasIndex = 43,
        .offset = (uint32_t)offsetof(ST__storage_, isInCalling),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isSetScreenLock",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsSetScreenLock,
        .hasIndex = 44,
        .offset = (uint32_t)offsetof(ST__storage_, isSetScreenLock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "neighborBssidlist",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_NeighborBssidlist,
        .hasIndex = 45,
        .offset = (uint32_t)offsetof(ST__storage_, neighborBssidlist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isWifiOpen",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsWifiOpen,
        .hasIndex = 46,
        .offset = (uint32_t)offsetof(ST__storage_, isWifiOpen),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hasXposedStackTrace",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_HasXposedStackTrace,
        .hasIndex = 47,
        .offset = (uint32_t)offsetof(ST__storage_, hasXposedStackTrace),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "xposedHookedMethods",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_XposedHookedMethods,
        .hasIndex = 48,
        .offset = (uint32_t)offsetof(ST__storage_, xposedHookedMethods),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isAdbswitchEnabled",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsAdbswitchEnabled,
        .hasIndex = 49,
        .offset = (uint32_t)offsetof(ST__storage_, isAdbswitchEnabled),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isRunningByMonkey",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsRunningByMonkey,
        .hasIndex = 50,
        .offset = (uint32_t)offsetof(ST__storage_, isRunningByMonkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "appInstrumentationClassName",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_AppInstrumentationClassName,
        .hasIndex = 51,
        .offset = (uint32_t)offsetof(ST__storage_, appInstrumentationClassName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amsbinderClassName",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_AmsbinderClassName,
        .hasIndex = 52,
        .offset = (uint32_t)offsetof(ST__storage_, amsbinderClassName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amssingletonClassName",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_AmssingletonClassName,
        .hasIndex = 53,
        .offset = (uint32_t)offsetof(ST__storage_, amssingletonClassName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isVpnused",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsVpnused,
        .hasIndex = 54,
        .offset = (uint32_t)offsetof(ST__storage_, isVpnused),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isVpnconnected",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_IsVpnconnected,
        .hasIndex = 55,
        .offset = (uint32_t)offsetof(ST__storage_, isVpnconnected),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pcodes",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Pcodes,
        .hasIndex = 56,
        .offset = (uint32_t)offsetof(ST__storage_, pcodes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hasQcodes",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_HasQcodes,
        .hasIndex = 57,
        .offset = (uint32_t)offsetof(ST__storage_, hasQcodes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rcodes0",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Rcodes0,
        .hasIndex = 58,
        .offset = (uint32_t)offsetof(ST__storage_, rcodes0),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rcodes1",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Rcodes1,
        .hasIndex = 59,
        .offset = (uint32_t)offsetof(ST__storage_, rcodes1),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stid",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Stid,
        .hasIndex = 60,
        .offset = (uint32_t)offsetof(ST__storage_, stid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "kernelReleaseNumber",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_KernelReleaseNumber,
        .hasIndex = 61,
        .offset = (uint32_t)offsetof(ST__storage_, kernelReleaseNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "usbState",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_UsbState,
        .hasIndex = 62,
        .offset = (uint32_t)offsetof(ST__storage_, usbState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "apkSignatureMd5",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_ApkSignatureMd5,
        .hasIndex = 63,
        .offset = (uint32_t)offsetof(ST__storage_, apkSignatureMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "googleServiceState",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_GoogleServiceState,
        .hasIndex = 64,
        .offset = (uint32_t)offsetof(ST__storage_, googleServiceState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "timeval1",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Timeval1,
        .hasIndex = 65,
        .offset = (uint32_t)offsetof(ST__storage_, timeval1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "spamInfoVersionSeq",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_SpamInfoVersionSeq,
        .hasIndex = 66,
        .offset = (uint32_t)offsetof(ST__storage_, spamInfoVersionSeq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "initialSeq",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_InitialSeq,
        .hasIndex = 67,
        .offset = (uint32_t)offsetof(ST__storage_, initialSeq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pathMd51",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PathMd51,
        .hasIndex = 68,
        .offset = (uint32_t)offsetof(ST__storage_, pathMd51),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pathMd52",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PathMd52,
        .hasIndex = 69,
        .offset = (uint32_t)offsetof(ST__storage_, pathMd52),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pathMd53",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PathMd53,
        .hasIndex = 70,
        .offset = (uint32_t)offsetof(ST__storage_, pathMd53),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pathMd54",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_PathMd54,
        .hasIndex = 71,
        .offset = (uint32_t)offsetof(ST__storage_, pathMd54),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "soteruid",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Soteruid,
        .hasIndex = 72,
        .offset = (uint32_t)offsetof(ST__storage_, soteruid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "widevineDeviceId",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_WidevineDeviceId,
        .hasIndex = 73,
        .offset = (uint32_t)offsetof(ST__storage_, widevineDeviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "storageId",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_StorageId,
        .hasIndex = 74,
        .offset = (uint32_t)offsetof(ST__storage_, storageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oaid",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Oaid,
        .hasIndex = 75,
        .offset = (uint32_t)offsetof(ST__storage_, oaid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "unkonwTag80",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_UnkonwTag80,
        .hasIndex = 76,
        .offset = (uint32_t)offsetof(ST__storage_, unkonwTag80),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "timeval2",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_Timeval2,
        .hasIndex = 77,
        .offset = (uint32_t)offsetof(ST__storage_, timeval2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fileModifiedInframework",
        .dataTypeSpecific.className = NULL,
        .number = ST_FieldNumber_FileModifiedInframework,
        .hasIndex = 78,
        .offset = (uint32_t)offsetof(ST__storage_, fileModifiedInframework),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ST class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ST__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "N\001M\000\002H\000\003N\000\004H\000\005J\000\006H\000\007d\000\010HA\000\tK\000\nJ\000\013L\000\014DA\000\r"
        "K\000\016Eb\000\017d\000\020e\000\021F\000\022d\003\000\023FA\000\024J\000\025O\000\026J\000\027K\000\030FA\000\031"
        "L\000\032L\000\033H\000\034G\000\035I\000\036I\000\037M\000 G\000!G\000\"H\000#W\000$\000MMProc"
        "LoadedFiles\000%Q\000&G\000(\000InstalledPackageInfo"
        "s\000)W\000*d\007B\000+M\000,c\002\000-GA\000.H\000/K\0000O\0001Ie\003\0002J\0003S"
        "\0004S\0005Cc\014\0006Q\0007[\0008d\016\0009d\021\000:Cc\003\000;Cc\010\000<b\004\000=DE"
        "\000>b\005\000\?b\005\000@d\000AS\000BH\000C\017\000D\022\000F\022\000G\n\000H\010\000I\010\000J\010\000K"
        "\010\000MOA\000N\010A\000Od\000P\013\000R\027\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClientSpamInfo

@implementation ClientSpamInfo

@dynamic hasCcdcc, ccdcc;
@dynamic hasCcdts, ccdts;
@dynamic hasSt, st;

typedef struct ClientSpamInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t ccdcc;
  uint32_t ccdts;
  ST *st;
} ClientSpamInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ccdcc",
        .dataTypeSpecific.className = NULL,
        .number = ClientSpamInfo_FieldNumber_Ccdcc,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ClientSpamInfo__storage_, ccdcc),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ccdts",
        .dataTypeSpecific.className = NULL,
        .number = ClientSpamInfo_FieldNumber_Ccdts,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ClientSpamInfo__storage_, ccdts),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "st",
        .dataTypeSpecific.className = GPBStringifySymbol(ST),
        .number = ClientSpamInfo_FieldNumber_St,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ClientSpamInfo__storage_, st),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClientSpamInfo class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ClientSpamInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WCSTF

@implementation WCSTF

@dynamic hasSt, st;
@dynamic hasEt, et;
@dynamic hasCc, cc;
@dynamic ctArray, ctArray_Count;

typedef struct WCSTF__storage_ {
  uint32_t _has_storage_[1];
  uint32_t st;
  uint32_t et;
  uint32_t cc;
  GPBUInt32Array *ctArray;
} WCSTF__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "st",
        .dataTypeSpecific.className = NULL,
        .number = WCSTF_FieldNumber_St,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WCSTF__storage_, st),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "et",
        .dataTypeSpecific.className = NULL,
        .number = WCSTF_FieldNumber_Et,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WCSTF__storage_, et),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cc",
        .dataTypeSpecific.className = NULL,
        .number = WCSTF_FieldNumber_Cc,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WCSTF__storage_, cc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ctArray",
        .dataTypeSpecific.className = NULL,
        .number = WCSTF_FieldNumber_CtArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(WCSTF__storage_, ctArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WCSTF class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WCSTF__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WCSTE

@implementation WCSTE

@dynamic hasContext, context;
@dynamic hasSt, st;
@dynamic hasEt, et;
@dynamic hasIec, iec;
@dynamic hasTec, tec;
@dynamic hasAsst, asst;
@dynamic hasPss, pss;
@dynamic hasTlmj, tlmj;
@dynamic hasTlmn, tlmn;
@dynamic hasThmj, thmj;
@dynamic hasThmn, thmn;
@dynamic hasSz, sz;

typedef struct WCSTE__storage_ {
  uint32_t _has_storage_[1];
  uint32_t st;
  uint32_t et;
  uint32_t iec;
  uint32_t tec;
  uint32_t asst;
  NSString *context;
  uint64_t pss;
  uint64_t tlmj;
  uint64_t tlmn;
  uint64_t thmj;
  uint64_t thmn;
  uint64_t sz;
} WCSTE__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "context",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Context,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WCSTE__storage_, context),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "st",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_St,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WCSTE__storage_, st),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "et",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Et,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WCSTE__storage_, et),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "iec",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Iec,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WCSTE__storage_, iec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tec",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Tec,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(WCSTE__storage_, tec),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "asst",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Asst,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(WCSTE__storage_, asst),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pss",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Pss,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(WCSTE__storage_, pss),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tlmj",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Tlmj,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(WCSTE__storage_, tlmj),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "tlmn",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Tlmn,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(WCSTE__storage_, tlmn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "thmj",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Thmj,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(WCSTE__storage_, thmj),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "thmn",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Thmn,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(WCSTE__storage_, thmn),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "sz",
        .dataTypeSpecific.className = NULL,
        .number = WCSTE_FieldNumber_Sz,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(WCSTE__storage_, sz),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WCSTE class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WCSTE__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPKeyVal

@implementation FPKeyVal

@dynamic hasKey, key;
@dynamic hasValue, value;

typedef struct FPKeyVal__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  NSString *value;
} FPKeyVal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = FPKeyVal_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPKeyVal__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = FPKeyVal_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FPKeyVal__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPKeyVal class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPKeyVal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPKeyVals

@implementation FPKeyVals

@dynamic keyValArray, keyValArray_Count;

typedef struct FPKeyVals__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *keyValArray;
} FPKeyVals__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyValArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FPKeyVal),
        .number = FPKeyVals_FieldNumber_KeyValArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(FPKeyVals__storage_, keyValArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPKeyVals class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPKeyVals__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000keyVal\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FPDevice

@implementation FPDevice

@dynamic hasKeyvals, keyvals;

typedef struct FPDevice__storage_ {
  uint32_t _has_storage_[1];
  FPKeyVals *keyvals;
} FPDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyvals",
        .dataTypeSpecific.className = GPBStringifySymbol(FPKeyVals),
        .number = FPDevice_FieldNumber_Keyvals,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FPDevice__storage_, keyvals),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FPDevice class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FPDevice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpamInfoEncrypedResult

@implementation SpamInfoEncrypedResult

@dynamic hasType, type;
@dynamic hasTag2, tag2;
@dynamic hasEncrypedData, encrypedData;
@dynamic hasTimestamp, timestamp;
@dynamic hasTag5, tag5;
@dynamic hasTag6, tag6;

typedef struct SpamInfoEncrypedResult__storage_ {
  uint32_t _has_storage_[1];
  uint32_t tag2;
  uint32_t timestamp;
  uint32_t tag5;
  uint32_t tag6;
  NSString *type;
  NSData *encrypedData;
} SpamInfoEncrypedResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = SpamInfoEncrypedResult_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpamInfoEncrypedResult__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag2",
        .dataTypeSpecific.className = NULL,
        .number = SpamInfoEncrypedResult_FieldNumber_Tag2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpamInfoEncrypedResult__storage_, tag2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "encrypedData",
        .dataTypeSpecific.className = NULL,
        .number = SpamInfoEncrypedResult_FieldNumber_EncrypedData,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SpamInfoEncrypedResult__storage_, encrypedData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = SpamInfoEncrypedResult_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SpamInfoEncrypedResult__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag5",
        .dataTypeSpecific.className = NULL,
        .number = SpamInfoEncrypedResult_FieldNumber_Tag5,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SpamInfoEncrypedResult__storage_, tag5),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag6",
        .dataTypeSpecific.className = NULL,
        .number = SpamInfoEncrypedResult_FieldNumber_Tag6,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SpamInfoEncrypedResult__storage_, tag6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpamInfoEncrypedResult class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpamInfoEncrypedResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpamBuff

@implementation SpamBuff

@dynamic hasUnknowntag2, unknowntag2;
@dynamic hasDevicetoken, devicetoken;
@dynamic hasTimestamp, timestamp;

typedef struct SpamBuff__storage_ {
  uint32_t _has_storage_[1];
  uint32_t timestamp;
  SpamBuff_UnknownTag2 *unknowntag2;
  NSString *devicetoken;
} SpamBuff__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unknowntag2",
        .dataTypeSpecific.className = GPBStringifySymbol(SpamBuff_UnknownTag2),
        .number = SpamBuff_FieldNumber_Unknowntag2,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpamBuff__storage_, unknowntag2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "devicetoken",
        .dataTypeSpecific.className = NULL,
        .number = SpamBuff_FieldNumber_Devicetoken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpamBuff__storage_, devicetoken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = SpamBuff_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SpamBuff__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpamBuff class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpamBuff__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpamBuff_UnknownTag2

@implementation SpamBuff_UnknownTag2

@dynamic hasUnknowntag1, unknowntag1;
@dynamic hasUnknowntag2, unknowntag2;

typedef struct SpamBuff_UnknownTag2__storage_ {
  uint32_t _has_storage_[1];
  NSData *unknowntag1;
  NSData *unknowntag2;
} SpamBuff_UnknownTag2__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unknowntag1",
        .dataTypeSpecific.className = NULL,
        .number = SpamBuff_UnknownTag2_FieldNumber_Unknowntag1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpamBuff_UnknownTag2__storage_, unknowntag1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "unknowntag2",
        .dataTypeSpecific.className = NULL,
        .number = SpamBuff_UnknownTag2_FieldNumber_Unknowntag2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpamBuff_UnknownTag2__storage_, unknowntag2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpamBuff_UnknownTag2 class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpamBuff_UnknownTag2__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SpamBuff)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceToken

@implementation DeviceToken

@dynamic hasTag1, tag1;
@dynamic hasTag2, tag2;
@dynamic hasToken, token;
@dynamic hasTimestamp, timestamp;
@dynamic hasTag5, tag5;
@dynamic hasTag6, tag6;

typedef struct DeviceToken__storage_ {
  uint32_t _has_storage_[1];
  uint32_t tag2;
  uint32_t timestamp;
  uint32_t tag5;
  uint32_t tag6;
  NSString *tag1;
  DeviceToken_Token *token;
} DeviceToken__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tag1",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_Tag1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, tag1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag2",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_Tag2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, tag2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = GPBStringifySymbol(DeviceToken_Token),
        .number = DeviceToken_FieldNumber_Token,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_Timestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag5",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_Tag5,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, tag5),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tag6",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_FieldNumber_Tag6,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DeviceToken__storage_, tag6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceToken class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceToken__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeviceToken_Token

@implementation DeviceToken_Token

@dynamic hasDevicetoken, devicetoken;

typedef struct DeviceToken_Token__storage_ {
  uint32_t _has_storage_[1];
  NSString *devicetoken;
} DeviceToken_Token__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "devicetoken",
        .dataTypeSpecific.className = NULL,
        .number = DeviceToken_Token_FieldNumber_Devicetoken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceToken_Token__storage_, devicetoken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceToken_Token class]
                                     rootClass:[SafeRoot class]
                                          file:SafeRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceToken_Token__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(DeviceToken)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
