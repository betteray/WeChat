// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmtrack.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mmtrack.pbobjc.h"
#import "Mmbuiltintype.pbobjc.h"
#import "Mmbase.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmtrackRoot

@implementation MmtrackRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MmtrackRoot_FileDescriptor

static GPBFileDescriptor *MmtrackRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"micromsg"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - PositionItem

@implementation PositionItem

@dynamic hasLatitude, latitude;
@dynamic hasLongitude, longitude;
@dynamic hasHeading, heading;

typedef struct PositionItem__storage_ {
  uint32_t _has_storage_[1];
  double latitude;
  double longitude;
  double heading;
} PositionItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = PositionItem_FieldNumber_Latitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PositionItem__storage_, latitude),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = PositionItem_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PositionItem__storage_, longitude),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "heading",
        .dataTypeSpecific.className = NULL,
        .number = PositionItem_FieldNumber_Heading,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PositionItem__storage_, heading),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PositionItem class]
                                     rootClass:[MmtrackRoot class]
                                          file:MmtrackRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PositionItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001H\000\002I\000\003G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TrackPOIItem

@implementation TrackPOIItem

@dynamic hasLatitude, latitude;
@dynamic hasLongitude, longitude;
@dynamic hasName, name;
@dynamic hasAddr, addr;

typedef struct TrackPOIItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *addr;
  double latitude;
  double longitude;
} TrackPOIItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = TrackPOIItem_FieldNumber_Latitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TrackPOIItem__storage_, latitude),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = TrackPOIItem_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TrackPOIItem__storage_, longitude),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = TrackPOIItem_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TrackPOIItem__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "addr",
        .dataTypeSpecific.className = NULL,
        .number = TrackPOIItem_FieldNumber_Addr,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TrackPOIItem__storage_, addr),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TrackPOIItem class]
                                     rootClass:[MmtrackRoot class]
                                          file:MmtrackRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TrackPOIItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001H\000\002I\000\003D\000\004D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserPositionItem

@implementation UserPositionItem

@dynamic hasUsername, username;
@dynamic hasPosition, position;

typedef struct UserPositionItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *username;
  PositionItem *position;
} UserPositionItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = UserPositionItem_FieldNumber_Username,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserPositionItem__storage_, username),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "position",
        .dataTypeSpecific.className = GPBStringifySymbol(PositionItem),
        .number = UserPositionItem_FieldNumber_Position,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserPositionItem__storage_, position),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserPositionItem class]
                                     rootClass:[MmtrackRoot class]
                                          file:MmtrackRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserPositionItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RefreshTrackRoomRequest

@implementation RefreshTrackRoomRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasTrackRoomId, trackRoomId;
@dynamic hasType, type;
@dynamic hasUserPosition, userPosition;
@dynamic hasTimeStamp, timeStamp;
@dynamic hasUserPoi, userPoi;

typedef struct RefreshTrackRoomRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  uint32_t timeStamp;
  BaseRequest *baseRequest;
  NSString *trackRoomId;
  UserPositionItem *userPosition;
  TrackPOIItem *userPoi;
} RefreshTrackRoomRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = RefreshTrackRoomRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RefreshTrackRoomRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trackRoomId",
        .dataTypeSpecific.className = NULL,
        .number = RefreshTrackRoomRequest_FieldNumber_TrackRoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RefreshTrackRoomRequest__storage_, trackRoomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = RefreshTrackRoomRequest_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RefreshTrackRoomRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userPosition",
        .dataTypeSpecific.className = GPBStringifySymbol(UserPositionItem),
        .number = RefreshTrackRoomRequest_FieldNumber_UserPosition,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RefreshTrackRoomRequest__storage_, userPosition),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = RefreshTrackRoomRequest_FieldNumber_TimeStamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RefreshTrackRoomRequest__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userPoi",
        .dataTypeSpecific.className = GPBStringifySymbol(TrackPOIItem),
        .number = RefreshTrackRoomRequest_FieldNumber_UserPoi,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RefreshTrackRoomRequest__storage_, userPoi),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RefreshTrackRoomRequest class]
                                     rootClass:[MmtrackRoot class]
                                          file:MmtrackRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RefreshTrackRoomRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001K\000\002JA\000\003D\000\004L\000\005I\000\006G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RefreshTrackRoomResponse

@implementation RefreshTrackRoomResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCount, count;
@dynamic positionsArray, positionsArray_Count;
@dynamic hasRetMsg, retMsg;
@dynamic hasRefreshTime, refreshTime;
@dynamic hasRoomPoi, roomPoi;

typedef struct RefreshTrackRoomResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  uint32_t refreshTime;
  BaseResponse *baseResponse;
  NSMutableArray *positionsArray;
  NSString *retMsg;
  TrackPOIItem *roomPoi;
} RefreshTrackRoomResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = RefreshTrackRoomResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RefreshTrackRoomResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = RefreshTrackRoomResponse_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RefreshTrackRoomResponse__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "positionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(UserPositionItem),
        .number = RefreshTrackRoomResponse_FieldNumber_PositionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RefreshTrackRoomResponse__storage_, positionsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "retMsg",
        .dataTypeSpecific.className = NULL,
        .number = RefreshTrackRoomResponse_FieldNumber_RetMsg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RefreshTrackRoomResponse__storage_, retMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "refreshTime",
        .dataTypeSpecific.className = NULL,
        .number = RefreshTrackRoomResponse_FieldNumber_RefreshTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RefreshTrackRoomResponse__storage_, refreshTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "roomPoi",
        .dataTypeSpecific.className = GPBStringifySymbol(TrackPOIItem),
        .number = RefreshTrackRoomResponse_FieldNumber_RoomPoi,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RefreshTrackRoomResponse__storage_, roomPoi),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RefreshTrackRoomResponse class]
                                     rootClass:[MmtrackRoot class]
                                          file:MmtrackRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RefreshTrackRoomResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001L\000\002E\000\003\000Positions\000\004F\000\005K\000\006G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - JoinTrackRoomRequest

@implementation JoinTrackRoomRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasChatname, chatname;
@dynamic hasScene, scene;

typedef struct JoinTrackRoomRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t scene;
  BaseRequest *baseRequest;
  NSString *chatname;
} JoinTrackRoomRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = JoinTrackRoomRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(JoinTrackRoomRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatname",
        .dataTypeSpecific.className = NULL,
        .number = JoinTrackRoomRequest_FieldNumber_Chatname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(JoinTrackRoomRequest__storage_, chatname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = JoinTrackRoomRequest_FieldNumber_Scene,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(JoinTrackRoomRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JoinTrackRoomRequest class]
                                     rootClass:[MmtrackRoot class]
                                          file:MmtrackRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(JoinTrackRoomRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002H\000\003E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - JoinTrackRoomResponse

@implementation JoinTrackRoomResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasTrackRoomId, trackRoomId;
@dynamic hasRetMsg, retMsg;

typedef struct JoinTrackRoomResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *trackRoomId;
  NSString *retMsg;
} JoinTrackRoomResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = JoinTrackRoomResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(JoinTrackRoomResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trackRoomId",
        .dataTypeSpecific.className = NULL,
        .number = JoinTrackRoomResponse_FieldNumber_TrackRoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(JoinTrackRoomResponse__storage_, trackRoomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "retMsg",
        .dataTypeSpecific.className = NULL,
        .number = JoinTrackRoomResponse_FieldNumber_RetMsg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(JoinTrackRoomResponse__storage_, retMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JoinTrackRoomResponse class]
                                     rootClass:[MmtrackRoot class]
                                          file:MmtrackRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(JoinTrackRoomResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002JA\000\003F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExitTrackRoomRequest

@implementation ExitTrackRoomRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasTrackRoomId, trackRoomId;
@dynamic hasScene, scene;

typedef struct ExitTrackRoomRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t scene;
  BaseRequest *baseRequest;
  NSString *trackRoomId;
} ExitTrackRoomRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ExitTrackRoomRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExitTrackRoomRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "trackRoomId",
        .dataTypeSpecific.className = NULL,
        .number = ExitTrackRoomRequest_FieldNumber_TrackRoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExitTrackRoomRequest__storage_, trackRoomId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = ExitTrackRoomRequest_FieldNumber_Scene,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExitTrackRoomRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExitTrackRoomRequest class]
                                     rootClass:[MmtrackRoot class]
                                          file:MmtrackRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExitTrackRoomRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002JA\000\003E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExitTrackRoomResponse

@implementation ExitTrackRoomResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasRetMsg, retMsg;

typedef struct ExitTrackRoomResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *retMsg;
} ExitTrackRoomResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ExitTrackRoomResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExitTrackRoomResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "retMsg",
        .dataTypeSpecific.className = NULL,
        .number = ExitTrackRoomResponse_FieldNumber_RetMsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExitTrackRoomResponse__storage_, retMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExitTrackRoomResponse class]
                                     rootClass:[MmtrackRoot class]
                                          file:MmtrackRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExitTrackRoomResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
