// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmbase.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mmbase.pbobjc.h"
#import "Mmbuiltintype.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmbaseRoot

@implementation MmbaseRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MmbaseRoot_FileDescriptor

static GPBFileDescriptor *MmbaseRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - BuiltinIP

@implementation BuiltinIP

@dynamic hasType, type;
@dynamic hasPort, port;
@dynamic hasIp, ip;
@dynamic hasDomain, domain;

typedef struct BuiltinIP__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t port;
  NSData *ip;
  NSData *domain;
} BuiltinIP__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIP_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BuiltinIP__storage_, type),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIP_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BuiltinIP__storage_, port),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIP_FieldNumber_Ip,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BuiltinIP__storage_, ip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "domain",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIP_FieldNumber_Domain,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BuiltinIP__storage_, domain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BuiltinIP class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BuiltinIP__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003b\000\004F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BuiltinIPList

@implementation BuiltinIPList

@dynamic hasLongConnectIpcount, longConnectIpcount;
@dynamic hasShortConnectIpcount, shortConnectIpcount;
@dynamic hasSeq, seq;
@dynamic longConnectIplistArray, longConnectIplistArray_Count;
@dynamic shortConnectIplistArray, shortConnectIplistArray_Count;

typedef struct BuiltinIPList__storage_ {
  uint32_t _has_storage_[1];
  uint32_t longConnectIpcount;
  uint32_t shortConnectIpcount;
  uint32_t seq;
  NSMutableArray *longConnectIplistArray;
  NSMutableArray *shortConnectIplistArray;
} BuiltinIPList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "longConnectIpcount",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_FieldNumber_LongConnectIpcount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, longConnectIpcount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "shortConnectIpcount",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_FieldNumber_ShortConnectIpcount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, shortConnectIpcount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "longConnectIplistArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIP),
        .number = BuiltinIPList_FieldNumber_LongConnectIplistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, longConnectIplistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shortConnectIplistArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIP),
        .number = BuiltinIPList_FieldNumber_ShortConnectIplistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, shortConnectIplistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "seq",
        .dataTypeSpecific.className = NULL,
        .number = BuiltinIPList_FieldNumber_Seq,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BuiltinIPList__storage_, seq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BuiltinIPList class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BuiltinIPList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001Lb\004\000\002Mb\004\000\003\000LongConnectIPList\000\004\000ShortCo"
        "nnectIPList\000\005C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkControl

@implementation NetworkControl

@dynamic hasPortList, portList;
@dynamic hasTimeoutList, timeoutList;
@dynamic hasMinNoopInterval, minNoopInterval;
@dynamic hasMaxNoopInterval, maxNoopInterval;
@dynamic hasTypingInterval, typingInterval;
@dynamic hasNoopIntervalTime, noopIntervalTime;

typedef struct NetworkControl__storage_ {
  uint32_t _has_storage_[1];
  uint32_t minNoopInterval;
  uint32_t maxNoopInterval;
  int32_t typingInterval;
  int32_t noopIntervalTime;
  NSString *portList;
  NSString *timeoutList;
} NetworkControl__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "portList",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_PortList,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, portList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeoutList",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_TimeoutList,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, timeoutList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minNoopInterval",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_MinNoopInterval,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, minNoopInterval),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "maxNoopInterval",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_MaxNoopInterval,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, maxNoopInterval),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "typingInterval",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_TypingInterval,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, typingInterval),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "noopIntervalTime",
        .dataTypeSpecific.className = NULL,
        .number = NetworkControl_FieldNumber_NoopIntervalTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NetworkControl__storage_, noopIntervalTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkControl class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkControl__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001H\000\002K\000\003O\000\004O\000\005N\000\007P\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PluginKey

@implementation PluginKey

@dynamic hasKey, key;
@dynamic hasId_p, id_p;

typedef struct PluginKey__storage_ {
  uint32_t _has_storage_[1];
  uint32_t id_p;
  NSString *key;
} PluginKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = PluginKey_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PluginKey__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PluginKey_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PluginKey__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PluginKey class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PluginKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001C\000\002\000Id\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PluginKeyList

@implementation PluginKeyList

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct PluginKeyList__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSMutableArray *listArray;
} PluginKeyList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PluginKeyList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PluginKeyList__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PluginKey),
        .number = PluginKeyList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PluginKeyList__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PluginKeyList class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PluginKeyList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001E\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Host

@implementation Host

@dynamic hasOrigin, origin;
@dynamic hasSubstitute, substitute;
@dynamic hasPriority, priority;

typedef struct Host__storage_ {
  uint32_t _has_storage_[1];
  int32_t priority;
  NSString *origin;
  NSString *substitute;
} Host__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "origin",
        .dataTypeSpecific.className = NULL,
        .number = Host_FieldNumber_Origin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Host__storage_, origin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "substitute",
        .dataTypeSpecific.className = NULL,
        .number = Host_FieldNumber_Substitute,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Host__storage_, substitute),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priority",
        .dataTypeSpecific.className = NULL,
        .number = Host_FieldNumber_Priority,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Host__storage_, priority),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Host class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Host__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001F\000\002J\000\003H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HostList

@implementation HostList

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct HostList__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSMutableArray *listArray;
} HostList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = HostList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HostList__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Host),
        .number = HostList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(HostList__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HostList class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HostList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001E\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PositionInfo

@implementation PositionInfo

@dynamic hasLongitude, longitude;
@dynamic hasLatitude, latitude;
@dynamic hasPrecision, precision;
@dynamic hasMacAddr, macAddr;
@dynamic hasCellId, cellId;
@dynamic hasGpssource, gpssource;

typedef struct PositionInfo__storage_ {
  uint32_t _has_storage_[1];
  float longitude;
  float latitude;
  int32_t precision;
  int32_t gpssource;
  NSString *macAddr;
  NSString *cellId;
} PositionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = PositionInfo_FieldNumber_Longitude,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PositionInfo__storage_, longitude),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = PositionInfo_FieldNumber_Latitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PositionInfo__storage_, latitude),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "precision",
        .dataTypeSpecific.className = NULL,
        .number = PositionInfo_FieldNumber_Precision,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PositionInfo__storage_, precision),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "macAddr",
        .dataTypeSpecific.className = NULL,
        .number = PositionInfo_FieldNumber_MacAddr,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PositionInfo__storage_, macAddr),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cellId",
        .dataTypeSpecific.className = NULL,
        .number = PositionInfo_FieldNumber_CellId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PositionInfo__storage_, cellId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gpssource",
        .dataTypeSpecific.className = NULL,
        .number = PositionInfo_FieldNumber_Gpssource,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PositionInfo__storage_, gpssource),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PositionInfo class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PositionInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001I\000\002H\000\003I\000\004G\000\005F\000\006d\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsUserInfo

@implementation SnsUserInfo

@dynamic hasSnsFlag, snsFlag;
@dynamic hasSnsBgimgId, snsBgimgId;
@dynamic hasSnsBgobjectId, snsBgobjectId;
@dynamic hasSnsFlagEx, snsFlagEx;

typedef struct SnsUserInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t snsFlag;
  uint32_t snsFlagEx;
  NSString *snsBgimgId;
  uint64_t snsBgobjectId;
} SnsUserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "snsFlag",
        .dataTypeSpecific.className = NULL,
        .number = SnsUserInfo_FieldNumber_SnsFlag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsUserInfo__storage_, snsFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "snsBgimgId",
        .dataTypeSpecific.className = NULL,
        .number = SnsUserInfo_FieldNumber_SnsBgimgId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsUserInfo__storage_, snsBgimgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "snsBgobjectId",
        .dataTypeSpecific.className = NULL,
        .number = SnsUserInfo_FieldNumber_SnsBgobjectId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SnsUserInfo__storage_, snsBgobjectId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "snsFlagEx",
        .dataTypeSpecific.className = NULL,
        .number = SnsUserInfo_FieldNumber_SnsFlagEx,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SnsUserInfo__storage_, snsFlagEx),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsUserInfo class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsUserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001G\000\002Db\003A\000\003Db\006A\000\004I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CustomizedInfo

@implementation CustomizedInfo

@dynamic hasBrandFlag, brandFlag;
@dynamic hasExternalInfo, externalInfo;
@dynamic hasBrandInfo, brandInfo;
@dynamic hasBrandIconURL, brandIconURL;

typedef struct CustomizedInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t brandFlag;
  NSString *externalInfo;
  NSString *brandInfo;
  NSString *brandIconURL;
} CustomizedInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "brandFlag",
        .dataTypeSpecific.className = NULL,
        .number = CustomizedInfo_FieldNumber_BrandFlag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CustomizedInfo__storage_, brandFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "externalInfo",
        .dataTypeSpecific.className = NULL,
        .number = CustomizedInfo_FieldNumber_ExternalInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CustomizedInfo__storage_, externalInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "brandInfo",
        .dataTypeSpecific.className = NULL,
        .number = CustomizedInfo_FieldNumber_BrandInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CustomizedInfo__storage_, brandInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "brandIconURL",
        .dataTypeSpecific.className = NULL,
        .number = CustomizedInfo_FieldNumber_BrandIconURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CustomizedInfo__storage_, brandIconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CustomizedInfo class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CustomizedInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001I\000\002L\000\003I\000\004L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CmdItem

@implementation CmdItem

@dynamic hasCmdId, cmdId;
@dynamic hasCmdBuf, cmdBuf;

typedef struct CmdItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t cmdId;
  SKBuiltinBuffer_t *cmdBuf;
} CmdItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cmdId",
        .dataTypeSpecific.className = NULL,
        .number = CmdItem_FieldNumber_CmdId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CmdItem__storage_, cmdId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cmdBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = CmdItem_FieldNumber_CmdBuf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CmdItem__storage_, cmdBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CmdItem class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CmdItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001E\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CmdList

@implementation CmdList

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct CmdList__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSMutableArray *listArray;
} CmdList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = CmdList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CmdList__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdItem),
        .number = CmdList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CmdList__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CmdList class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CmdList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001E\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShakeSyncRequest

@implementation ShakeSyncRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasLongitude, longitude;
@dynamic hasLatitude, latitude;
@dynamic hasPrecision, precision;
@dynamic hasMacAddr, macAddr;
@dynamic hasCellId, cellId;
@dynamic hasImgId, imgId;
@dynamic hasTimes, times;

typedef struct ShakeSyncRequest__storage_ {
  uint32_t _has_storage_[1];
  float longitude;
  float latitude;
  int32_t precision;
  uint32_t imgId;
  uint32_t times;
  BaseRequest *baseRequest;
  NSString *macAddr;
  NSString *cellId;
} ShakeSyncRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ShakeSyncRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShakeSyncRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = ShakeSyncRequest_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShakeSyncRequest__storage_, longitude),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = ShakeSyncRequest_FieldNumber_Latitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShakeSyncRequest__storage_, latitude),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "precision",
        .dataTypeSpecific.className = NULL,
        .number = ShakeSyncRequest_FieldNumber_Precision,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShakeSyncRequest__storage_, precision),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "macAddr",
        .dataTypeSpecific.className = NULL,
        .number = ShakeSyncRequest_FieldNumber_MacAddr,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ShakeSyncRequest__storage_, macAddr),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cellId",
        .dataTypeSpecific.className = NULL,
        .number = ShakeSyncRequest_FieldNumber_CellId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ShakeSyncRequest__storage_, cellId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgId",
        .dataTypeSpecific.className = NULL,
        .number = ShakeSyncRequest_FieldNumber_ImgId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ShakeSyncRequest__storage_, imgId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "times",
        .dataTypeSpecific.className = NULL,
        .number = ShakeSyncRequest_FieldNumber_Times,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ShakeSyncRequest__storage_, times),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShakeSyncRequest class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShakeSyncRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001K\000\002I\000\003H\000\004I\000\005G\000\006F\000\007E\000\010E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShakeSyncResponse

@implementation ShakeSyncResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasBuffer, buffer;
@dynamic hasRet, ret;
@dynamic hasImgId, imgId;
@dynamic hasImgTotoalLen, imgTotoalLen;

typedef struct ShakeSyncResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t ret;
  uint32_t imgId;
  uint32_t imgTotoalLen;
  BaseResponse *baseResponse;
  SKBuiltinBuffer_t *buffer;
} ShakeSyncResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ShakeSyncResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShakeSyncResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "buffer",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ShakeSyncResponse_FieldNumber_Buffer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShakeSyncResponse__storage_, buffer),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = ShakeSyncResponse_FieldNumber_Ret,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShakeSyncResponse__storage_, ret),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgId",
        .dataTypeSpecific.className = NULL,
        .number = ShakeSyncResponse_FieldNumber_ImgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShakeSyncResponse__storage_, imgId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgTotoalLen",
        .dataTypeSpecific.className = NULL,
        .number = ShakeSyncResponse_FieldNumber_ImgTotoalLen,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ShakeSyncResponse__storage_, imgTotoalLen),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShakeSyncResponse class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShakeSyncResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001L\000\002F\000\003C\000\004E\000\005L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindEmailRequest

@implementation BindEmailRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasOpCode, opCode;
@dynamic hasEmail, email;

typedef struct BindEmailRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opCode;
  BaseRequest *baseRequest;
  NSString *email;
} BindEmailRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BindEmailRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindEmailRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opCode",
        .dataTypeSpecific.className = NULL,
        .number = BindEmailRequest_FieldNumber_OpCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindEmailRequest__storage_, opCode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = BindEmailRequest_FieldNumber_Email,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindEmailRequest__storage_, email),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindEmailRequest class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindEmailRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002F\000\003E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindEmailResponse

@implementation BindEmailResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct BindEmailResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} BindEmailResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BindEmailResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindEmailResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindEmailResponse class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindEmailResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLocationRequest

@implementation GetLocationRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasLongitude, longitude;
@dynamic hasLatitude, latitude;
@dynamic hasPrecision, precision;
@dynamic hasMacAddr, macAddr;
@dynamic hasCellId, cellId;
@dynamic hasGpssource, gpssource;

typedef struct GetLocationRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t longitude;
  int32_t latitude;
  int32_t precision;
  int32_t gpssource;
  BaseRequest *baseRequest;
  NSString *macAddr;
  NSString *cellId;
} GetLocationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetLocationRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLocationRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = GetLocationRequest_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLocationRequest__storage_, longitude),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = GetLocationRequest_FieldNumber_Latitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLocationRequest__storage_, latitude),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "precision",
        .dataTypeSpecific.className = NULL,
        .number = GetLocationRequest_FieldNumber_Precision,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetLocationRequest__storage_, precision),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "macAddr",
        .dataTypeSpecific.className = NULL,
        .number = GetLocationRequest_FieldNumber_MacAddr,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetLocationRequest__storage_, macAddr),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cellId",
        .dataTypeSpecific.className = NULL,
        .number = GetLocationRequest_FieldNumber_CellId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetLocationRequest__storage_, cellId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gpssource",
        .dataTypeSpecific.className = NULL,
        .number = GetLocationRequest_FieldNumber_Gpssource,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetLocationRequest__storage_, gpssource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLocationRequest class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLocationRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001K\000\003I\000\004H\000\005I\000\006G\000\007F\000\010d\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLocationResponse

@implementation GetLocationResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasLongitude, longitude;
@dynamic hasLatitude, latitude;

typedef struct GetLocationResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t longitude;
  int32_t latitude;
  BaseResponse *baseResponse;
} GetLocationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetLocationResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLocationResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = GetLocationResponse_FieldNumber_Longitude,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLocationResponse__storage_, longitude),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = GetLocationResponse_FieldNumber_Latitude,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLocationResponse__storage_, latitude),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLocationResponse class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLocationResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002I\000\003H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RoomInfo

@implementation RoomInfo

@dynamic hasUserName, userName;
@dynamic hasNickName, nickName;

typedef struct RoomInfo__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinString_t *userName;
  SKBuiltinString_t *nickName;
} RoomInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = RoomInfo_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RoomInfo__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = RoomInfo_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RoomInfo__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RoomInfo class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RoomInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CDNDnsInfo

@implementation CDNDnsInfo

@dynamic hasVer, ver;
@dynamic hasUin, uin;
@dynamic hasExpireTime, expireTime;
@dynamic hasFrontId, frontId;
@dynamic hasFrontIpcount, frontIpcount;
@dynamic frontIplistArray, frontIplistArray_Count;
@dynamic hasZoneDomain, zoneDomain;
@dynamic hasAuthKey, authKey;
@dynamic hasZoneId, zoneId;
@dynamic hasZoneIpcount, zoneIpcount;
@dynamic zoneIplistArray, zoneIplistArray_Count;

typedef struct CDNDnsInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t ver;
  uint32_t uin;
  uint32_t expireTime;
  int32_t frontId;
  int32_t frontIpcount;
  int32_t zoneId;
  int32_t zoneIpcount;
  NSMutableArray *frontIplistArray;
  NSString *zoneDomain;
  SKBuiltinBuffer_t *authKey;
  NSMutableArray *zoneIplistArray;
} CDNDnsInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ver",
        .dataTypeSpecific.className = NULL,
        .number = CDNDnsInfo_FieldNumber_Ver,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CDNDnsInfo__storage_, ver),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = CDNDnsInfo_FieldNumber_Uin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CDNDnsInfo__storage_, uin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "expireTime",
        .dataTypeSpecific.className = NULL,
        .number = CDNDnsInfo_FieldNumber_ExpireTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CDNDnsInfo__storage_, expireTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "frontId",
        .dataTypeSpecific.className = NULL,
        .number = CDNDnsInfo_FieldNumber_FrontId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CDNDnsInfo__storage_, frontId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "frontIpcount",
        .dataTypeSpecific.className = NULL,
        .number = CDNDnsInfo_FieldNumber_FrontIpcount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CDNDnsInfo__storage_, frontIpcount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "frontIplistArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = CDNDnsInfo_FieldNumber_FrontIplistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CDNDnsInfo__storage_, frontIplistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "zoneDomain",
        .dataTypeSpecific.className = NULL,
        .number = CDNDnsInfo_FieldNumber_ZoneDomain,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CDNDnsInfo__storage_, zoneDomain),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = CDNDnsInfo_FieldNumber_AuthKey,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CDNDnsInfo__storage_, authKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "zoneId",
        .dataTypeSpecific.className = NULL,
        .number = CDNDnsInfo_FieldNumber_ZoneId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(CDNDnsInfo__storage_, zoneId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "zoneIpcount",
        .dataTypeSpecific.className = NULL,
        .number = CDNDnsInfo_FieldNumber_ZoneIpcount,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(CDNDnsInfo__storage_, zoneIpcount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "zoneIplistArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = CDNDnsInfo_FieldNumber_ZoneIplistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CDNDnsInfo__storage_, zoneIplistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CDNDnsInfo class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CDNDnsInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\013\001C\000\002C\000\003J\000\004FA\000\005Fb\004\000\006\000FrontIPList\000\007J\000\010G\000\t"
        "EA\000\nEb\004\000\013\000ZoneIPList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StyleKeyVal

@implementation StyleKeyVal

@dynamic hasKey, key;
@dynamic hasVal, val;

typedef struct StyleKeyVal__storage_ {
  uint32_t _has_storage_[1];
  uint32_t key;
  NSString *val;
} StyleKeyVal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = StyleKeyVal_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StyleKeyVal__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "val",
        .dataTypeSpecific.className = NULL,
        .number = StyleKeyVal_FieldNumber_Val,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StyleKeyVal__storage_, val),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StyleKeyVal class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StyleKeyVal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001C\000\002C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShowStyleKey

@implementation ShowStyleKey

@dynamic hasKeyCount, keyCount;
@dynamic keyArray, keyArray_Count;

typedef struct ShowStyleKey__storage_ {
  uint32_t _has_storage_[1];
  uint32_t keyCount;
  NSMutableArray *keyArray;
} ShowStyleKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyCount",
        .dataTypeSpecific.className = NULL,
        .number = ShowStyleKey_FieldNumber_KeyCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShowStyleKey__storage_, keyCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "keyArray",
        .dataTypeSpecific.className = GPBStringifySymbol(StyleKeyVal),
        .number = ShowStyleKey_FieldNumber_KeyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShowStyleKey__storage_, keyArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShowStyleKey class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShowStyleKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002\000Key\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SafeDevice

@implementation SafeDevice

@dynamic hasName, name;
@dynamic hasUuid, uuid;
@dynamic hasDeviceType, deviceType;
@dynamic hasCreateTime, createTime;

typedef struct SafeDevice__storage_ {
  uint32_t _has_storage_[1];
  uint32_t createTime;
  NSString *name;
  NSString *uuid;
  NSString *deviceType;
} SafeDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = SafeDevice_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SafeDevice__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = SafeDevice_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SafeDevice__storage_, uuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = SafeDevice_FieldNumber_DeviceType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SafeDevice__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = SafeDevice_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SafeDevice__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SafeDevice class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SafeDevice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001D\000\002D\000\003J\000\004J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SafeDeviceList

@implementation SafeDeviceList

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct SafeDeviceList__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSMutableArray *listArray;
} SafeDeviceList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = SafeDeviceList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SafeDeviceList__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SafeDevice),
        .number = SafeDeviceList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SafeDeviceList__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SafeDeviceList class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SafeDeviceList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001E\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberReq

@implementation MemberReq

@dynamic hasMemberName, memberName;

typedef struct MemberReq__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinString_t *memberName;
} MemberReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MemberReq_FieldNumber_MemberName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberReq__storage_, memberName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberReq class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberResp

@implementation MemberResp

@dynamic hasMemberName, memberName;
@dynamic hasMemberStatus, memberStatus;
@dynamic hasNickName, nickName;
@dynamic hasPyinitial, pyinitial;
@dynamic hasQuanPin, quanPin;
@dynamic hasSex, sex;
@dynamic hasRemark, remark;
@dynamic hasRemarkPyinitial, remarkPyinitial;
@dynamic hasRemarkQuanPin, remarkQuanPin;
@dynamic hasContactType, contactType;
@dynamic hasProvince, province;
@dynamic hasCity, city;
@dynamic hasSignature, signature;
@dynamic hasPersonalCard, personalCard;
@dynamic hasVerifyFlag, verifyFlag;
@dynamic hasVerifyInfo, verifyInfo;
@dynamic hasCountry, country;

typedef struct MemberResp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t memberStatus;
  int32_t sex;
  uint32_t contactType;
  uint32_t personalCard;
  uint32_t verifyFlag;
  SKBuiltinString_t *memberName;
  SKBuiltinString_t *nickName;
  SKBuiltinString_t *pyinitial;
  SKBuiltinString_t *quanPin;
  SKBuiltinString_t *remark;
  SKBuiltinString_t *remarkPyinitial;
  SKBuiltinString_t *remarkQuanPin;
  NSString *province;
  NSString *city;
  NSString *signature;
  NSString *verifyInfo;
  NSString *country;
} MemberResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MemberResp_FieldNumber_MemberName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberResp__storage_, memberName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberStatus",
        .dataTypeSpecific.className = NULL,
        .number = MemberResp_FieldNumber_MemberStatus,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MemberResp__storage_, memberStatus),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MemberResp_FieldNumber_NickName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MemberResp__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pyinitial",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MemberResp_FieldNumber_Pyinitial,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MemberResp__storage_, pyinitial),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "quanPin",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MemberResp_FieldNumber_QuanPin,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MemberResp__storage_, quanPin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = MemberResp_FieldNumber_Sex,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MemberResp__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MemberResp_FieldNumber_Remark,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(MemberResp__storage_, remark),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remarkPyinitial",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MemberResp_FieldNumber_RemarkPyinitial,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(MemberResp__storage_, remarkPyinitial),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remarkQuanPin",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MemberResp_FieldNumber_RemarkQuanPin,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(MemberResp__storage_, remarkQuanPin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contactType",
        .dataTypeSpecific.className = NULL,
        .number = MemberResp_FieldNumber_ContactType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(MemberResp__storage_, contactType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "province",
        .dataTypeSpecific.className = NULL,
        .number = MemberResp_FieldNumber_Province,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(MemberResp__storage_, province),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "city",
        .dataTypeSpecific.className = NULL,
        .number = MemberResp_FieldNumber_City,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(MemberResp__storage_, city),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = MemberResp_FieldNumber_Signature,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(MemberResp__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "personalCard",
        .dataTypeSpecific.className = NULL,
        .number = MemberResp_FieldNumber_PersonalCard,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(MemberResp__storage_, personalCard),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "verifyFlag",
        .dataTypeSpecific.className = NULL,
        .number = MemberResp_FieldNumber_VerifyFlag,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(MemberResp__storage_, verifyFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "verifyInfo",
        .dataTypeSpecific.className = NULL,
        .number = MemberResp_FieldNumber_VerifyInfo,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(MemberResp__storage_, verifyInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = MemberResp_FieldNumber_Country,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(MemberResp__storage_, country),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberResp class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\021\001J\000\002L\000\003H\000\004c\006\000\005G\000\006C\000\tF\000\nGb\006\000\013M\000\014K\000\rH\000\016D\000"
        "\017I\000\020L\000\021J\000\022J\000\023G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelMemberReq

@implementation DelMemberReq

@dynamic hasMemberName, memberName;

typedef struct DelMemberReq__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinString_t *memberName;
} DelMemberReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = DelMemberReq_FieldNumber_MemberName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelMemberReq__storage_, memberName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelMemberReq class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelMemberReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelMemberResp

@implementation DelMemberResp

@dynamic hasMemberName, memberName;

typedef struct DelMemberResp__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinString_t *memberName;
} DelMemberResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = DelMemberResp_FieldNumber_MemberName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelMemberResp__storage_, memberName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelMemberResp class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelMemberResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisturbTimeSpan

@implementation DisturbTimeSpan

@dynamic hasBeginTime, beginTime;
@dynamic hasEndTime, endTime;

typedef struct DisturbTimeSpan__storage_ {
  uint32_t _has_storage_[1];
  uint32_t beginTime;
  uint32_t endTime;
} DisturbTimeSpan__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "beginTime",
        .dataTypeSpecific.className = NULL,
        .number = DisturbTimeSpan_FieldNumber_BeginTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisturbTimeSpan__storage_, beginTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = DisturbTimeSpan_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DisturbTimeSpan__storage_, endTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisturbTimeSpan class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisturbTimeSpan__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001I\000\002G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisturbSetting

@implementation DisturbSetting

@dynamic hasNightSetting, nightSetting;
@dynamic hasNightTime, nightTime;
@dynamic hasAllDaySetting, allDaySetting;
@dynamic hasAllDayTime, allDayTime;

typedef struct DisturbSetting__storage_ {
  uint32_t _has_storage_[1];
  uint32_t nightSetting;
  uint32_t allDaySetting;
  DisturbTimeSpan *nightTime;
  DisturbTimeSpan *allDayTime;
} DisturbSetting__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nightSetting",
        .dataTypeSpecific.className = NULL,
        .number = DisturbSetting_FieldNumber_NightSetting,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisturbSetting__storage_, nightSetting),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nightTime",
        .dataTypeSpecific.className = GPBStringifySymbol(DisturbTimeSpan),
        .number = DisturbSetting_FieldNumber_NightTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DisturbSetting__storage_, nightTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "allDaySetting",
        .dataTypeSpecific.className = NULL,
        .number = DisturbSetting_FieldNumber_AllDaySetting,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DisturbSetting__storage_, allDaySetting),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "allDayTime",
        .dataTypeSpecific.className = GPBStringifySymbol(DisturbTimeSpan),
        .number = DisturbSetting_FieldNumber_AllDayTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DisturbSetting__storage_, allDayTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisturbSetting class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisturbSetting__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001L\000\002I\000\003M\000\004J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GmailInfo

@implementation GmailInfo

@dynamic hasGmailAcct, gmailAcct;
@dynamic hasGmailSwitch, gmailSwitch;
@dynamic hasGmailErrCode, gmailErrCode;

typedef struct GmailInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t gmailSwitch;
  uint32_t gmailErrCode;
  NSString *gmailAcct;
} GmailInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gmailAcct",
        .dataTypeSpecific.className = NULL,
        .number = GmailInfo_FieldNumber_GmailAcct,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GmailInfo__storage_, gmailAcct),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gmailSwitch",
        .dataTypeSpecific.className = NULL,
        .number = GmailInfo_FieldNumber_GmailSwitch,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GmailInfo__storage_, gmailSwitch),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gmailErrCode",
        .dataTypeSpecific.className = NULL,
        .number = GmailInfo_FieldNumber_GmailErrCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GmailInfo__storage_, gmailErrCode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GmailInfo class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GmailInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001I\000\002K\000\003L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GmailList

@implementation GmailList

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct GmailList__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSMutableArray *listArray;
} GmailList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = GmailList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GmailList__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GmailInfo),
        .number = GmailList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GmailList__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GmailList class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GmailList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001E\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LinkedinContactItem

@implementation LinkedinContactItem

@dynamic hasLinkedinName, linkedinName;
@dynamic hasLinkedinMemberId, linkedinMemberId;
@dynamic hasLinkedinPublicURL, linkedinPublicURL;

typedef struct LinkedinContactItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *linkedinName;
  NSString *linkedinMemberId;
  NSString *linkedinPublicURL;
} LinkedinContactItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "linkedinName",
        .dataTypeSpecific.className = NULL,
        .number = LinkedinContactItem_FieldNumber_LinkedinName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LinkedinContactItem__storage_, linkedinName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linkedinMemberId",
        .dataTypeSpecific.className = NULL,
        .number = LinkedinContactItem_FieldNumber_LinkedinMemberId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LinkedinContactItem__storage_, linkedinMemberId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linkedinPublicURL",
        .dataTypeSpecific.className = NULL,
        .number = LinkedinContactItem_FieldNumber_LinkedinPublicURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LinkedinContactItem__storage_, linkedinPublicURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LinkedinContactItem class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LinkedinContactItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002OA\000\003O!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AdditionalContactList

@implementation AdditionalContactList

@dynamic hasLinkedinContactItem, linkedinContactItem;

typedef struct AdditionalContactList__storage_ {
  uint32_t _has_storage_[1];
  LinkedinContactItem *linkedinContactItem;
} AdditionalContactList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "linkedinContactItem",
        .dataTypeSpecific.className = GPBStringifySymbol(LinkedinContactItem),
        .number = AdditionalContactList_FieldNumber_LinkedinContactItem,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AdditionalContactList__storage_, linkedinContactItem),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AdditionalContactList class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AdditionalContactList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001S\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatRoomMemberInfo

@implementation ChatRoomMemberInfo

@dynamic hasUserName, userName;
@dynamic hasNickName, nickName;
@dynamic hasDisplayName, displayName;
@dynamic hasBigHeadImgURL, bigHeadImgURL;
@dynamic hasSmallHeadImgURL, smallHeadImgURL;
@dynamic hasChatroomMemberFlag, chatroomMemberFlag;
@dynamic hasInviterUserName, inviterUserName;

typedef struct ChatRoomMemberInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t chatroomMemberFlag;
  NSString *userName;
  NSString *nickName;
  NSString *displayName;
  NSString *bigHeadImgURL;
  NSString *smallHeadImgURL;
  NSString *inviterUserName;
} ChatRoomMemberInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_DisplayName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, displayName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bigHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_BigHeadImgURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, bigHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smallHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_SmallHeadImgURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, smallHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatroomMemberFlag",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_ChatroomMemberFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, chatroomMemberFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "inviterUserName",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberInfo_FieldNumber_InviterUserName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChatRoomMemberInfo__storage_, inviterUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatRoomMemberInfo class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatRoomMemberInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001H\000\002H\000\003K\000\004K!!\000\005M!!\000\006R\000\007O\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatRoomMemberData

@implementation ChatRoomMemberData

@dynamic hasMemberCount, memberCount;
@dynamic chatRoomMemberArray, chatRoomMemberArray_Count;
@dynamic hasInfoMask, infoMask;

typedef struct ChatRoomMemberData__storage_ {
  uint32_t _has_storage_[1];
  uint32_t memberCount;
  uint32_t infoMask;
  NSMutableArray *chatRoomMemberArray;
} ChatRoomMemberData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberCount",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberData_FieldNumber_MemberCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatRoomMemberData__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chatRoomMemberArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatRoomMemberInfo),
        .number = ChatRoomMemberData_FieldNumber_ChatRoomMemberArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChatRoomMemberData__storage_, chatRoomMemberArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "infoMask",
        .dataTypeSpecific.className = NULL,
        .number = ChatRoomMemberData_FieldNumber_InfoMask,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatRoomMemberData__storage_, infoMask),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatRoomMemberData class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatRoomMemberData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002\000ChatRoomMember\000\003H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PatternLockInfo

@implementation PatternLockInfo

@dynamic hasPatternVersion, patternVersion;
@dynamic hasSign, sign;
@dynamic hasLockStatus, lockStatus;

typedef struct PatternLockInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t patternVersion;
  uint32_t lockStatus;
  SKBuiltinBuffer_t *sign;
} PatternLockInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "patternVersion",
        .dataTypeSpecific.className = NULL,
        .number = PatternLockInfo_FieldNumber_PatternVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PatternLockInfo__storage_, patternVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = PatternLockInfo_FieldNumber_Sign,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PatternLockInfo__storage_, sign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lockStatus",
        .dataTypeSpecific.className = NULL,
        .number = PatternLockInfo_FieldNumber_LockStatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PatternLockInfo__storage_, lockStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PatternLockInfo class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PatternLockInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001N\000\002D\000\003J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModUserInfo

@implementation ModUserInfo

@dynamic hasBitFlag, bitFlag;
@dynamic hasUserName, userName;
@dynamic hasNickName, nickName;
@dynamic hasBindUin, bindUin;
@dynamic hasBindEmail, bindEmail;
@dynamic hasBindMobile, bindMobile;
@dynamic hasStatus, status;
@dynamic hasImgLen, imgLen;
@dynamic hasImgBuf, imgBuf;
@dynamic hasSex, sex;
@dynamic hasProvince, province;
@dynamic hasCity, city;
@dynamic hasSignature, signature;
@dynamic hasPersonalCard, personalCard;
@dynamic hasDisturbSetting, disturbSetting;
@dynamic hasPluginFlag, pluginFlag;
@dynamic hasVerifyFlag, verifyFlag;
@dynamic hasVerifyInfo, verifyInfo;
@dynamic hasPoint, point;
@dynamic hasExperience, experience;
@dynamic hasLevel, level;
@dynamic hasLevelLowExp, levelLowExp;
@dynamic hasLevelHighExp, levelHighExp;
@dynamic hasWeibo, weibo;
@dynamic hasPluginSwitch, pluginSwitch;
@dynamic hasGmailList, gmailList;
@dynamic hasAlias, alias;
@dynamic hasWeiboNickname, weiboNickname;
@dynamic hasWeiboFlag, weiboFlag;
@dynamic hasFaceBookFlag, faceBookFlag;
@dynamic hasFbuserId, fbuserId;
@dynamic hasFbuserName, fbuserName;
@dynamic hasAlbumStyle, albumStyle;
@dynamic hasAlbumFlag, albumFlag;
@dynamic hasAlbumBgimgId, albumBgimgId;
@dynamic hasTxnewsCategory, txnewsCategory;
@dynamic hasFbtoken, fbtoken;
@dynamic hasCountry, country;

typedef struct ModUserInfo__storage_ {
  uint32_t _has_storage_[2];
  uint32_t bitFlag;
  uint32_t bindUin;
  uint32_t status;
  uint32_t imgLen;
  int32_t sex;
  uint32_t personalCard;
  uint32_t pluginFlag;
  uint32_t verifyFlag;
  int32_t point;
  int32_t experience;
  int32_t level;
  int32_t levelLowExp;
  int32_t levelHighExp;
  uint32_t pluginSwitch;
  uint32_t weiboFlag;
  uint32_t faceBookFlag;
  int32_t albumStyle;
  int32_t albumFlag;
  uint32_t txnewsCategory;
  SKBuiltinString_t *userName;
  SKBuiltinString_t *nickName;
  SKBuiltinString_t *bindEmail;
  SKBuiltinString_t *bindMobile;
  NSData *imgBuf;
  NSString *province;
  NSString *city;
  NSString *signature;
  DisturbSetting *disturbSetting;
  NSString *verifyInfo;
  NSString *weibo;
  GmailList *gmailList;
  NSString *alias;
  NSString *weiboNickname;
  NSString *fbuserName;
  NSString *albumBgimgId;
  NSString *fbtoken;
  NSString *country;
  uint64_t fbuserId;
} ModUserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bitFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_BitFlag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, bitFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModUserInfo_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModUserInfo_FieldNumber_NickName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bindUin",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_BindUin,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, bindUin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bindEmail",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModUserInfo_FieldNumber_BindEmail,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, bindEmail),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bindMobile",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModUserInfo_FieldNumber_BindMobile,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, bindMobile),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_Status,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgLen",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_ImgLen,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, imgLen),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgBuf",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_ImgBuf,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, imgBuf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_Sex,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "province",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_Province,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, province),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "city",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_City,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, city),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_Signature,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "personalCard",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_PersonalCard,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, personalCard),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "disturbSetting",
        .dataTypeSpecific.className = GPBStringifySymbol(DisturbSetting),
        .number = ModUserInfo_FieldNumber_DisturbSetting,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, disturbSetting),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pluginFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_PluginFlag,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, pluginFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "verifyFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_VerifyFlag,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, verifyFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "verifyInfo",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_VerifyInfo,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, verifyInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "point",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_Point,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, point),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "experience",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_Experience,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, experience),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_Level,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, level),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "levelLowExp",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_LevelLowExp,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, levelLowExp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "levelHighExp",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_LevelHighExp,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, levelHighExp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "weibo",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_Weibo,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, weibo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pluginSwitch",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_PluginSwitch,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, pluginSwitch),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "gmailList",
        .dataTypeSpecific.className = GPBStringifySymbol(GmailList),
        .number = ModUserInfo_FieldNumber_GmailList,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, gmailList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_Alias,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, alias),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weiboNickname",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_WeiboNickname,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, weiboNickname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weiboFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_WeiboFlag,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, weiboFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "faceBookFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_FaceBookFlag,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, faceBookFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fbuserId",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_FbuserId,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, fbuserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fbuserName",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_FbuserName,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, fbuserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "albumStyle",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_AlbumStyle,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, albumStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "albumFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_AlbumFlag,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, albumFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "albumBgimgId",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_AlbumBgimgId,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, albumBgimgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "txnewsCategory",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_TxnewsCategory,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, txnewsCategory),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fbtoken",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_Fbtoken,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, fbtoken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = ModUserInfo_FieldNumber_Country,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(ModUserInfo__storage_, country),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModUserInfo class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModUserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "&\001G\000\002H\000\003H\000\004G\000\005I\000\006J\000\007F\000\010F\000\tF\000\nC\000\013H\000\014D\000\rI\000"
        "\016L\000\017N\000\020J\000\021J\000\022J\000\023E\000\024J\000\025E\000\026K\000\027L\000\030E\000\031L\000\032I\000\033"
        "E\000\034M\000\035I\000\036L\000\037c\004A\000 c\007\000!J\000\"I\000#Fb\003A\000$c\013\000%c\004\000"
        "&G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfoExt

@implementation UserInfoExt

@dynamic hasSnsUserInfo, snsUserInfo;
@dynamic hasMyBrandList, myBrandList;
@dynamic hasMsgPushSound, msgPushSound;
@dynamic hasVoipPushSound, voipPushSound;
@dynamic hasBigChatRoomSize, bigChatRoomSize;
@dynamic hasBigChatRoomQuota, bigChatRoomQuota;
@dynamic hasBigChatRoomInvite, bigChatRoomInvite;
@dynamic hasSafeMobile, safeMobile;
@dynamic hasBigHeadImgURL, bigHeadImgURL;
@dynamic hasSmallHeadImgURL, smallHeadImgURL;
@dynamic hasMainAcctType, mainAcctType;
@dynamic hasExtXml, extXml;
@dynamic hasSafeDeviceList, safeDeviceList;
@dynamic hasSafeDevice, safeDevice;
@dynamic hasGrayscaleFlag, grayscaleFlag;
@dynamic hasGoogleContactName, googleContactName;
@dynamic hasIdcardNum, idcardNum;
@dynamic hasRealName, realName;
@dynamic hasRegCountry, regCountry;
@dynamic hasBbppid, bbppid;
@dynamic hasBbpin, bbpin;
@dynamic hasBbmnickName, bbmnickName;
@dynamic hasLinkedinContactItem, linkedinContactItem;
@dynamic hasKfinfo, kfinfo;
@dynamic hasPatternLockInfo, patternLockInfo;
@dynamic hasSecurityDeviceId, securityDeviceId;
@dynamic hasPayWalletType, payWalletType;

typedef struct UserInfoExt__storage_ {
  uint32_t _has_storage_[1];
  uint32_t bigChatRoomSize;
  uint32_t bigChatRoomQuota;
  uint32_t bigChatRoomInvite;
  uint32_t mainAcctType;
  uint32_t safeDevice;
  uint32_t grayscaleFlag;
  uint32_t payWalletType;
  SnsUserInfo *snsUserInfo;
  NSString *myBrandList;
  NSString *msgPushSound;
  NSString *voipPushSound;
  NSString *safeMobile;
  NSString *bigHeadImgURL;
  NSString *smallHeadImgURL;
  SKBuiltinString_t *extXml;
  SafeDeviceList *safeDeviceList;
  NSString *googleContactName;
  NSString *idcardNum;
  NSString *realName;
  NSString *regCountry;
  NSString *bbppid;
  NSString *bbpin;
  NSString *bbmnickName;
  LinkedinContactItem *linkedinContactItem;
  NSString *kfinfo;
  PatternLockInfo *patternLockInfo;
  NSString *securityDeviceId;
} UserInfoExt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "snsUserInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SnsUserInfo),
        .number = UserInfoExt_FieldNumber_SnsUserInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, snsUserInfo),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "myBrandList",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_MyBrandList,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, myBrandList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgPushSound",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_MsgPushSound,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, msgPushSound),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "voipPushSound",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_VoipPushSound,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, voipPushSound),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bigChatRoomSize",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_BigChatRoomSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, bigChatRoomSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bigChatRoomQuota",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_BigChatRoomQuota,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, bigChatRoomQuota),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bigChatRoomInvite",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_BigChatRoomInvite,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, bigChatRoomInvite),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "safeMobile",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_SafeMobile,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, safeMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bigHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_BigHeadImgURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, bigHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smallHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_SmallHeadImgURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, smallHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mainAcctType",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_MainAcctType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, mainAcctType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extXml",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = UserInfoExt_FieldNumber_ExtXml,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, extXml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "safeDeviceList",
        .dataTypeSpecific.className = GPBStringifySymbol(SafeDeviceList),
        .number = UserInfoExt_FieldNumber_SafeDeviceList,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, safeDeviceList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "safeDevice",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_SafeDevice,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, safeDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "grayscaleFlag",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_GrayscaleFlag,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, grayscaleFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "googleContactName",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_GoogleContactName,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, googleContactName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "idcardNum",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_IdcardNum,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, idcardNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realName",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_RealName,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, realName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "regCountry",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_RegCountry,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, regCountry),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bbppid",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_Bbppid,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, bbppid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bbpin",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_Bbpin,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, bbpin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bbmnickName",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_BbmnickName,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, bbmnickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linkedinContactItem",
        .dataTypeSpecific.className = GPBStringifySymbol(LinkedinContactItem),
        .number = UserInfoExt_FieldNumber_LinkedinContactItem,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, linkedinContactItem),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "kfinfo",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_Kfinfo,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, kfinfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "patternLockInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PatternLockInfo),
        .number = UserInfoExt_FieldNumber_PatternLockInfo,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, patternLockInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "securityDeviceId",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_SecurityDeviceId,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, securityDeviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payWalletType",
        .dataTypeSpecific.className = NULL,
        .number = UserInfoExt_FieldNumber_PayWalletType,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(UserInfoExt__storage_, payWalletType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfoExt class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfoExt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\033\001K\000\002K\000\003L\000\004M\000\005O\000\006P\000\007Q\000\010J\000\tK!!\000\nM!!\000\013L\000\014F"
        "\000\rN\000\016J\000\017M\000\020Q\000\021c\006\000\022H\000\023J\000\024f\000\025e\000\026d\007\000\027S\000\030c\003\000"
        "\031O\000\032P\000\033M\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PhoneNumItem

@implementation PhoneNumItem

@dynamic hasPhoneNum, phoneNum;

typedef struct PhoneNumItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *phoneNum;
} PhoneNumItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "phoneNum",
        .dataTypeSpecific.className = NULL,
        .number = PhoneNumItem_FieldNumber_PhoneNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PhoneNumItem__storage_, phoneNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PhoneNumItem class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PhoneNumItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PhoneNumListInfo

@implementation PhoneNumListInfo

@dynamic hasCount, count;
@dynamic phoneNumListArray, phoneNumListArray_Count;

typedef struct PhoneNumListInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSMutableArray *phoneNumListArray;
} PhoneNumListInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PhoneNumListInfo_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PhoneNumListInfo__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "phoneNumListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PhoneNumItem),
        .number = PhoneNumListInfo_FieldNumber_PhoneNumListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PhoneNumListInfo__storage_, phoneNumListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PhoneNumListInfo class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PhoneNumListInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000phoneNumList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModContact

@implementation ModContact

@dynamic hasUserName, userName;
@dynamic hasNickName, nickName;
@dynamic hasPyinitial, pyinitial;
@dynamic hasQuanPin, quanPin;
@dynamic hasSex, sex;
@dynamic hasImgBuf, imgBuf;
@dynamic hasBitMask, bitMask;
@dynamic hasBitVal, bitVal;
@dynamic hasImgFlag, imgFlag;
@dynamic hasRemark, remark;
@dynamic hasRemarkPyinitial, remarkPyinitial;
@dynamic hasRemarkQuanPin, remarkQuanPin;
@dynamic hasContactType, contactType;
@dynamic hasRoomInfoCount, roomInfoCount;
@dynamic roomInfoListArray, roomInfoListArray_Count;
@dynamic hasDomainList, domainList;
@dynamic hasChatRoomNotify, chatRoomNotify;
@dynamic hasAddContactScene, addContactScene;
@dynamic hasProvince, province;
@dynamic hasCity, city;
@dynamic hasSignature, signature;
@dynamic hasPersonalCard, personalCard;
@dynamic hasHasWeiXinHdHeadImg, hasWeiXinHdHeadImg;
@dynamic hasVerifyFlag, verifyFlag;
@dynamic hasVerifyInfo, verifyInfo;
@dynamic hasLevel, level;
@dynamic hasSource, source;
@dynamic hasWeibo, weibo;
@dynamic hasVerifyContent, verifyContent;
@dynamic hasAlias, alias;
@dynamic hasChatRoomOwner, chatRoomOwner;
@dynamic hasWeiboNickname, weiboNickname;
@dynamic hasWeiboFlag, weiboFlag;
@dynamic hasAlbumStyle, albumStyle;
@dynamic hasAlbumFlag, albumFlag;
@dynamic hasAlbumBgimgId, albumBgimgId;
@dynamic hasSnsUserInfo, snsUserInfo;
@dynamic hasCountry, country;
@dynamic hasBigHeadImgURL, bigHeadImgURL;
@dynamic hasSmallHeadImgURL, smallHeadImgURL;
@dynamic hasMyBrandList, myBrandList;
@dynamic hasCustomizedInfo, customizedInfo;
@dynamic hasChatRoomData, chatRoomData;
@dynamic hasHeadImgMd5, headImgMd5;
@dynamic hasEncryptUserName, encryptUserName;
@dynamic hasIdcardNum, idcardNum;
@dynamic hasRealName, realName;
@dynamic hasMobileHash, mobileHash;
@dynamic hasMobileFullHash, mobileFullHash;
@dynamic hasAdditionalContactList, additionalContactList;
@dynamic hasChatroomVersion, chatroomVersion;
@dynamic hasExtInfo, extInfo;
@dynamic hasChatroomMaxCount, chatroomMaxCount;
@dynamic hasChatroomType, chatroomType;
@dynamic hasNewChatroomData, newChatroomData;
@dynamic hasDeleteFlag, deleteFlag;
@dynamic hasDescription_p, description_p;
@dynamic hasCardImgURL, cardImgURL;
@dynamic hasLabelIdlist, labelIdlist;
@dynamic hasPhoneNumListInfo, phoneNumListInfo;
@dynamic hasWeiDianInfo, weiDianInfo;
@dynamic hasChatroomInfoVersion, chatroomInfoVersion;
@dynamic hasDeleteContactScene, deleteContactScene;
@dynamic hasChatroomStatus, chatroomStatus;
@dynamic hasExtFlag, extFlag;

typedef struct ModContact__storage_ {
  uint32_t _has_storage_[2];
  int32_t sex;
  uint32_t bitMask;
  uint32_t bitVal;
  uint32_t imgFlag;
  uint32_t contactType;
  uint32_t roomInfoCount;
  uint32_t chatRoomNotify;
  uint32_t addContactScene;
  uint32_t personalCard;
  uint32_t hasWeiXinHdHeadImg;
  uint32_t verifyFlag;
  int32_t level;
  uint32_t source;
  uint32_t weiboFlag;
  int32_t albumStyle;
  int32_t albumFlag;
  uint32_t chatroomVersion;
  uint32_t chatroomMaxCount;
  uint32_t chatroomType;
  int32_t deleteFlag;
  uint32_t chatroomInfoVersion;
  uint32_t deleteContactScene;
  uint32_t chatroomStatus;
  uint32_t extFlag;
  SKBuiltinString_t *userName;
  SKBuiltinString_t *nickName;
  SKBuiltinString_t *pyinitial;
  SKBuiltinString_t *quanPin;
  SKBuiltinBuffer_t *imgBuf;
  SKBuiltinString_t *remark;
  SKBuiltinString_t *remarkPyinitial;
  SKBuiltinString_t *remarkQuanPin;
  NSMutableArray *roomInfoListArray;
  SKBuiltinString_t *domainList;
  NSString *province;
  NSString *city;
  NSString *signature;
  NSString *verifyInfo;
  NSString *weibo;
  NSString *verifyContent;
  NSString *alias;
  NSString *chatRoomOwner;
  NSString *weiboNickname;
  NSString *albumBgimgId;
  SnsUserInfo *snsUserInfo;
  NSString *country;
  NSString *bigHeadImgURL;
  NSString *smallHeadImgURL;
  NSString *myBrandList;
  CustomizedInfo *customizedInfo;
  NSString *chatRoomData;
  NSString *headImgMd5;
  NSString *encryptUserName;
  NSString *idcardNum;
  NSString *realName;
  NSString *mobileHash;
  NSString *mobileFullHash;
  AdditionalContactList *additionalContactList;
  NSString *extInfo;
  ChatRoomMemberData *newChatroomData;
  NSString *description_p;
  NSString *cardImgURL;
  NSString *labelIdlist;
  PhoneNumListInfo *phoneNumListInfo;
  NSString *weiDianInfo;
} ModContact__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModContact__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModContact__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pyinitial",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_Pyinitial,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModContact__storage_, pyinitial),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "quanPin",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_QuanPin,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModContact__storage_, quanPin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ModContact__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imgBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ModContact_FieldNumber_ImgBuf,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ModContact__storage_, imgBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bitMask",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_BitMask,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ModContact__storage_, bitMask),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bitVal",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_BitVal,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ModContact__storage_, bitVal),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ImgFlag,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ModContact__storage_, imgFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_Remark,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ModContact__storage_, remark),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remarkPyinitial",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_RemarkPyinitial,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ModContact__storage_, remarkPyinitial),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remarkQuanPin",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_RemarkQuanPin,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ModContact__storage_, remarkQuanPin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contactType",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ContactType,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ModContact__storage_, contactType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "roomInfoCount",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_RoomInfoCount,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ModContact__storage_, roomInfoCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "roomInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RoomInfo),
        .number = ModContact_FieldNumber_RoomInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ModContact__storage_, roomInfoListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "domainList",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModContact_FieldNumber_DomainList,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ModContact__storage_, domainList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatRoomNotify",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatRoomNotify,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatRoomNotify),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "addContactScene",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_AddContactScene,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ModContact__storage_, addContactScene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "province",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Province,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ModContact__storage_, province),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "city",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_City,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ModContact__storage_, city),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Signature,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ModContact__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "personalCard",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_PersonalCard,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ModContact__storage_, personalCard),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hasWeiXinHdHeadImg",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_HasWeiXinHdHeadImg,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ModContact__storage_, hasWeiXinHdHeadImg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "verifyFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_VerifyFlag,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(ModContact__storage_, verifyFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "verifyInfo",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_VerifyInfo,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(ModContact__storage_, verifyInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "level",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Level,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(ModContact__storage_, level),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Source,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(ModContact__storage_, source),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "weibo",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Weibo,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(ModContact__storage_, weibo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyContent",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_VerifyContent,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(ModContact__storage_, verifyContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Alias,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(ModContact__storage_, alias),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatRoomOwner",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatRoomOwner,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatRoomOwner),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weiboNickname",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_WeiboNickname,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(ModContact__storage_, weiboNickname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weiboFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_WeiboFlag,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(ModContact__storage_, weiboFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "albumStyle",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_AlbumStyle,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(ModContact__storage_, albumStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "albumFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_AlbumFlag,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(ModContact__storage_, albumFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "albumBgimgId",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_AlbumBgimgId,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(ModContact__storage_, albumBgimgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "snsUserInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SnsUserInfo),
        .number = ModContact_FieldNumber_SnsUserInfo,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(ModContact__storage_, snsUserInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Country,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(ModContact__storage_, country),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bigHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_BigHeadImgURL,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(ModContact__storage_, bigHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smallHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_SmallHeadImgURL,
        .hasIndex = 38,
        .offset = (uint32_t)offsetof(ModContact__storage_, smallHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "myBrandList",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_MyBrandList,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(ModContact__storage_, myBrandList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "customizedInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(CustomizedInfo),
        .number = ModContact_FieldNumber_CustomizedInfo,
        .hasIndex = 40,
        .offset = (uint32_t)offsetof(ModContact__storage_, customizedInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatRoomData",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatRoomData,
        .hasIndex = 41,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatRoomData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headImgMd5",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_HeadImgMd5,
        .hasIndex = 42,
        .offset = (uint32_t)offsetof(ModContact__storage_, headImgMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encryptUserName",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_EncryptUserName,
        .hasIndex = 43,
        .offset = (uint32_t)offsetof(ModContact__storage_, encryptUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "idcardNum",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_IdcardNum,
        .hasIndex = 44,
        .offset = (uint32_t)offsetof(ModContact__storage_, idcardNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realName",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_RealName,
        .hasIndex = 45,
        .offset = (uint32_t)offsetof(ModContact__storage_, realName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobileHash",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_MobileHash,
        .hasIndex = 46,
        .offset = (uint32_t)offsetof(ModContact__storage_, mobileHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobileFullHash",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_MobileFullHash,
        .hasIndex = 47,
        .offset = (uint32_t)offsetof(ModContact__storage_, mobileFullHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "additionalContactList",
        .dataTypeSpecific.className = GPBStringifySymbol(AdditionalContactList),
        .number = ModContact_FieldNumber_AdditionalContactList,
        .hasIndex = 48,
        .offset = (uint32_t)offsetof(ModContact__storage_, additionalContactList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatroomVersion",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatroomVersion,
        .hasIndex = 49,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatroomVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extInfo",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ExtInfo,
        .hasIndex = 50,
        .offset = (uint32_t)offsetof(ModContact__storage_, extInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatroomMaxCount",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatroomMaxCount,
        .hasIndex = 51,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatroomMaxCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chatroomType",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatroomType,
        .hasIndex = 52,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatroomType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "newChatroomData",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatRoomMemberData),
        .number = ModContact_FieldNumber_NewChatroomData,
        .hasIndex = 53,
        .offset = (uint32_t)offsetof(ModContact__storage_, newChatroomData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deleteFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_DeleteFlag,
        .hasIndex = 54,
        .offset = (uint32_t)offsetof(ModContact__storage_, deleteFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_Description_p,
        .hasIndex = 55,
        .offset = (uint32_t)offsetof(ModContact__storage_, description_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cardImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_CardImgURL,
        .hasIndex = 56,
        .offset = (uint32_t)offsetof(ModContact__storage_, cardImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "labelIdlist",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_LabelIdlist,
        .hasIndex = 57,
        .offset = (uint32_t)offsetof(ModContact__storage_, labelIdlist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "phoneNumListInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(PhoneNumListInfo),
        .number = ModContact_FieldNumber_PhoneNumListInfo,
        .hasIndex = 58,
        .offset = (uint32_t)offsetof(ModContact__storage_, phoneNumListInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "weiDianInfo",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_WeiDianInfo,
        .hasIndex = 59,
        .offset = (uint32_t)offsetof(ModContact__storage_, weiDianInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatroomInfoVersion",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatroomInfoVersion,
        .hasIndex = 60,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatroomInfoVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deleteContactScene",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_DeleteContactScene,
        .hasIndex = 61,
        .offset = (uint32_t)offsetof(ModContact__storage_, deleteContactScene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chatroomStatus",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ChatroomStatus,
        .hasIndex = 62,
        .offset = (uint32_t)offsetof(ModContact__storage_, chatroomStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModContact_FieldNumber_ExtFlag,
        .hasIndex = 63,
        .offset = (uint32_t)offsetof(ModContact__storage_, extFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModContact class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModContact__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "A\001H\000\002H\000\003c\006\000\004G\000\005C\000\006F\000\007G\000\010F\000\tG\000\nF\000\013Gb\006\000\014M\000"
        "\rK\000\016M\000\017\000RoomInfoList\000\020J\000\021N\000\022O\000\023H\000\024D\000\025I\000\026"
        "L\000\027R\000\030J\000\031J\000\032E\000\033F\000\034E\000\035M\000\036E\000\037M\000 M\000!I\000\"J\000#I"
        "\000$Fb\003A\000%K\000&G\000\'K!!\000(M!!\000)K\000*N\000+L\000,J\000-O\000.c"
        "\006\000/H\0000J\0001N\0002U\0005O\0006G\0007P\0008L\0009O\000:J\000;\000Descri"
        "ption\000<H!!\000=Fb\003\000>\020\000\?\013\000@\023\000A\022\000B\016\000C\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HardDevice

@implementation HardDevice

@dynamic hasDeviceType, deviceType;
@dynamic hasDeviceId, deviceId;

typedef struct HardDevice__storage_ {
  uint32_t _has_storage_[1];
  NSString *deviceType;
  NSString *deviceId;
} HardDevice__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = HardDevice_FieldNumber_DeviceType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HardDevice__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = HardDevice_FieldNumber_DeviceId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HardDevice__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HardDevice class]
                                     rootClass:[MmbaseRoot class]
                                          file:MmbaseRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HardDevice__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002GA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
