// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmtalk.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mmtalk.pbobjc.h"
#import "Mmbuiltintype.pbobjc.h"
#import "Mmbase.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmtalkRoot

@implementation MmtalkRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MmtalkRoot_FileDescriptor

static GPBFileDescriptor *MmtalkRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"micromsg"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - TalkRoomMember

@implementation TalkRoomMember

@dynamic hasMemberId, memberId;
@dynamic hasUserName, userName;

typedef struct TalkRoomMember__storage_ {
  uint32_t _has_storage_[1];
  int32_t memberId;
  NSString *userName;
} TalkRoomMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "memberId",
        .dataTypeSpecific.className = NULL,
        .number = TalkRoomMember_FieldNumber_MemberId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkRoomMember__storage_, memberId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = TalkRoomMember_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TalkRoomMember__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkRoomMember class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkRoomMember__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001GA\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TalkRelayAddr

@implementation TalkRelayAddr

@dynamic hasIp, ip;
@dynamic hasPort, port;

typedef struct TalkRelayAddr__storage_ {
  uint32_t _has_storage_[1];
  uint32_t ip;
  uint32_t port;
} TalkRelayAddr__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = TalkRelayAddr_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkRelayAddr__storage_, ip),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = TalkRelayAddr_FieldNumber_Port,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TalkRelayAddr__storage_, port),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkRelayAddr class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkRelayAddr__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001B\000\002D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnterTalkRoomReq

@implementation EnterTalkRoomReq

@dynamic hasBaseRequest, baseRequest;
@dynamic hasToUsername, toUsername;
@dynamic hasScene, scene;

typedef struct EnterTalkRoomReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t scene;
  BaseRequest *baseRequest;
  NSString *toUsername;
} EnterTalkRoomReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = EnterTalkRoomReq_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnterTalkRoomReq__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toUsername",
        .dataTypeSpecific.className = NULL,
        .number = EnterTalkRoomReq_FieldNumber_ToUsername,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EnterTalkRoomReq__storage_, toUsername),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = EnterTalkRoomReq_FieldNumber_Scene,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EnterTalkRoomReq__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnterTalkRoomReq class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnterTalkRoomReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002J\000\003E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnterTalkRoomResp

@implementation EnterTalkRoomResp

@dynamic hasBaseResponse, baseResponse;
@dynamic hasRoomId, roomId;
@dynamic hasRoomKey, roomKey;
@dynamic hasMicSeq, micSeq;
@dynamic hasMemberNum, memberNum;
@dynamic memberListArray, memberListArray_Count;
@dynamic hasMyRoomMemberId, myRoomMemberId;
@dynamic hasAddrCount, addrCount;
@dynamic addrListArray, addrListArray_Count;

typedef struct EnterTalkRoomResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t roomId;
  int32_t micSeq;
  int32_t memberNum;
  int32_t myRoomMemberId;
  int32_t addrCount;
  BaseResponse *baseResponse;
  NSMutableArray *memberListArray;
  NSMutableArray *addrListArray;
  int64_t roomKey;
} EnterTalkRoomResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = EnterTalkRoomResp_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnterTalkRoomResp__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = EnterTalkRoomResp_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EnterTalkRoomResp__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roomKey",
        .dataTypeSpecific.className = NULL,
        .number = EnterTalkRoomResp_FieldNumber_RoomKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EnterTalkRoomResp__storage_, roomKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "micSeq",
        .dataTypeSpecific.className = NULL,
        .number = EnterTalkRoomResp_FieldNumber_MicSeq,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EnterTalkRoomResp__storage_, micSeq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "memberNum",
        .dataTypeSpecific.className = NULL,
        .number = EnterTalkRoomResp_FieldNumber_MemberNum,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EnterTalkRoomResp__storage_, memberNum),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "memberListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TalkRoomMember),
        .number = EnterTalkRoomResp_FieldNumber_MemberListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EnterTalkRoomResp__storage_, memberListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "myRoomMemberId",
        .dataTypeSpecific.className = NULL,
        .number = EnterTalkRoomResp_FieldNumber_MyRoomMemberId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EnterTalkRoomResp__storage_, myRoomMemberId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "addrCount",
        .dataTypeSpecific.className = NULL,
        .number = EnterTalkRoomResp_FieldNumber_AddrCount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EnterTalkRoomResp__storage_, addrCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "addrListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TalkRelayAddr),
        .number = EnterTalkRoomResp_FieldNumber_AddrListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EnterTalkRoomResp__storage_, addrListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnterTalkRoomResp class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnterTalkRoomResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001L\000\002F\000\003G\000\004F\000\005I\000\006\000MemberList\000\007N\000\010I\000\t\000Add"
        "rList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExitTalkRoomReq

@implementation ExitTalkRoomReq

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRoomId, roomId;
@dynamic hasRoomKey, roomKey;
@dynamic hasToUsername, toUsername;
@dynamic hasScene, scene;

typedef struct ExitTalkRoomReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t roomId;
  uint32_t scene;
  BaseRequest *baseRequest;
  NSString *toUsername;
  int64_t roomKey;
} ExitTalkRoomReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ExitTalkRoomReq_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExitTalkRoomReq__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = ExitTalkRoomReq_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExitTalkRoomReq__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roomKey",
        .dataTypeSpecific.className = NULL,
        .number = ExitTalkRoomReq_FieldNumber_RoomKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExitTalkRoomReq__storage_, roomKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "toUsername",
        .dataTypeSpecific.className = NULL,
        .number = ExitTalkRoomReq_FieldNumber_ToUsername,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ExitTalkRoomReq__storage_, toUsername),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = ExitTalkRoomReq_FieldNumber_Scene,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ExitTalkRoomReq__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExitTalkRoomReq class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExitTalkRoomReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001K\000\002F\000\003G\000\004J\000\005E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExitTalkRoomResp

@implementation ExitTalkRoomResp

@dynamic hasBaseResponse, baseResponse;

typedef struct ExitTalkRoomResp__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} ExitTalkRoomResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ExitTalkRoomResp_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExitTalkRoomResp__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExitTalkRoomResp class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExitTalkRoomResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TalkMicActionReq

@implementation TalkMicActionReq

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRoomId, roomId;
@dynamic hasRoomKey, roomKey;
@dynamic hasActionType, actionType;
@dynamic hasUpdateTime, updateTime;
@dynamic hasScene, scene;

typedef struct TalkMicActionReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t roomId;
  uint32_t actionType;
  uint32_t updateTime;
  uint32_t scene;
  BaseRequest *baseRequest;
  int64_t roomKey;
} TalkMicActionReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = TalkMicActionReq_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkMicActionReq__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = TalkMicActionReq_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TalkMicActionReq__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roomKey",
        .dataTypeSpecific.className = NULL,
        .number = TalkMicActionReq_FieldNumber_RoomKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TalkMicActionReq__storage_, roomKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "actionType",
        .dataTypeSpecific.className = NULL,
        .number = TalkMicActionReq_FieldNumber_ActionType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TalkMicActionReq__storage_, actionType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "updateTime",
        .dataTypeSpecific.className = NULL,
        .number = TalkMicActionReq_FieldNumber_UpdateTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TalkMicActionReq__storage_, updateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = TalkMicActionReq_FieldNumber_Scene,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TalkMicActionReq__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkMicActionReq class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkMicActionReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001K\000\002F\000\003G\000\004J\000\005J\000\006E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TalkMicActionResp

@implementation TalkMicActionResp

@dynamic hasBaseResponse, baseResponse;
@dynamic hasMicSeq, micSeq;
@dynamic hasChannelId, channelId;

typedef struct TalkMicActionResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t micSeq;
  uint32_t channelId;
  BaseResponse *baseResponse;
} TalkMicActionResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = TalkMicActionResp_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkMicActionResp__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "micSeq",
        .dataTypeSpecific.className = NULL,
        .number = TalkMicActionResp_FieldNumber_MicSeq,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TalkMicActionResp__storage_, micSeq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "channelId",
        .dataTypeSpecific.className = NULL,
        .number = TalkMicActionResp_FieldNumber_ChannelId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TalkMicActionResp__storage_, channelId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkMicActionResp class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkMicActionResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002F\000\003I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TalkNoopReq

@implementation TalkNoopReq

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRoomId, roomId;
@dynamic hasRoomKey, roomKey;
@dynamic hasUpdateTime, updateTime;
@dynamic hasScene, scene;

typedef struct TalkNoopReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t roomId;
  uint32_t updateTime;
  uint32_t scene;
  BaseRequest *baseRequest;
  int64_t roomKey;
} TalkNoopReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = TalkNoopReq_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkNoopReq__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = TalkNoopReq_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TalkNoopReq__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roomKey",
        .dataTypeSpecific.className = NULL,
        .number = TalkNoopReq_FieldNumber_RoomKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TalkNoopReq__storage_, roomKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "updateTime",
        .dataTypeSpecific.className = NULL,
        .number = TalkNoopReq_FieldNumber_UpdateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TalkNoopReq__storage_, updateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = TalkNoopReq_FieldNumber_Scene,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TalkNoopReq__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkNoopReq class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkNoopReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001K\000\002F\000\003G\000\004J\000\005E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TalkNoopResp

@implementation TalkNoopResp

@dynamic hasBaseResponse, baseResponse;

typedef struct TalkNoopResp__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} TalkNoopResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = TalkNoopResp_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkNoopResp__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkNoopResp class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkNoopResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTalkRoomMemberReq

@implementation GetTalkRoomMemberReq

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRoomId, roomId;
@dynamic hasRoomKey, roomKey;
@dynamic hasScene, scene;

typedef struct GetTalkRoomMemberReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t roomId;
  uint32_t scene;
  BaseRequest *baseRequest;
  int64_t roomKey;
} GetTalkRoomMemberReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetTalkRoomMemberReq_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTalkRoomMemberReq__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = GetTalkRoomMemberReq_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetTalkRoomMemberReq__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roomKey",
        .dataTypeSpecific.className = NULL,
        .number = GetTalkRoomMemberReq_FieldNumber_RoomKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetTalkRoomMemberReq__storage_, roomKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = GetTalkRoomMemberReq_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetTalkRoomMemberReq__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTalkRoomMemberReq class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTalkRoomMemberReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002F\000\003G\000\004E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTalkRoomMemberResp

@implementation GetTalkRoomMemberResp

@dynamic hasBaseResponse, baseResponse;
@dynamic hasMicSeq, micSeq;
@dynamic hasMemberNum, memberNum;
@dynamic memberListArray, memberListArray_Count;

typedef struct GetTalkRoomMemberResp__storage_ {
  uint32_t _has_storage_[1];
  int32_t micSeq;
  int32_t memberNum;
  BaseResponse *baseResponse;
  NSMutableArray *memberListArray;
} GetTalkRoomMemberResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetTalkRoomMemberResp_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTalkRoomMemberResp__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "micSeq",
        .dataTypeSpecific.className = NULL,
        .number = GetTalkRoomMemberResp_FieldNumber_MicSeq,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetTalkRoomMemberResp__storage_, micSeq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "memberNum",
        .dataTypeSpecific.className = NULL,
        .number = GetTalkRoomMemberResp_FieldNumber_MemberNum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetTalkRoomMemberResp__storage_, memberNum),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "memberListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TalkRoomMember),
        .number = GetTalkRoomMemberResp_FieldNumber_MemberListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetTalkRoomMemberResp__storage_, memberListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTalkRoomMemberResp class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTalkRoomMemberResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001L\000\002F\000\003I\000\004\000MemberList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TalkInviteReq

@implementation TalkInviteReq

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRoomId, roomId;
@dynamic hasRoomKey, roomKey;
@dynamic hasScene, scene;

typedef struct TalkInviteReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t roomId;
  uint32_t scene;
  BaseRequest *baseRequest;
  int64_t roomKey;
} TalkInviteReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = TalkInviteReq_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkInviteReq__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = TalkInviteReq_FieldNumber_RoomId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TalkInviteReq__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roomKey",
        .dataTypeSpecific.className = NULL,
        .number = TalkInviteReq_FieldNumber_RoomKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TalkInviteReq__storage_, roomKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = TalkInviteReq_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TalkInviteReq__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkInviteReq class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkInviteReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002F\000\003G\000\004E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TalkInviteResp

@implementation TalkInviteResp

@dynamic hasBaseResponse, baseResponse;

typedef struct TalkInviteResp__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} TalkInviteResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = TalkInviteResp_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkInviteResp__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkInviteResp class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkInviteResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TalkStatReportData

@implementation TalkStatReportData

@dynamic hasLogId, logId;
@dynamic hasStatReport, statReport;

typedef struct TalkStatReportData__storage_ {
  uint32_t _has_storage_[1];
  int32_t logId;
  SKBuiltinString_t *statReport;
} TalkStatReportData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "logId",
        .dataTypeSpecific.className = NULL,
        .number = TalkStatReportData_FieldNumber_LogId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkStatReportData__storage_, logId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "statReport",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = TalkStatReportData_FieldNumber_StatReport,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TalkStatReportData__storage_, statReport),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkStatReportData class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkStatReportData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001DA\000\002J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TalkStatReportReq

@implementation TalkStatReportReq

@dynamic hasBaseRequest, baseRequest;
@dynamic hasDataNum, dataNum;
@dynamic reportDataArray, reportDataArray_Count;
@dynamic hasScene, scene;

typedef struct TalkStatReportReq__storage_ {
  uint32_t _has_storage_[1];
  int32_t dataNum;
  uint32_t scene;
  BaseRequest *baseRequest;
  NSMutableArray *reportDataArray;
} TalkStatReportReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = TalkStatReportReq_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkStatReportReq__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dataNum",
        .dataTypeSpecific.className = NULL,
        .number = TalkStatReportReq_FieldNumber_DataNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TalkStatReportReq__storage_, dataNum),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "reportDataArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TalkStatReportData),
        .number = TalkStatReportReq_FieldNumber_ReportDataArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TalkStatReportReq__storage_, reportDataArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = TalkStatReportReq_FieldNumber_Scene,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TalkStatReportReq__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkStatReportReq class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkStatReportReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002G\000\003\000ReportData\000\004E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TalkStatReportResp

@implementation TalkStatReportResp

@dynamic hasBaseResponse, baseResponse;

typedef struct TalkStatReportResp__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} TalkStatReportResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = TalkStatReportResp_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TalkStatReportResp__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TalkStatReportResp class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TalkStatReportResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateTalkRoomRequest

@implementation CreateTalkRoomRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasTopic, topic;
@dynamic hasMemberCount, memberCount;
@dynamic memberListArray, memberListArray_Count;
@dynamic hasScene, scene;

typedef struct CreateTalkRoomRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t memberCount;
  uint32_t scene;
  BaseRequest *baseRequest;
  SKBuiltinString_t *topic;
  NSMutableArray *memberListArray;
} CreateTalkRoomRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = CreateTalkRoomRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateTalkRoomRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "topic",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = CreateTalkRoomRequest_FieldNumber_Topic,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateTalkRoomRequest__storage_, topic),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.className = NULL,
        .number = CreateTalkRoomRequest_FieldNumber_MemberCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CreateTalkRoomRequest__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "memberListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberReq),
        .number = CreateTalkRoomRequest_FieldNumber_MemberListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CreateTalkRoomRequest__storage_, memberListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = CreateTalkRoomRequest_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CreateTalkRoomRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateTalkRoomRequest class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateTalkRoomRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001K\000\002E\000\003K\000\004\000MemberList\000\005E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateTalkRoomResponse

@implementation CreateTalkRoomResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasTopic, topic;
@dynamic hasPyinitial, pyinitial;
@dynamic hasQuanPin, quanPin;
@dynamic hasMemberCount, memberCount;
@dynamic memberListArray, memberListArray_Count;
@dynamic hasTalkRoomName, talkRoomName;
@dynamic hasImgBuf, imgBuf;
@dynamic hasBigHeadImgURL, bigHeadImgURL;
@dynamic hasSmallHeadImgURL, smallHeadImgURL;
@dynamic hasRoomId, roomId;
@dynamic hasRoomKey, roomKey;
@dynamic hasMicSeq, micSeq;
@dynamic hasMyRoomMemberId, myRoomMemberId;

typedef struct CreateTalkRoomResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t memberCount;
  int32_t roomId;
  int32_t micSeq;
  int32_t myRoomMemberId;
  BaseResponse *baseResponse;
  SKBuiltinString_t *topic;
  SKBuiltinString_t *pyinitial;
  SKBuiltinString_t *quanPin;
  NSMutableArray *memberListArray;
  SKBuiltinString_t *talkRoomName;
  SKBuiltinBuffer_t *imgBuf;
  NSString *bigHeadImgURL;
  NSString *smallHeadImgURL;
  int64_t roomKey;
} CreateTalkRoomResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = CreateTalkRoomResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "topic",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = CreateTalkRoomResponse_FieldNumber_Topic,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, topic),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pyinitial",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = CreateTalkRoomResponse_FieldNumber_Pyinitial,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, pyinitial),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "quanPin",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = CreateTalkRoomResponse_FieldNumber_QuanPin,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, quanPin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.className = NULL,
        .number = CreateTalkRoomResponse_FieldNumber_MemberCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "memberListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberResp),
        .number = CreateTalkRoomResponse_FieldNumber_MemberListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, memberListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "talkRoomName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = CreateTalkRoomResponse_FieldNumber_TalkRoomName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, talkRoomName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = CreateTalkRoomResponse_FieldNumber_ImgBuf,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, imgBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bigHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = CreateTalkRoomResponse_FieldNumber_BigHeadImgURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, bigHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smallHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = CreateTalkRoomResponse_FieldNumber_SmallHeadImgURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, smallHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "roomId",
        .dataTypeSpecific.className = NULL,
        .number = CreateTalkRoomResponse_FieldNumber_RoomId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, roomId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "roomKey",
        .dataTypeSpecific.className = NULL,
        .number = CreateTalkRoomResponse_FieldNumber_RoomKey,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, roomKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "micSeq",
        .dataTypeSpecific.className = NULL,
        .number = CreateTalkRoomResponse_FieldNumber_MicSeq,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, micSeq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "myRoomMemberId",
        .dataTypeSpecific.className = NULL,
        .number = CreateTalkRoomResponse_FieldNumber_MyRoomMemberId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(CreateTalkRoomResponse__storage_, myRoomMemberId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateTalkRoomResponse class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateTalkRoomResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\016\001L\000\002E\000\003c\006\000\004G\000\005K\000\006\000MemberList\000\007L\000\010F\000\tK!!"
        "\000\nM!!\000\013F\000\014G\000\rF\000\016N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddTalkRoomMemberRequest

@implementation AddTalkRoomMemberRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasMemberCount, memberCount;
@dynamic memberListArray, memberListArray_Count;
@dynamic hasTalkRoomName, talkRoomName;
@dynamic hasScene, scene;

typedef struct AddTalkRoomMemberRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t memberCount;
  uint32_t scene;
  BaseRequest *baseRequest;
  NSMutableArray *memberListArray;
  SKBuiltinString_t *talkRoomName;
} AddTalkRoomMemberRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = AddTalkRoomMemberRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddTalkRoomMemberRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.className = NULL,
        .number = AddTalkRoomMemberRequest_FieldNumber_MemberCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddTalkRoomMemberRequest__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "memberListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberReq),
        .number = AddTalkRoomMemberRequest_FieldNumber_MemberListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddTalkRoomMemberRequest__storage_, memberListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "talkRoomName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = AddTalkRoomMemberRequest_FieldNumber_TalkRoomName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddTalkRoomMemberRequest__storage_, talkRoomName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = AddTalkRoomMemberRequest_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddTalkRoomMemberRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddTalkRoomMemberRequest class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddTalkRoomMemberRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001K\000\002K\000\003\000MemberList\000\004L\000\005E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddTalkRoomMemberResponse

@implementation AddTalkRoomMemberResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasMemberCount, memberCount;
@dynamic memberListArray, memberListArray_Count;

typedef struct AddTalkRoomMemberResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t memberCount;
  BaseResponse *baseResponse;
  NSMutableArray *memberListArray;
} AddTalkRoomMemberResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = AddTalkRoomMemberResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddTalkRoomMemberResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.className = NULL,
        .number = AddTalkRoomMemberResponse_FieldNumber_MemberCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddTalkRoomMemberResponse__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "memberListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberResp),
        .number = AddTalkRoomMemberResponse_FieldNumber_MemberListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(AddTalkRoomMemberResponse__storage_, memberListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddTalkRoomMemberResponse class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddTalkRoomMemberResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002K\000\003\000MemberList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelTalkRoomMemberRequest

@implementation DelTalkRoomMemberRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasMemberCount, memberCount;
@dynamic memberListArray, memberListArray_Count;
@dynamic hasTalkRoomName, talkRoomName;
@dynamic hasScene, scene;

typedef struct DelTalkRoomMemberRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t memberCount;
  uint32_t scene;
  BaseRequest *baseRequest;
  NSMutableArray *memberListArray;
  NSString *talkRoomName;
} DelTalkRoomMemberRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = DelTalkRoomMemberRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelTalkRoomMemberRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.className = NULL,
        .number = DelTalkRoomMemberRequest_FieldNumber_MemberCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelTalkRoomMemberRequest__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "memberListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DelMemberReq),
        .number = DelTalkRoomMemberRequest_FieldNumber_MemberListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DelTalkRoomMemberRequest__storage_, memberListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "talkRoomName",
        .dataTypeSpecific.className = NULL,
        .number = DelTalkRoomMemberRequest_FieldNumber_TalkRoomName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DelTalkRoomMemberRequest__storage_, talkRoomName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = DelTalkRoomMemberRequest_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DelTalkRoomMemberRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelTalkRoomMemberRequest class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelTalkRoomMemberRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001K\000\002K\000\003\000MemberList\000\004L\000\005E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelTalkRoomMemberResponse

@implementation DelTalkRoomMemberResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasMemberCount, memberCount;
@dynamic memberListArray, memberListArray_Count;

typedef struct DelTalkRoomMemberResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t memberCount;
  BaseResponse *baseResponse;
  NSMutableArray *memberListArray;
} DelTalkRoomMemberResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = DelTalkRoomMemberResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelTalkRoomMemberResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.className = NULL,
        .number = DelTalkRoomMemberResponse_FieldNumber_MemberCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelTalkRoomMemberResponse__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "memberListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DelMemberResp),
        .number = DelTalkRoomMemberResponse_FieldNumber_MemberListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DelTalkRoomMemberResponse__storage_, memberListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelTalkRoomMemberResponse class]
                                     rootClass:[MmtalkRoot class]
                                          file:MmtalkRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelTalkRoomMemberResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002K\000\003\000MemberList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
