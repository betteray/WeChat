// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmsync.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mmsync.pbobjc.h"
#import "Mmbuiltintype.pbobjc.h"
#import "Mmbase.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmsyncRoot

@implementation MmsyncRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MmsyncRoot_FileDescriptor

static GPBFileDescriptor *MmsyncRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"micromsg"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - InitBuffer

@implementation InitBuffer

@dynamic hasMaxSyncKey, maxSyncKey;

typedef struct InitBuffer__storage_ {
  uint32_t _has_storage_[1];
  uint32_t maxSyncKey;
} InitBuffer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "maxSyncKey",
        .dataTypeSpecific.className = NULL,
        .number = InitBuffer_FieldNumber_MaxSyncKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InitBuffer__storage_, maxSyncKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InitBuffer class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InitBuffer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InitRequest

@implementation InitRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasSyncKey, syncKey;
@dynamic hasBuffer, buffer;
@dynamic hasLanguage, language;

typedef struct InitRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t syncKey;
  BaseRequest *baseRequest;
  SKBuiltinString_t *userName;
  SKBuiltinString_t *buffer;
  NSString *language;
} InitRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = InitRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InitRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = InitRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InitRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "syncKey",
        .dataTypeSpecific.className = NULL,
        .number = InitRequest_FieldNumber_SyncKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InitRequest__storage_, syncKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "buffer",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = InitRequest_FieldNumber_Buffer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InitRequest__storage_, buffer),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = InitRequest_FieldNumber_Language,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(InitRequest__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InitRequest class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InitRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001K\000\002H\000\003G\000\004F\000\005H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InitResponse

@implementation InitResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasNewSyncKey, newSyncKey;
@dynamic hasContinueFlag, continueFlag;
@dynamic hasCmdCount, cmdCount;
@dynamic cmdListArray, cmdListArray_Count;
@dynamic hasBuffer, buffer;
@dynamic hasRatio, ratio;

typedef struct InitResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t newSyncKey;
  int32_t continueFlag;
  uint32_t cmdCount;
  uint32_t ratio;
  BaseResponse *baseResponse;
  NSMutableArray *cmdListArray;
  SKBuiltinString_t *buffer;
} InitResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = InitResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InitResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newSyncKey",
        .dataTypeSpecific.className = NULL,
        .number = InitResponse_FieldNumber_NewSyncKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InitResponse__storage_, newSyncKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "continueFlag",
        .dataTypeSpecific.className = NULL,
        .number = InitResponse_FieldNumber_ContinueFlag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InitResponse__storage_, continueFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cmdCount",
        .dataTypeSpecific.className = NULL,
        .number = InitResponse_FieldNumber_CmdCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InitResponse__storage_, cmdCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cmdListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdItem),
        .number = InitResponse_FieldNumber_CmdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InitResponse__storage_, cmdListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "buffer",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = InitResponse_FieldNumber_Buffer,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(InitResponse__storage_, buffer),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ratio",
        .dataTypeSpecific.className = NULL,
        .number = InitResponse_FieldNumber_Ratio,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(InitResponse__storage_, ratio),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InitResponse class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InitResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001L\000\002J\000\003L\000\004H\000\005\000CmdList\000\006F\000\007E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KeyBuffer

@implementation KeyBuffer

@dynamic hasSynckey, synckey;

typedef struct KeyBuffer__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinString_t *synckey;
} KeyBuffer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "synckey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = KeyBuffer_FieldNumber_Synckey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KeyBuffer__storage_, synckey),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KeyBuffer class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KeyBuffer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewInitRequest

@implementation NewInitRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasCurrentSynckey, currentSynckey;
@dynamic hasMaxSynckey, maxSynckey;
@dynamic hasLanguage, language;

typedef struct NewInitRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *userName;
  SKBuiltinBuffer_t *currentSynckey;
  SKBuiltinBuffer_t *maxSynckey;
  NSString *language;
} NewInitRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = NewInitRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currentSynckey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewInitRequest_FieldNumber_CurrentSynckey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, currentSynckey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxSynckey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewInitRequest_FieldNumber_MaxSynckey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, maxSynckey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_Language,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewInitRequest class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewInitRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001K\000\002H\000\003N\000\004J\000\005H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewInitResponse

@implementation NewInitResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCurrentSynckey, currentSynckey;
@dynamic hasMaxSynckey, maxSynckey;
@dynamic hasContinueFlag, continueFlag;
@dynamic hasSelectBitmap, selectBitmap;
@dynamic hasCmdCount, cmdCount;
@dynamic cmdListArray, cmdListArray_Count;
@dynamic hasRatio, ratio;

typedef struct NewInitResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t continueFlag;
  uint32_t selectBitmap;
  uint32_t cmdCount;
  uint32_t ratio;
  BaseResponse *baseResponse;
  SKBuiltinBuffer_t *currentSynckey;
  SKBuiltinBuffer_t *maxSynckey;
  NSMutableArray *cmdListArray;
} NewInitResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = NewInitResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "currentSynckey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewInitResponse_FieldNumber_CurrentSynckey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, currentSynckey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxSynckey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewInitResponse_FieldNumber_MaxSynckey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, maxSynckey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "continueFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_ContinueFlag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, continueFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "selectBitmap",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_SelectBitmap,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, selectBitmap),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cmdCount",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_CmdCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, cmdCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cmdListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdItem),
        .number = NewInitResponse_FieldNumber_CmdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, cmdListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ratio",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_Ratio,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, ratio),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewInitResponse class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewInitResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001L\000\002N\000\003J\000\004L\000\005L\000\006H\000\007\000CmdList\000\010E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncRequest

@implementation SyncRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasSyncKey, syncKey;
@dynamic hasScene, scene;
@dynamic hasOption, option;
@dynamic hasOplog, oplog;
@dynamic hasKeyBuf, keyBuf;

typedef struct SyncRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t syncKey;
  int32_t scene;
  int32_t option;
  BaseRequest *baseRequest;
  SKBuiltinString_t *userName;
  CmdList *oplog;
  NSString *keyBuf;
} SyncRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = SyncRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = SyncRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "syncKey",
        .dataTypeSpecific.className = NULL,
        .number = SyncRequest_FieldNumber_SyncKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SyncRequest__storage_, syncKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = SyncRequest_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SyncRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "option",
        .dataTypeSpecific.className = NULL,
        .number = SyncRequest_FieldNumber_Option,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SyncRequest__storage_, option),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "oplog",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdList),
        .number = SyncRequest_FieldNumber_Oplog,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SyncRequest__storage_, oplog),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "keyBuf",
        .dataTypeSpecific.className = NULL,
        .number = SyncRequest_FieldNumber_KeyBuf,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SyncRequest__storage_, keyBuf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncRequest class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001K\000\002H\000\003G\000\004E\000\005F\000\006E\000\007F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncResponse

@implementation SyncResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasNewSyncKey, newSyncKey;
@dynamic hasContinueFlag, continueFlag;
@dynamic hasCmdCount, cmdCount;
@dynamic cmdListArray, cmdListArray_Count;
@dynamic hasOobcount, oobcount;
@dynamic ooblistArray, ooblistArray_Count;
@dynamic hasKeyBuf, keyBuf;

typedef struct SyncResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t newSyncKey;
  int32_t continueFlag;
  uint32_t cmdCount;
  uint32_t oobcount;
  BaseResponse *baseResponse;
  NSMutableArray *cmdListArray;
  NSMutableArray *ooblistArray;
  NSString *keyBuf;
} SyncResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = SyncResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newSyncKey",
        .dataTypeSpecific.className = NULL,
        .number = SyncResponse_FieldNumber_NewSyncKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncResponse__storage_, newSyncKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "continueFlag",
        .dataTypeSpecific.className = NULL,
        .number = SyncResponse_FieldNumber_ContinueFlag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SyncResponse__storage_, continueFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cmdCount",
        .dataTypeSpecific.className = NULL,
        .number = SyncResponse_FieldNumber_CmdCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SyncResponse__storage_, cmdCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cmdListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdItem),
        .number = SyncResponse_FieldNumber_CmdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncResponse__storage_, cmdListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "oobcount",
        .dataTypeSpecific.className = NULL,
        .number = SyncResponse_FieldNumber_Oobcount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SyncResponse__storage_, oobcount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ooblistArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdItem),
        .number = SyncResponse_FieldNumber_OoblistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncResponse__storage_, ooblistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "keyBuf",
        .dataTypeSpecific.className = NULL,
        .number = SyncResponse_FieldNumber_KeyBuf,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SyncResponse__storage_, keyBuf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncResponse class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001L\000\002J\000\003L\000\004H\000\005\000CmdList\000\006d\004\000\007\000OOBList\000\010F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KeyVal

@implementation KeyVal

@dynamic hasKey, key;
@dynamic hasVal, val;

typedef struct KeyVal__storage_ {
  uint32_t _has_storage_[1];
  uint32_t key;
  uint32_t val;
} KeyVal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = KeyVal_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KeyVal__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "val",
        .dataTypeSpecific.className = NULL,
        .number = KeyVal_FieldNumber_Val,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KeyVal__storage_, val),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KeyVal class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KeyVal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001C\000\002C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncKey

@implementation SyncKey

@dynamic hasKeyCount, keyCount;
@dynamic keyArray, keyArray_Count;

typedef struct SyncKey__storage_ {
  uint32_t _has_storage_[1];
  uint32_t keyCount;
  NSMutableArray *keyArray;
} SyncKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyCount",
        .dataTypeSpecific.className = NULL,
        .number = SyncKey_FieldNumber_KeyCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncKey__storage_, keyCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "keyArray",
        .dataTypeSpecific.className = GPBStringifySymbol(KeyVal),
        .number = SyncKey_FieldNumber_KeyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncKey__storage_, keyArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncKey class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002\000Key\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewSyncRequest

@implementation NewSyncRequest

@dynamic hasOplog, oplog;
@dynamic hasSelector, selector;
@dynamic hasKeyBuf, keyBuf;
@dynamic hasScene, scene;
@dynamic hasDeviceType, deviceType;
@dynamic hasSyncMsgDigest, syncMsgDigest;

typedef struct NewSyncRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t selector;
  uint32_t scene;
  int32_t syncMsgDigest;
  CmdList *oplog;
  SKBuiltinBuffer_t *keyBuf;
  NSString *deviceType;
} NewSyncRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oplog",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdList),
        .number = NewSyncRequest_FieldNumber_Oplog,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, oplog),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "selector",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_Selector,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, selector),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "keyBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewSyncRequest_FieldNumber_KeyBuf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, keyBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_DeviceType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "syncMsgDigest",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_SyncMsgDigest,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, syncMsgDigest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewSyncRequest class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewSyncRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001E\000\002H\000\003F\000\004E\000\005J\000\006\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewSyncResponse

@implementation NewSyncResponse

@dynamic hasRet, ret;
@dynamic hasCmdList, cmdList;
@dynamic hasContinueFlag, continueFlag;
@dynamic hasKeyBuf, keyBuf;
@dynamic hasStatus, status;
@dynamic hasOnlineVersion, onlineVersion;
@dynamic hasSvrTime, svrTime;

typedef struct NewSyncResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  uint32_t continueFlag;
  uint32_t status;
  uint32_t onlineVersion;
  int32_t svrTime;
  CmdList *cmdList;
  SKBuiltinBuffer_t *keyBuf;
} NewSyncResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, ret),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cmdList",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdList),
        .number = NewSyncResponse_FieldNumber_CmdList,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, cmdList),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "continueFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_ContinueFlag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, continueFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "keyBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewSyncResponse_FieldNumber_KeyBuf,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, keyBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "onlineVersion",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_OnlineVersion,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, onlineVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "svrTime",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncResponse_FieldNumber_SvrTime,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NewSyncResponse__storage_, svrTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewSyncResponse class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewSyncResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001C\000\002G\000\003L\000\004F\000\005F\000\006M\000\007\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncFriendRequest

@implementation SyncFriendRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasSyncKey, syncKey;
@dynamic hasScene, scene;

typedef struct SyncFriendRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t syncKey;
  int32_t scene;
  BaseRequest *baseRequest;
  SKBuiltinString_t *userName;
} SyncFriendRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = SyncFriendRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncFriendRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = SyncFriendRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncFriendRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "syncKey",
        .dataTypeSpecific.className = NULL,
        .number = SyncFriendRequest_FieldNumber_SyncKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SyncFriendRequest__storage_, syncKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = SyncFriendRequest_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SyncFriendRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncFriendRequest class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncFriendRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002H\000\003G\000\004E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SyncFriendResponse

@implementation SyncFriendResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasNewSyncKey, newSyncKey;
@dynamic hasContinueFlag, continueFlag;
@dynamic hasCmdCount, cmdCount;
@dynamic cmdListArray, cmdListArray_Count;

typedef struct SyncFriendResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t newSyncKey;
  int32_t continueFlag;
  uint32_t cmdCount;
  BaseResponse *baseResponse;
  NSMutableArray *cmdListArray;
} SyncFriendResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = SyncFriendResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SyncFriendResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newSyncKey",
        .dataTypeSpecific.className = NULL,
        .number = SyncFriendResponse_FieldNumber_NewSyncKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SyncFriendResponse__storage_, newSyncKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "continueFlag",
        .dataTypeSpecific.className = NULL,
        .number = SyncFriendResponse_FieldNumber_ContinueFlag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SyncFriendResponse__storage_, continueFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cmdCount",
        .dataTypeSpecific.className = NULL,
        .number = SyncFriendResponse_FieldNumber_CmdCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SyncFriendResponse__storage_, cmdCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cmdListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdItem),
        .number = SyncFriendResponse_FieldNumber_CmdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SyncFriendResponse__storage_, cmdListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SyncFriendResponse class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SyncFriendResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001L\000\002J\000\003L\000\004H\000\005\000CmdList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpenQQMicroBlog

@implementation OpenQQMicroBlog

@dynamic hasMicroBlogUserName, microBlogUserName;

typedef struct OpenQQMicroBlog__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinString_t *microBlogUserName;
} OpenQQMicroBlog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "microBlogUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = OpenQQMicroBlog_FieldNumber_MicroBlogUserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OpenQQMicroBlog__storage_, microBlogUserName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpenQQMicroBlog class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpenQQMicroBlog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001Q\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModChatRoomNotify

@implementation ModChatRoomNotify

@dynamic hasChatRoomName, chatRoomName;
@dynamic hasStatus, status;

typedef struct ModChatRoomNotify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  SKBuiltinString_t *chatRoomName;
} ModChatRoomNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatRoomName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModChatRoomNotify_FieldNumber_ChatRoomName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModChatRoomNotify__storage_, chatRoomName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomNotify_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModChatRoomNotify__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModChatRoomNotify class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModChatRoomNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CloseMicroBlog

@implementation CloseMicroBlog

@dynamic hasMicroBlogUserName, microBlogUserName;

typedef struct CloseMicroBlog__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinString_t *microBlogUserName;
} CloseMicroBlog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "microBlogUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = CloseMicroBlog_FieldNumber_MicroBlogUserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CloseMicroBlog__storage_, microBlogUserName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CloseMicroBlog class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CloseMicroBlog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001Q\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModChatRoomMember

@implementation ModChatRoomMember

@dynamic hasUserName, userName;
@dynamic hasNickName, nickName;
@dynamic hasPyinitial, pyinitial;
@dynamic hasQuanPin, quanPin;
@dynamic hasSex, sex;
@dynamic hasImgBuf, imgBuf;
@dynamic hasImgFlag, imgFlag;
@dynamic hasRemark, remark;
@dynamic hasRemarkPyinitial, remarkPyinitial;
@dynamic hasRemarkQuanPin, remarkQuanPin;
@dynamic hasContactType, contactType;
@dynamic hasProvince, province;
@dynamic hasCity, city;
@dynamic hasSignature, signature;
@dynamic hasPersonalCard, personalCard;
@dynamic hasVerifyFlag, verifyFlag;
@dynamic hasVerifyInfo, verifyInfo;
@dynamic hasWeibo, weibo;
@dynamic hasVerifyContent, verifyContent;
@dynamic hasWeiboNickname, weiboNickname;
@dynamic hasWeiboFlag, weiboFlag;
@dynamic hasAlbumStyle, albumStyle;
@dynamic hasAlbumFlag, albumFlag;
@dynamic hasAlbumBgimgId, albumBgimgId;
@dynamic hasAlias, alias;
@dynamic hasSnsUserInfo, snsUserInfo;
@dynamic hasCountry, country;
@dynamic hasBigHeadImgURL, bigHeadImgURL;
@dynamic hasSmallHeadImgURL, smallHeadImgURL;
@dynamic hasMyBrandList, myBrandList;
@dynamic hasCustomizedInfo, customizedInfo;

typedef struct ModChatRoomMember__storage_ {
  uint32_t _has_storage_[1];
  int32_t sex;
  uint32_t imgFlag;
  uint32_t contactType;
  uint32_t personalCard;
  uint32_t verifyFlag;
  uint32_t weiboFlag;
  int32_t albumStyle;
  int32_t albumFlag;
  SKBuiltinString_t *userName;
  SKBuiltinString_t *nickName;
  SKBuiltinString_t *pyinitial;
  SKBuiltinString_t *quanPin;
  SKBuiltinBuffer_t *imgBuf;
  SKBuiltinString_t *remark;
  SKBuiltinString_t *remarkPyinitial;
  SKBuiltinString_t *remarkQuanPin;
  NSString *province;
  NSString *city;
  NSString *signature;
  NSString *verifyInfo;
  NSString *weibo;
  NSString *verifyContent;
  NSString *weiboNickname;
  NSString *albumBgimgId;
  NSString *alias;
  SnsUserInfo *snsUserInfo;
  NSString *country;
  NSString *bigHeadImgURL;
  NSString *smallHeadImgURL;
  NSString *myBrandList;
  CustomizedInfo *customizedInfo;
} ModChatRoomMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModChatRoomMember_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModChatRoomMember_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pyinitial",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModChatRoomMember_FieldNumber_Pyinitial,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, pyinitial),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "quanPin",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModChatRoomMember_FieldNumber_QuanPin,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, quanPin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, sex),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "imgBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ModChatRoomMember_FieldNumber_ImgBuf,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, imgBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_ImgFlag,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, imgFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "remark",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModChatRoomMember_FieldNumber_Remark,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, remark),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remarkPyinitial",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModChatRoomMember_FieldNumber_RemarkPyinitial,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, remarkPyinitial),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remarkQuanPin",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModChatRoomMember_FieldNumber_RemarkQuanPin,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, remarkQuanPin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "contactType",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_ContactType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, contactType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "province",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_Province,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, province),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "city",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_City,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, city),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_Signature,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "personalCard",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_PersonalCard,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, personalCard),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "verifyFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_VerifyFlag,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, verifyFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "verifyInfo",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_VerifyInfo,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, verifyInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weibo",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_Weibo,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, weibo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyContent",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_VerifyContent,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, verifyContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weiboNickname",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_WeiboNickname,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, weiboNickname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "weiboFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_WeiboFlag,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, weiboFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "albumStyle",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_AlbumStyle,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, albumStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "albumFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_AlbumFlag,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, albumFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "albumBgimgId",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_AlbumBgimgId,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, albumBgimgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_Alias,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, alias),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "snsUserInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SnsUserInfo),
        .number = ModChatRoomMember_FieldNumber_SnsUserInfo,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, snsUserInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_Country,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, country),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bigHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_BigHeadImgURL,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, bigHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smallHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_SmallHeadImgURL,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, smallHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "myBrandList",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMember_FieldNumber_MyBrandList,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, myBrandList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "customizedInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(CustomizedInfo),
        .number = ModChatRoomMember_FieldNumber_CustomizedInfo,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(ModChatRoomMember__storage_, customizedInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModChatRoomMember class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModChatRoomMember__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\037\001H\000\002H\000\003c\006\000\004G\000\005C\000\006F\000\007G\000\010F\000\tGb\006\000\nM\000\013K\000\014H\000"
        "\rD\000\016I\000\017L\000\020J\000\021J\000\022E\000\023M\000\024M\000\025I\000\026J\000\027I\000\030Fb\003A\000\031"
        "E\000\032K\000\033G\000\034K!!\000\035M!!\000\036K\000\037N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QuitChatRoom

@implementation QuitChatRoom

@dynamic hasChatRoomName, chatRoomName;
@dynamic hasUserName, userName;

typedef struct QuitChatRoom__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinString_t *chatRoomName;
  SKBuiltinString_t *userName;
} QuitChatRoom__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatRoomName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = QuitChatRoom_FieldNumber_ChatRoomName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QuitChatRoom__storage_, chatRoomName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = QuitChatRoom_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QuitChatRoom__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QuitChatRoom class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QuitChatRoom__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModChatRoomTopic

@implementation ModChatRoomTopic

@dynamic hasChatRoomName, chatRoomName;
@dynamic hasChatRoomTopic, chatRoomTopic;

typedef struct ModChatRoomTopic__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinString_t *chatRoomName;
  SKBuiltinString_t *chatRoomTopic;
} ModChatRoomTopic__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatRoomName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModChatRoomTopic_FieldNumber_ChatRoomName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModChatRoomTopic__storage_, chatRoomName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "chatRoomTopic",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModChatRoomTopic_FieldNumber_ChatRoomTopic,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModChatRoomTopic__storage_, chatRoomTopic),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModChatRoomTopic class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModChatRoomTopic__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002M\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModChatRoomMemberDisplayName

@implementation ModChatRoomMemberDisplayName

@dynamic hasChatRoomName, chatRoomName;
@dynamic hasUserName, userName;
@dynamic hasDisplayName, displayName;

typedef struct ModChatRoomMemberDisplayName__storage_ {
  uint32_t _has_storage_[1];
  NSString *chatRoomName;
  NSString *userName;
  NSString *displayName;
} ModChatRoomMemberDisplayName__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatRoomName",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMemberDisplayName_FieldNumber_ChatRoomName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModChatRoomMemberDisplayName__storage_, chatRoomName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMemberDisplayName_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModChatRoomMemberDisplayName__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayName",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMemberDisplayName_FieldNumber_DisplayName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModChatRoomMemberDisplayName__storage_, displayName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModChatRoomMemberDisplayName class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModChatRoomMemberDisplayName__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002H\000\003K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModChatRoomMemberFlag

@implementation ModChatRoomMemberFlag

@dynamic hasChatRoomName, chatRoomName;
@dynamic hasUserName, userName;
@dynamic hasFlagSwitch, flagSwitch;
@dynamic hasValue, value;

typedef struct ModChatRoomMemberFlag__storage_ {
  uint32_t _has_storage_[1];
  uint32_t flagSwitch;
  uint32_t value;
  NSString *chatRoomName;
  NSString *userName;
} ModChatRoomMemberFlag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatRoomName",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMemberFlag_FieldNumber_ChatRoomName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModChatRoomMemberFlag__storage_, chatRoomName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMemberFlag_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModChatRoomMemberFlag__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "flagSwitch",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMemberFlag_FieldNumber_FlagSwitch,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModChatRoomMemberFlag__storage_, flagSwitch),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = ModChatRoomMemberFlag_FieldNumber_Value,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModChatRoomMemberFlag__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModChatRoomMemberFlag class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModChatRoomMemberFlag__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001L\000\002H\000\003J\000\004E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddMsg

@implementation AddMsg

@dynamic hasMsgId, msgId;
@dynamic hasFromUserName, fromUserName;
@dynamic hasToUserName, toUserName;
@dynamic hasMsgType, msgType;
@dynamic hasContent, content;
@dynamic hasStatus, status;
@dynamic hasImgStatus, imgStatus;
@dynamic hasImgBuf, imgBuf;
@dynamic hasCreateTime, createTime;
@dynamic hasMsgSource, msgSource;
@dynamic hasPushContent, pushContent;
@dynamic hasNewMsgId, newMsgId;
@dynamic hasMsgSeq, msgSeq;

typedef struct AddMsg__storage_ {
  uint32_t _has_storage_[1];
  int32_t msgId;
  int32_t msgType;
  uint32_t status;
  uint32_t imgStatus;
  uint32_t createTime;
  int32_t msgSeq;
  SKBuiltinString_t *fromUserName;
  SKBuiltinString_t *toUserName;
  SKBuiltinString_t *content;
  SKBuiltinBuffer_t *imgBuf;
  NSString *msgSource;
  NSString *pushContent;
  int64_t newMsgId;
} AddMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddMsg__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fromUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = AddMsg_FieldNumber_FromUserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddMsg__storage_, fromUserName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = AddMsg_FieldNumber_ToUserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddMsg__storage_, toUserName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_MsgType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddMsg__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = AddMsg_FieldNumber_Content,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AddMsg__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AddMsg__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgStatus",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_ImgStatus,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AddMsg__storage_, imgStatus),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AddMsg_FieldNumber_ImgBuf,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AddMsg__storage_, imgBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_CreateTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AddMsg__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgSource",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_MsgSource,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AddMsg__storage_, msgSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushContent",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_PushContent,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AddMsg__storage_, pushContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newMsgId",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_NewMsgId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AddMsg__storage_, newMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSeq",
        .dataTypeSpecific.className = NULL,
        .number = AddMsg_FieldNumber_MsgSeq,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AddMsg__storage_, msgSeq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddMsg class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\r\001E\000\002L\000\003J\000\004G\000\005G\000\006F\000\007I\000\010F\000\tJ\000\nI\000\013K\000\014H\000\r\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModMsgStatus

@implementation ModMsgStatus

@dynamic hasMsgId, msgId;
@dynamic hasFromUserName, fromUserName;
@dynamic hasToUserName, toUserName;
@dynamic hasStatus, status;
@dynamic hasNewMsgId, newMsgId;

typedef struct ModMsgStatus__storage_ {
  uint32_t _has_storage_[1];
  int32_t msgId;
  uint32_t status;
  SKBuiltinString_t *fromUserName;
  SKBuiltinString_t *toUserName;
  int64_t newMsgId;
} ModMsgStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = ModMsgStatus_FieldNumber_MsgId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModMsgStatus__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "fromUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModMsgStatus_FieldNumber_FromUserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModMsgStatus__storage_, fromUserName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModMsgStatus_FieldNumber_ToUserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModMsgStatus__storage_, toUserName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ModMsgStatus_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModMsgStatus__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "newMsgId",
        .dataTypeSpecific.className = NULL,
        .number = ModMsgStatus_FieldNumber_NewMsgId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ModMsgStatus__storage_, newMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModMsgStatus class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModMsgStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001E\000\002L\000\003J\000\004F\000\005H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelContact

@implementation DelContact

@dynamic hasUserName, userName;

typedef struct DelContact__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinString_t *userName;
} DelContact__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = DelContact_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelContact__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelContact class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelContact__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelChatContact

@implementation DelChatContact

@dynamic hasUserName, userName;

typedef struct DelChatContact__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinString_t *userName;
} DelChatContact__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = DelChatContact_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelChatContact__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelChatContact class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelChatContact__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelContactMsg

@implementation DelContactMsg

@dynamic hasUserName, userName;
@dynamic hasMaxMsgId, maxMsgId;
@dynamic hasNewMsgId, newMsgId;

typedef struct DelContactMsg__storage_ {
  uint32_t _has_storage_[1];
  int32_t maxMsgId;
  SKBuiltinString_t *userName;
  int64_t newMsgId;
} DelContactMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = DelContactMsg_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelContactMsg__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "maxMsgId",
        .dataTypeSpecific.className = NULL,
        .number = DelContactMsg_FieldNumber_MaxMsgId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelContactMsg__storage_, maxMsgId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "newMsgId",
        .dataTypeSpecific.className = NULL,
        .number = DelContactMsg_FieldNumber_NewMsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DelContactMsg__storage_, newMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelContactMsg class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelContactMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001H\000\002H\000\003H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelMsg

@implementation DelMsg

@dynamic hasUserName, userName;
@dynamic hasCount, count;
@dynamic msgIdListArray, msgIdListArray_Count;

typedef struct DelMsg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  SKBuiltinString_t *userName;
  GPBInt32Array *msgIdListArray;
} DelMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = DelMsg_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelMsg__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = DelMsg_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelMsg__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "msgIdListArray",
        .dataTypeSpecific.className = NULL,
        .number = DelMsg_FieldNumber_MsgIdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DelMsg__storage_, msgIdListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelMsg class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001H\000\002E\000\003\000MsgIdList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewDelMsg

@implementation NewDelMsg

@dynamic hasFromUserName, fromUserName;
@dynamic hasToUserName, toUserName;
@dynamic hasMsgId, msgId;
@dynamic hasMsgType, msgType;
@dynamic hasNewMsgId, newMsgId;

typedef struct NewDelMsg__storage_ {
  uint32_t _has_storage_[1];
  int32_t msgId;
  uint32_t msgType;
  NSString *fromUserName;
  NSString *toUserName;
  int64_t newMsgId;
} NewDelMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUserName",
        .dataTypeSpecific.className = NULL,
        .number = NewDelMsg_FieldNumber_FromUserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewDelMsg__storage_, fromUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "toUserName",
        .dataTypeSpecific.className = NULL,
        .number = NewDelMsg_FieldNumber_ToUserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewDelMsg__storage_, toUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = NewDelMsg_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewDelMsg__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgType",
        .dataTypeSpecific.className = NULL,
        .number = NewDelMsg_FieldNumber_MsgType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewDelMsg__storage_, msgType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "newMsgId",
        .dataTypeSpecific.className = NULL,
        .number = NewDelMsg_FieldNumber_NewMsgId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewDelMsg__storage_, newMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewDelMsg class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewDelMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001L\000\002J\000\003E\000\004G\000\005H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FacebookInfo

@implementation FacebookInfo

@dynamic hasUid, uid;
@dynamic hasName, name;
@dynamic hasToken, token;

typedef struct FacebookInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *token;
  uint64_t uid;
} FacebookInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = FacebookInfo_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FacebookInfo__storage_, uid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = FacebookInfo_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FacebookInfo__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = FacebookInfo_FieldNumber_Token,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FacebookInfo__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FacebookInfo class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FacebookInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001C\000\002D\000\003E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModUserImg

@implementation ModUserImg

@dynamic hasImgType, imgType;
@dynamic hasImgLen, imgLen;
@dynamic hasImgBuf, imgBuf;
@dynamic hasImgMd5, imgMd5;
@dynamic hasBigHeadImgURL, bigHeadImgURL;
@dynamic hasSmallHeadImgURL, smallHeadImgURL;

typedef struct ModUserImg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t imgType;
  uint32_t imgLen;
  NSData *imgBuf;
  NSString *imgMd5;
  NSString *bigHeadImgURL;
  NSString *smallHeadImgURL;
} ModUserImg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imgType",
        .dataTypeSpecific.className = NULL,
        .number = ModUserImg_FieldNumber_ImgType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModUserImg__storage_, imgType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgLen",
        .dataTypeSpecific.className = NULL,
        .number = ModUserImg_FieldNumber_ImgLen,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModUserImg__storage_, imgLen),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgBuf",
        .dataTypeSpecific.className = NULL,
        .number = ModUserImg_FieldNumber_ImgBuf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModUserImg__storage_, imgBuf),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "imgMd5",
        .dataTypeSpecific.className = NULL,
        .number = ModUserImg_FieldNumber_ImgMd5,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModUserImg__storage_, imgMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bigHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ModUserImg_FieldNumber_BigHeadImgURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ModUserImg__storage_, bigHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smallHeadImgURL",
        .dataTypeSpecific.className = NULL,
        .number = ModUserImg_FieldNumber_SmallHeadImgURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ModUserImg__storage_, smallHeadImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModUserImg class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModUserImg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001G\000\002F\000\003F\000\004F\000\005K!!\000\006M!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModDisturbSetting

@implementation ModDisturbSetting

@dynamic hasDisturbSetting, disturbSetting;

typedef struct ModDisturbSetting__storage_ {
  uint32_t _has_storage_[1];
  DisturbSetting *disturbSetting;
} ModDisturbSetting__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "disturbSetting",
        .dataTypeSpecific.className = GPBStringifySymbol(DisturbSetting),
        .number = ModDisturbSetting_FieldNumber_DisturbSetting,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModDisturbSetting__storage_, disturbSetting),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModDisturbSetting class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModDisturbSetting__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModNotifyStatus

@implementation ModNotifyStatus

@dynamic hasUserName, userName;
@dynamic hasStatus, status;

typedef struct ModNotifyStatus__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  SKBuiltinString_t *userName;
} ModNotifyStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModNotifyStatus_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModNotifyStatus__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ModNotifyStatus_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModNotifyStatus__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModNotifyStatus class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModNotifyStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModMicroBlogInfo

@implementation ModMicroBlogInfo

@dynamic hasUserName, userName;
@dynamic hasMicroBlogType, microBlogType;
@dynamic hasNotifyStatus, notifyStatus;
@dynamic hasDeleteFlag, deleteFlag;

typedef struct ModMicroBlogInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t microBlogType;
  uint32_t notifyStatus;
  uint32_t deleteFlag;
  SKBuiltinString_t *userName;
} ModMicroBlogInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModMicroBlogInfo_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModMicroBlogInfo__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "microBlogType",
        .dataTypeSpecific.className = NULL,
        .number = ModMicroBlogInfo_FieldNumber_MicroBlogType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModMicroBlogInfo__storage_, microBlogType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "notifyStatus",
        .dataTypeSpecific.className = NULL,
        .number = ModMicroBlogInfo_FieldNumber_NotifyStatus,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModMicroBlogInfo__storage_, notifyStatus),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deleteFlag",
        .dataTypeSpecific.className = NULL,
        .number = ModMicroBlogInfo_FieldNumber_DeleteFlag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModMicroBlogInfo__storage_, deleteFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModMicroBlogInfo class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModMicroBlogInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001H\000\002M\000\003L\000\004J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Report

@implementation Report

@dynamic hasLog, log;

typedef struct Report__storage_ {
  uint32_t _has_storage_[1];
  NSString *log;
} Report__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "log",
        .dataTypeSpecific.className = NULL,
        .number = Report_FieldNumber_Log,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Report__storage_, log),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Report class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Report__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InviteFriendOpen

@implementation InviteFriendOpen

@dynamic hasUserName, userName;
@dynamic hasFriendType, friendType;

typedef struct InviteFriendOpen__storage_ {
  uint32_t _has_storage_[1];
  uint32_t friendType;
  NSString *userName;
} InviteFriendOpen__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = InviteFriendOpen_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InviteFriendOpen__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "friendType",
        .dataTypeSpecific.className = NULL,
        .number = InviteFriendOpen_FieldNumber_FriendType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InviteFriendOpen__storage_, friendType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InviteFriendOpen class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InviteFriendOpen__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModUserDomainEmail

@implementation ModUserDomainEmail

@dynamic hasStatus, status;
@dynamic hasEmail, email;

typedef struct ModUserDomainEmail__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  SKBuiltinString_t *email;
} ModUserDomainEmail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ModUserDomainEmail_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModUserDomainEmail__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ModUserDomainEmail_FieldNumber_Email,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModUserDomainEmail__storage_, email),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModUserDomainEmail class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModUserDomainEmail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001F\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelUserDomainEmail

@implementation DelUserDomainEmail

@dynamic hasUserName, userName;
@dynamic hasEmail, email;

typedef struct DelUserDomainEmail__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinString_t *userName;
  SKBuiltinString_t *email;
} DelUserDomainEmail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = DelUserDomainEmail_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelUserDomainEmail__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = DelUserDomainEmail_FieldNumber_Email,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelUserDomainEmail__storage_, email),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelUserDomainEmail class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelUserDomainEmail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FunctionSwitch

@implementation FunctionSwitch

@dynamic hasFunctionId, functionId;
@dynamic hasSwitchValue, switchValue;

typedef struct FunctionSwitch__storage_ {
  uint32_t _has_storage_[1];
  uint32_t functionId;
  uint32_t switchValue;
} FunctionSwitch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "functionId",
        .dataTypeSpecific.className = NULL,
        .number = FunctionSwitch_FieldNumber_FunctionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FunctionSwitch__storage_, functionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "switchValue",
        .dataTypeSpecific.className = NULL,
        .number = FunctionSwitch_FieldNumber_SwitchValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FunctionSwitch__storage_, switchValue),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FunctionSwitch class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FunctionSwitch__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WebWxFunctionSwitch

@implementation WebWxFunctionSwitch

@dynamic hasFunctionId, functionId;
@dynamic hasSwitchValue, switchValue;

typedef struct WebWxFunctionSwitch__storage_ {
  uint32_t _has_storage_[1];
  uint32_t functionId;
  uint32_t switchValue;
} WebWxFunctionSwitch__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "functionId",
        .dataTypeSpecific.className = NULL,
        .number = WebWxFunctionSwitch_FieldNumber_FunctionId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WebWxFunctionSwitch__storage_, functionId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "switchValue",
        .dataTypeSpecific.className = NULL,
        .number = WebWxFunctionSwitch_FieldNumber_SwitchValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WebWxFunctionSwitch__storage_, switchValue),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WebWxFunctionSwitch class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WebWxFunctionSwitch__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PluginInstall

@implementation PluginInstall

@dynamic hasPluginFlag, pluginFlag;
@dynamic hasIsUnInstall, isUnInstall;

typedef struct PluginInstall__storage_ {
  uint32_t _has_storage_[1];
  uint32_t pluginFlag;
  uint32_t isUnInstall;
} PluginInstall__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pluginFlag",
        .dataTypeSpecific.className = NULL,
        .number = PluginInstall_FieldNumber_PluginFlag,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PluginInstall__storage_, pluginFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isUnInstall",
        .dataTypeSpecific.className = NULL,
        .number = PluginInstall_FieldNumber_IsUnInstall,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PluginInstall__storage_, isUnInstall),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PluginInstall class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PluginInstall__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModTXNewsCategory

@implementation ModTXNewsCategory

@dynamic hasTxnewsCategory, txnewsCategory;

typedef struct ModTXNewsCategory__storage_ {
  uint32_t _has_storage_[1];
  uint32_t txnewsCategory;
} ModTXNewsCategory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txnewsCategory",
        .dataTypeSpecific.className = NULL,
        .number = ModTXNewsCategory_FieldNumber_TxnewsCategory,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModTXNewsCategory__storage_, txnewsCategory),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModTXNewsCategory class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModTXNewsCategory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001c\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MediaNoteOpLog

@implementation MediaNoteOpLog

@dynamic hasWriteCount, writeCount;
@dynamic hasNoteType, noteType;

typedef struct MediaNoteOpLog__storage_ {
  uint32_t _has_storage_[1];
  uint32_t writeCount;
  int32_t noteType;
} MediaNoteOpLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "writeCount",
        .dataTypeSpecific.className = NULL,
        .number = MediaNoteOpLog_FieldNumber_WriteCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MediaNoteOpLog__storage_, writeCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "noteType",
        .dataTypeSpecific.className = NULL,
        .number = MediaNoteOpLog_FieldNumber_NoteType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MediaNoteOpLog__storage_, noteType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MediaNoteOpLog class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MediaNoteOpLog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GmailSwitchOplog

@implementation GmailSwitchOplog

@dynamic hasGmailAcct, gmailAcct;
@dynamic hasGmailSwitch, gmailSwitch;

typedef struct GmailSwitchOplog__storage_ {
  uint32_t _has_storage_[1];
  uint32_t gmailSwitch;
  NSString *gmailAcct;
} GmailSwitchOplog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "gmailAcct",
        .dataTypeSpecific.className = NULL,
        .number = GmailSwitchOplog_FieldNumber_GmailAcct,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GmailSwitchOplog__storage_, gmailAcct),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "gmailSwitch",
        .dataTypeSpecific.className = NULL,
        .number = GmailSwitchOplog_FieldNumber_GmailSwitch,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GmailSwitchOplog__storage_, gmailSwitch),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GmailSwitchOplog class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GmailSwitchOplog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001I\000\002K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateStatOpLog

@implementation UpdateStatOpLog

@dynamic hasOpCode, opCode;

typedef struct UpdateStatOpLog__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opCode;
} UpdateStatOpLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "opCode",
        .dataTypeSpecific.className = NULL,
        .number = UpdateStatOpLog_FieldNumber_OpCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateStatOpLog__storage_, opCode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateStatOpLog class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateStatOpLog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KVStatItem

@implementation KVStatItem

@dynamic hasKey, key;
@dynamic hasValue, value;

typedef struct KVStatItem__storage_ {
  uint32_t _has_storage_[1];
  uint32_t key;
  NSString *value;
} KVStatItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = KVStatItem_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KVStatItem__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = KVStatItem_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KVStatItem__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KVStatItem class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KVStatItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001C\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KVStatOpLog

@implementation KVStatOpLog

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct KVStatOpLog__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSMutableArray *listArray;
} KVStatOpLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = KVStatOpLog_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KVStatOpLog__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(KVStatItem),
        .number = KVStatOpLog_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(KVStatOpLog__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KVStatOpLog class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KVStatOpLog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001E\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - KVCmd

@implementation KVCmd

@dynamic hasKey, key;
@dynamic hasValue, value;

typedef struct KVCmd__storage_ {
  uint32_t _has_storage_[1];
  uint32_t key;
  SKBuiltinBuffer_t *value;
} KVCmd__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = KVCmd_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(KVCmd__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = KVCmd_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(KVCmd__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[KVCmd class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(KVCmd__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001C\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ThemeOpLog

@implementation ThemeOpLog

@dynamic hasKey, key;
@dynamic hasValue, value;

typedef struct ThemeOpLog__storage_ {
  uint32_t _has_storage_[1];
  uint32_t key;
  NSString *value;
} ThemeOpLog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ThemeOpLog_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ThemeOpLog__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = ThemeOpLog_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ThemeOpLog__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ThemeOpLog class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ThemeOpLog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001C\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModDescription

@implementation ModDescription

@dynamic hasContactUsername, contactUsername;
@dynamic hasDesc, desc;

typedef struct ModDescription__storage_ {
  uint32_t _has_storage_[1];
  NSString *contactUsername;
  NSString *desc;
} ModDescription__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "contactUsername",
        .dataTypeSpecific.className = NULL,
        .number = ModDescription_FieldNumber_ContactUsername,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModDescription__storage_, contactUsername),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = ModDescription_FieldNumber_Desc,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModDescription__storage_, desc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModDescription class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModDescription__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001O\000\002D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OplogRet

@implementation OplogRet

@dynamic hasCount, count;
@dynamic retArray, retArray_Count;

typedef struct OplogRet__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  GPBInt32Array *retArray;
} OplogRet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = OplogRet_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OplogRet__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "retArray",
        .dataTypeSpecific.className = NULL,
        .number = OplogRet_FieldNumber_RetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OplogRet__storage_, retArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OplogRet class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OplogRet__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001E\000\002\000Ret\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OplogRequest

@implementation OplogRequest

@dynamic hasOplog, oplog;

typedef struct OplogRequest__storage_ {
  uint32_t _has_storage_[1];
  CmdList *oplog;
} OplogRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "oplog",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdList),
        .number = OplogRequest_FieldNumber_Oplog,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OplogRequest__storage_, oplog),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OplogRequest class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OplogRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OplogResponse

@implementation OplogResponse

@dynamic hasRet, ret;
@dynamic hasOplogRet, oplogRet;

typedef struct OplogResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  OplogRet *oplogRet;
} OplogResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = OplogResponse_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OplogResponse__storage_, ret),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "oplogRet",
        .dataTypeSpecific.className = GPBStringifySymbol(OplogRet),
        .number = OplogResponse_FieldNumber_OplogRet,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OplogResponse__storage_, oplogRet),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OplogResponse class]
                                     rootClass:[MmsyncRoot class]
                                          file:MmsyncRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OplogResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001C\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
