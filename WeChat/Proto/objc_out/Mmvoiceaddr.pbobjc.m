// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmvoiceaddr.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mmvoiceaddr.pbobjc.h"
#import "Mmbuiltintype.pbobjc.h"
#import "Mmbase.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmvoiceaddrRoot

@implementation MmvoiceaddrRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MmvoiceaddrRoot_FileDescriptor

static GPBFileDescriptor *MmvoiceaddrRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"micromsg"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - VoiceAddrRequest

@implementation VoiceAddrRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasData_p, data_p;
@dynamic hasOffset, offset;
@dynamic hasClientVoiceId, clientVoiceId;
@dynamic hasEndFlag, endFlag;
@dynamic hasSamplePerSec, samplePerSec;
@dynamic hasBitsPerSample, bitsPerSample;
@dynamic hasVoiceEncodeType, voiceEncodeType;
@dynamic hasFileType, fileType;
@dynamic hasSearchType, searchType;
@dynamic hasExtraNameCount, extraNameCount;
@dynamic extraNameUserNameListArray, extraNameUserNameListArray_Count;
@dynamic extraNameRemarkNameListArray, extraNameRemarkNameListArray_Count;

typedef struct VoiceAddrRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t offset;
  uint32_t endFlag;
  uint32_t samplePerSec;
  uint32_t bitsPerSample;
  uint32_t voiceEncodeType;
  uint32_t fileType;
  uint32_t searchType;
  uint32_t extraNameCount;
  BaseRequest *baseRequest;
  NSString *userName;
  SKBuiltinBuffer_t *data_p;
  NSString *clientVoiceId;
  NSMutableArray *extraNameUserNameListArray;
  NSMutableArray *extraNameRemarkNameListArray;
} VoiceAddrRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = VoiceAddrRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = VoiceAddrRequest_FieldNumber_Data_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrRequest_FieldNumber_Offset,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientVoiceId",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrRequest_FieldNumber_ClientVoiceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, clientVoiceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endFlag",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrRequest_FieldNumber_EndFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, endFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "samplePerSec",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrRequest_FieldNumber_SamplePerSec,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, samplePerSec),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bitsPerSample",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrRequest_FieldNumber_BitsPerSample,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, bitsPerSample),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "voiceEncodeType",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrRequest_FieldNumber_VoiceEncodeType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, voiceEncodeType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fileType",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrRequest_FieldNumber_FileType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, fileType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "searchType",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrRequest_FieldNumber_SearchType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, searchType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extraNameCount",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrRequest_FieldNumber_ExtraNameCount,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, extraNameCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extraNameUserNameListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = VoiceAddrRequest_FieldNumber_ExtraNameUserNameListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, extraNameUserNameListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extraNameRemarkNameListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = VoiceAddrRequest_FieldNumber_ExtraNameRemarkNameListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VoiceAddrRequest__storage_, extraNameRemarkNameListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoiceAddrRequest class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceAddrRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\016\001K\000\002H\000\003\000Data\000\004F\000\005M\000\006G\000\007L\000\010M\000\tO\000\nH\000\013J\000\014N"
        "\000\r\000ExtraNameUserNameList\000\016\000ExtraNameRema"
        "rkNameList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoiceAddrResponse

@implementation VoiceAddrResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasEndFlag, endFlag;
@dynamic hasUserCount, userCount;
@dynamic userNameListArray, userNameListArray_Count;
@dynamic hasReportFiled, reportFiled;

typedef struct VoiceAddrResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t endFlag;
  int32_t userCount;
  BaseResponse *baseResponse;
  NSMutableArray *userNameListArray;
  NSString *reportFiled;
} VoiceAddrResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = VoiceAddrResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoiceAddrResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endFlag",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrResponse_FieldNumber_EndFlag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VoiceAddrResponse__storage_, endFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userCount",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrResponse_FieldNumber_UserCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VoiceAddrResponse__storage_, userCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "userNameListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = VoiceAddrResponse_FieldNumber_UserNameListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VoiceAddrResponse__storage_, userNameListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reportFiled",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrResponse_FieldNumber_ReportFiled,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VoiceAddrResponse__storage_, reportFiled),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoiceAddrResponse class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceAddrResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001L\000\002G\000\003I\000\004\000UserNameList\000\005K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoiceAddrReportRequest

@implementation VoiceAddrReportRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasHitPos, hitPos;
@dynamic hasHitUserName, hitUserName;

typedef struct VoiceAddrReportRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t hitPos;
  BaseRequest *baseRequest;
  NSString *hitUserName;
} VoiceAddrReportRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = VoiceAddrReportRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoiceAddrReportRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hitPos",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrReportRequest_FieldNumber_HitPos,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VoiceAddrReportRequest__storage_, hitPos),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hitUserName",
        .dataTypeSpecific.className = NULL,
        .number = VoiceAddrReportRequest_FieldNumber_HitUserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VoiceAddrReportRequest__storage_, hitUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoiceAddrReportRequest class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceAddrReportRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002F\000\003K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VoiceAddrReportResponse

@implementation VoiceAddrReportResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct VoiceAddrReportResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} VoiceAddrReportResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = VoiceAddrReportResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VoiceAddrReportResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VoiceAddrReportResponse class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VoiceAddrReportResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ScanBarcodeRequest

@implementation ScanBarcodeRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasType, type;
@dynamic hasBarcode, barcode;
@dynamic hasScene, scene;

typedef struct ScanBarcodeRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t scene;
  BaseRequest *baseRequest;
  NSString *barcode;
} ScanBarcodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ScanBarcodeRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ScanBarcodeRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ScanBarcodeRequest_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ScanBarcodeRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "barcode",
        .dataTypeSpecific.className = NULL,
        .number = ScanBarcodeRequest_FieldNumber_Barcode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ScanBarcodeRequest__storage_, barcode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = ScanBarcodeRequest_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ScanBarcodeRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ScanBarcodeRequest class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ScanBarcodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002D\000\003G\000\004E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ScanBarcodeResponse

@implementation ScanBarcodeResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasType, type;
@dynamic hasDescXml, descXml;

typedef struct ScanBarcodeResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  BaseResponse *baseResponse;
  NSString *descXml;
} ScanBarcodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ScanBarcodeResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ScanBarcodeResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ScanBarcodeResponse_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ScanBarcodeResponse__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "descXml",
        .dataTypeSpecific.className = NULL,
        .number = ScanBarcodeResponse_FieldNumber_DescXml,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ScanBarcodeResponse__storage_, descXml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ScanBarcodeResponse class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ScanBarcodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002D\000\003Eb\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ScanImageRequest

@implementation ScanImageRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasClientScanId, clientScanId;
@dynamic hasImageBuffer, imageBuffer;
@dynamic hasTotalLength, totalLength;
@dynamic hasOffset, offset;
@dynamic hasEndFlag, endFlag;
@dynamic hasImageType, imageType;
@dynamic hasOpcode, opcode;
@dynamic hasSessionId, sessionId;

typedef struct ScanImageRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientScanId;
  uint32_t totalLength;
  uint32_t offset;
  uint32_t endFlag;
  uint32_t imageType;
  uint32_t opcode;
  uint32_t sessionId;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *imageBuffer;
} ScanImageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ScanImageRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ScanImageRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientScanId",
        .dataTypeSpecific.className = NULL,
        .number = ScanImageRequest_FieldNumber_ClientScanId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ScanImageRequest__storage_, clientScanId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imageBuffer",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ScanImageRequest_FieldNumber_ImageBuffer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ScanImageRequest__storage_, imageBuffer),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "totalLength",
        .dataTypeSpecific.className = NULL,
        .number = ScanImageRequest_FieldNumber_TotalLength,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ScanImageRequest__storage_, totalLength),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "offset",
        .dataTypeSpecific.className = NULL,
        .number = ScanImageRequest_FieldNumber_Offset,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ScanImageRequest__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "endFlag",
        .dataTypeSpecific.className = NULL,
        .number = ScanImageRequest_FieldNumber_EndFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ScanImageRequest__storage_, endFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imageType",
        .dataTypeSpecific.className = NULL,
        .number = ScanImageRequest_FieldNumber_ImageType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ScanImageRequest__storage_, imageType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = ScanImageRequest_FieldNumber_Opcode,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ScanImageRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = ScanImageRequest_FieldNumber_SessionId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ScanImageRequest__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ScanImageRequest class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ScanImageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001K\000\002KA\000\003K\000\004K\000\005F\000\006G\000\007I\000\010c\003\000\tHA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ScanImageResponse

@implementation ScanImageResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasClientScanId, clientScanId;
@dynamic hasType, type;
@dynamic hasDescriptionXml, descriptionXml;
@dynamic hasEndFlag, endFlag;
@dynamic hasImageType, imageType;

typedef struct ScanImageResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientScanId;
  uint32_t type;
  uint32_t endFlag;
  uint32_t imageType;
  BaseResponse *baseResponse;
  NSString *descriptionXml;
} ScanImageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ScanImageResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ScanImageResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientScanId",
        .dataTypeSpecific.className = NULL,
        .number = ScanImageResponse_FieldNumber_ClientScanId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ScanImageResponse__storage_, clientScanId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ScanImageResponse_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ScanImageResponse__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "descriptionXml",
        .dataTypeSpecific.className = NULL,
        .number = ScanImageResponse_FieldNumber_DescriptionXml,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ScanImageResponse__storage_, descriptionXml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endFlag",
        .dataTypeSpecific.className = NULL,
        .number = ScanImageResponse_FieldNumber_EndFlag,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ScanImageResponse__storage_, endFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imageType",
        .dataTypeSpecific.className = NULL,
        .number = ScanImageResponse_FieldNumber_ImageType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ScanImageResponse__storage_, imageType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ScanImageResponse class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ScanImageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001L\000\002KA\000\003D\000\004Lb\000\005G\000\006I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetProductInfoRequest

@implementation GetProductInfoRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasProductId, productId;
@dynamic hasScene, scene;
@dynamic hasQrURL, qrURL;

typedef struct GetProductInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t scene;
  BaseRequest *baseRequest;
  NSString *productId;
  NSString *qrURL;
} GetProductInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetProductInfoRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetProductInfoRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = GetProductInfoRequest_FieldNumber_ProductId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetProductInfoRequest__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = GetProductInfoRequest_FieldNumber_Scene,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetProductInfoRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "qrURL",
        .dataTypeSpecific.className = NULL,
        .number = GetProductInfoRequest_FieldNumber_QrURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetProductInfoRequest__storage_, qrURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProductInfoRequest class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProductInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002HA\000\003E\000\004C!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetProductInfoResponse

@implementation GetProductInfoResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasType, type;
@dynamic hasDescXml, descXml;
@dynamic hasProductId, productId;

typedef struct GetProductInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  BaseResponse *baseResponse;
  NSString *descXml;
  NSString *productId;
} GetProductInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetProductInfoResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetProductInfoResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = GetProductInfoResponse_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetProductInfoResponse__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "descXml",
        .dataTypeSpecific.className = NULL,
        .number = GetProductInfoResponse_FieldNumber_DescXml,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetProductInfoResponse__storage_, descXml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = GetProductInfoResponse_FieldNumber_ProductId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetProductInfoResponse__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetProductInfoResponse class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetProductInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001L\000\002D\000\003Eb\000\004HA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OCRTranslationRequest

@implementation OCRTranslationRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasClientScanId, clientScanId;
@dynamic hasImageBuffer, imageBuffer;
@dynamic hasImageType, imageType;
@dynamic hasFromLanguage, fromLanguage;
@dynamic hasToLanguage, toLanguage;
@dynamic hasSessionId, sessionId;

typedef struct OCRTranslationRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientScanId;
  uint32_t imageType;
  uint32_t sessionId;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *imageBuffer;
  NSString *fromLanguage;
  NSString *toLanguage;
} OCRTranslationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = OCRTranslationRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OCRTranslationRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientScanId",
        .dataTypeSpecific.className = NULL,
        .number = OCRTranslationRequest_FieldNumber_ClientScanId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OCRTranslationRequest__storage_, clientScanId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imageBuffer",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = OCRTranslationRequest_FieldNumber_ImageBuffer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OCRTranslationRequest__storage_, imageBuffer),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imageType",
        .dataTypeSpecific.className = NULL,
        .number = OCRTranslationRequest_FieldNumber_ImageType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OCRTranslationRequest__storage_, imageType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fromLanguage",
        .dataTypeSpecific.className = NULL,
        .number = OCRTranslationRequest_FieldNumber_FromLanguage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OCRTranslationRequest__storage_, fromLanguage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "toLanguage",
        .dataTypeSpecific.className = NULL,
        .number = OCRTranslationRequest_FieldNumber_ToLanguage,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OCRTranslationRequest__storage_, toLanguage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionId",
        .dataTypeSpecific.className = NULL,
        .number = OCRTranslationRequest_FieldNumber_SessionId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OCRTranslationRequest__storage_, sessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OCRTranslationRequest class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OCRTranslationRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001K\000\002KA\000\003K\000\004I\000\005L\000\006J\000\007HA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OCRTranslationResponse

@implementation OCRTranslationResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasClientScanId, clientScanId;
@dynamic hasSource, source;
@dynamic hasTranslation, translation;
@dynamic hasImageType, imageType;

typedef struct OCRTranslationResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientScanId;
  uint32_t imageType;
  BaseResponse *baseResponse;
  NSString *source;
  NSString *translation;
} OCRTranslationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = OCRTranslationResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OCRTranslationResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientScanId",
        .dataTypeSpecific.className = NULL,
        .number = OCRTranslationResponse_FieldNumber_ClientScanId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OCRTranslationResponse__storage_, clientScanId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "source",
        .dataTypeSpecific.className = NULL,
        .number = OCRTranslationResponse_FieldNumber_Source,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OCRTranslationResponse__storage_, source),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "translation",
        .dataTypeSpecific.className = NULL,
        .number = OCRTranslationResponse_FieldNumber_Translation,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OCRTranslationResponse__storage_, translation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imageType",
        .dataTypeSpecific.className = NULL,
        .number = OCRTranslationResponse_FieldNumber_ImageType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OCRTranslationResponse__storage_, imageType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OCRTranslationResponse class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OCRTranslationResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001L\000\002KA\000\003F\000\004K\000\005I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShakeTVRequest

@implementation ShakeTVRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasData_p, data_p;
@dynamic hasDataId, dataId;
@dynamic hasEndFlag, endFlag;
@dynamic hasVoiceLen, voiceLen;
@dynamic hasNetType, netType;
@dynamic hasSdkVersion, sdkVersion;

typedef struct ShakeTVRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dataId;
  uint32_t endFlag;
  float voiceLen;
  uint32_t netType;
  uint32_t sdkVersion;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *data_p;
} ShakeTVRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ShakeTVRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShakeTVRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ShakeTVRequest_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShakeTVRequest__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dataId",
        .dataTypeSpecific.className = NULL,
        .number = ShakeTVRequest_FieldNumber_DataId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShakeTVRequest__storage_, dataId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "endFlag",
        .dataTypeSpecific.className = NULL,
        .number = ShakeTVRequest_FieldNumber_EndFlag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShakeTVRequest__storage_, endFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "voiceLen",
        .dataTypeSpecific.className = NULL,
        .number = ShakeTVRequest_FieldNumber_VoiceLen,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ShakeTVRequest__storage_, voiceLen),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "netType",
        .dataTypeSpecific.className = NULL,
        .number = ShakeTVRequest_FieldNumber_NetType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ShakeTVRequest__storage_, netType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sdkVersion",
        .dataTypeSpecific.className = NULL,
        .number = ShakeTVRequest_FieldNumber_SdkVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ShakeTVRequest__storage_, sdkVersion),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShakeTVRequest class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShakeTVRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001K\000\002\000Data\000\003F\000\004G\000\005H\000\006G\000\007J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShakeTVResponse

@implementation ShakeTVResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasEndFlag, endFlag;
@dynamic hasType, type;
@dynamic hasDescriptionXml, descriptionXml;

typedef struct ShakeTVResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t endFlag;
  uint32_t type;
  BaseResponse *baseResponse;
  NSString *descriptionXml;
} ShakeTVResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ShakeTVResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShakeTVResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endFlag",
        .dataTypeSpecific.className = NULL,
        .number = ShakeTVResponse_FieldNumber_EndFlag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShakeTVResponse__storage_, endFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ShakeTVResponse_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShakeTVResponse__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "descriptionXml",
        .dataTypeSpecific.className = NULL,
        .number = ShakeTVResponse_FieldNumber_DescriptionXml,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShakeTVResponse__storage_, descriptionXml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShakeTVResponse class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShakeTVResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001L\000\002G\000\003D\000\004Lb\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTVInfoRequest

@implementation GetTVInfoRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasTvid, tvid;
@dynamic hasScene, scene;

typedef struct GetTVInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t scene;
  BaseRequest *baseRequest;
  NSString *tvid;
} GetTVInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetTVInfoRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTVInfoRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tvid",
        .dataTypeSpecific.className = NULL,
        .number = GetTVInfoRequest_FieldNumber_Tvid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetTVInfoRequest__storage_, tvid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = GetTVInfoRequest_FieldNumber_Scene,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetTVInfoRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTVInfoRequest class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTVInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002d\000\003E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetTVInfoResponse

@implementation GetTVInfoResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasType, type;
@dynamic hasDescriptionXml, descriptionXml;
@dynamic hasTvid, tvid;

typedef struct GetTVInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  BaseResponse *baseResponse;
  NSString *descriptionXml;
  NSString *tvid;
} GetTVInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetTVInfoResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetTVInfoResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = GetTVInfoResponse_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetTVInfoResponse__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "descriptionXml",
        .dataTypeSpecific.className = NULL,
        .number = GetTVInfoResponse_FieldNumber_DescriptionXml,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetTVInfoResponse__storage_, descriptionXml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tvid",
        .dataTypeSpecific.className = NULL,
        .number = GetTVInfoResponse_FieldNumber_Tvid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetTVInfoResponse__storage_, tvid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetTVInfoResponse class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetTVInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001L\000\002D\000\003Lb\000\004d\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShakeMusicRequest

@implementation ShakeMusicRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasData_p, data_p;
@dynamic hasDataId, dataId;
@dynamic hasEndFlag, endFlag;
@dynamic hasVoiceLen, voiceLen;
@dynamic hasNetType, netType;
@dynamic hasSdkVersion, sdkVersion;

typedef struct ShakeMusicRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t dataId;
  uint32_t endFlag;
  float voiceLen;
  uint32_t netType;
  uint32_t sdkVersion;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *data_p;
} ShakeMusicRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ShakeMusicRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShakeMusicRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ShakeMusicRequest_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShakeMusicRequest__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dataId",
        .dataTypeSpecific.className = NULL,
        .number = ShakeMusicRequest_FieldNumber_DataId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShakeMusicRequest__storage_, dataId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "endFlag",
        .dataTypeSpecific.className = NULL,
        .number = ShakeMusicRequest_FieldNumber_EndFlag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShakeMusicRequest__storage_, endFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "voiceLen",
        .dataTypeSpecific.className = NULL,
        .number = ShakeMusicRequest_FieldNumber_VoiceLen,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ShakeMusicRequest__storage_, voiceLen),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "netType",
        .dataTypeSpecific.className = NULL,
        .number = ShakeMusicRequest_FieldNumber_NetType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ShakeMusicRequest__storage_, netType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sdkVersion",
        .dataTypeSpecific.className = NULL,
        .number = ShakeMusicRequest_FieldNumber_SdkVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ShakeMusicRequest__storage_, sdkVersion),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShakeMusicRequest class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShakeMusicRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001K\000\002\000Data\000\003F\000\004G\000\005H\000\006G\000\007J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShakeMusicResponse

@implementation ShakeMusicResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasEndFlag, endFlag;
@dynamic hasMusicId, musicId;
@dynamic hasOffset, offset;
@dynamic hasSongName, songName;
@dynamic hasSongSinger, songSinger;
@dynamic hasSongAlbum, songAlbum;
@dynamic hasSongAlbumURL, songAlbumURL;
@dynamic hasSongWifiURL, songWifiURL;
@dynamic hasSongWapLinkURL, songWapLinkURL;
@dynamic hasSongWebURL, songWebURL;
@dynamic hasSongLyric, songLyric;
@dynamic hasResultType, resultType;
@dynamic hasTvtype, tvtype;
@dynamic hasTvdescriptionXml, tvdescriptionXml;

typedef struct ShakeMusicResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t endFlag;
  uint32_t musicId;
  float offset;
  uint32_t resultType;
  uint32_t tvtype;
  BaseResponse *baseResponse;
  SKBuiltinBuffer_t *songName;
  SKBuiltinBuffer_t *songSinger;
  SKBuiltinBuffer_t *songAlbum;
  SKBuiltinBuffer_t *songAlbumURL;
  SKBuiltinBuffer_t *songWifiURL;
  SKBuiltinBuffer_t *songWapLinkURL;
  SKBuiltinBuffer_t *songWebURL;
  SKBuiltinBuffer_t *songLyric;
  NSString *tvdescriptionXml;
} ShakeMusicResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ShakeMusicResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endFlag",
        .dataTypeSpecific.className = NULL,
        .number = ShakeMusicResponse_FieldNumber_EndFlag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, endFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "musicId",
        .dataTypeSpecific.className = NULL,
        .number = ShakeMusicResponse_FieldNumber_MusicId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, musicId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "offset",
        .dataTypeSpecific.className = NULL,
        .number = ShakeMusicResponse_FieldNumber_Offset,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "songName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ShakeMusicResponse_FieldNumber_SongName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, songName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "songSinger",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ShakeMusicResponse_FieldNumber_SongSinger,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, songSinger),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "songAlbum",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ShakeMusicResponse_FieldNumber_SongAlbum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, songAlbum),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "songAlbumURL",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ShakeMusicResponse_FieldNumber_SongAlbumURL,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, songAlbumURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "songWifiURL",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ShakeMusicResponse_FieldNumber_SongWifiURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, songWifiURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "songWapLinkURL",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ShakeMusicResponse_FieldNumber_SongWapLinkURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, songWapLinkURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "songWebURL",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ShakeMusicResponse_FieldNumber_SongWebURL,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, songWebURL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "songLyric",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ShakeMusicResponse_FieldNumber_SongLyric,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, songLyric),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resultType",
        .dataTypeSpecific.className = NULL,
        .number = ShakeMusicResponse_FieldNumber_ResultType,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, resultType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tvtype",
        .dataTypeSpecific.className = NULL,
        .number = ShakeMusicResponse_FieldNumber_Tvtype,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, tvtype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tvdescriptionXml",
        .dataTypeSpecific.className = NULL,
        .number = ShakeMusicResponse_FieldNumber_TvdescriptionXml,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ShakeMusicResponse__storage_, tvdescriptionXml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShakeMusicResponse class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShakeMusicResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\017\001L\000\002G\000\003G\000\004F\000\005H\000\006J\000\007I\000\010J!!\000\tI!!\000\nL!!\000\013H!"
        "!\000\014I\000\rJ\000\016c\003\000\017c\013b\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetQQMusicLyricRequest

@implementation GetQQMusicLyricRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasSongId, songId;
@dynamic hasURL, URL;

typedef struct GetQQMusicLyricRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t songId;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *URL;
} GetQQMusicLyricRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetQQMusicLyricRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetQQMusicLyricRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "songId",
        .dataTypeSpecific.className = NULL,
        .number = GetQQMusicLyricRequest_FieldNumber_SongId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetQQMusicLyricRequest__storage_, songId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetQQMusicLyricRequest_FieldNumber_URL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetQQMusicLyricRequest__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetQQMusicLyricRequest class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetQQMusicLyricRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002F\000\003\001!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetQQMusicLyricResponse

@implementation GetQQMusicLyricResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasSongLyric, songLyric;

typedef struct GetQQMusicLyricResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  SKBuiltinBuffer_t *songLyric;
} GetQQMusicLyricResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetQQMusicLyricResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetQQMusicLyricResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "songLyric",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetQQMusicLyricResponse_FieldNumber_SongLyric,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetQQMusicLyricResponse__storage_, songLyric),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetQQMusicLyricResponse class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetQQMusicLyricResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UploadInputVoiceRequest

@implementation UploadInputVoiceRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasData_p, data_p;
@dynamic hasOffset, offset;
@dynamic hasClientVoiceId, clientVoiceId;
@dynamic hasEndFlag, endFlag;
@dynamic hasSamplePerSec, samplePerSec;
@dynamic hasBitsPerSample, bitsPerSample;
@dynamic hasVoiceEncodeType, voiceEncodeType;
@dynamic hasFileType, fileType;

typedef struct UploadInputVoiceRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t offset;
  uint32_t endFlag;
  uint32_t samplePerSec;
  uint32_t bitsPerSample;
  uint32_t voiceEncodeType;
  uint32_t fileType;
  BaseRequest *baseRequest;
  NSString *userName;
  SKBuiltinBuffer_t *data_p;
  NSString *clientVoiceId;
} UploadInputVoiceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = UploadInputVoiceRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UploadInputVoiceRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = UploadInputVoiceRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UploadInputVoiceRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = UploadInputVoiceRequest_FieldNumber_Data_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UploadInputVoiceRequest__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "offset",
        .dataTypeSpecific.className = NULL,
        .number = UploadInputVoiceRequest_FieldNumber_Offset,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UploadInputVoiceRequest__storage_, offset),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientVoiceId",
        .dataTypeSpecific.className = NULL,
        .number = UploadInputVoiceRequest_FieldNumber_ClientVoiceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UploadInputVoiceRequest__storage_, clientVoiceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endFlag",
        .dataTypeSpecific.className = NULL,
        .number = UploadInputVoiceRequest_FieldNumber_EndFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(UploadInputVoiceRequest__storage_, endFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "samplePerSec",
        .dataTypeSpecific.className = NULL,
        .number = UploadInputVoiceRequest_FieldNumber_SamplePerSec,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(UploadInputVoiceRequest__storage_, samplePerSec),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bitsPerSample",
        .dataTypeSpecific.className = NULL,
        .number = UploadInputVoiceRequest_FieldNumber_BitsPerSample,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(UploadInputVoiceRequest__storage_, bitsPerSample),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "voiceEncodeType",
        .dataTypeSpecific.className = NULL,
        .number = UploadInputVoiceRequest_FieldNumber_VoiceEncodeType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(UploadInputVoiceRequest__storage_, voiceEncodeType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fileType",
        .dataTypeSpecific.className = NULL,
        .number = UploadInputVoiceRequest_FieldNumber_FileType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(UploadInputVoiceRequest__storage_, fileType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UploadInputVoiceRequest class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UploadInputVoiceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\001K\000\002H\000\003\000Data\000\004F\000\005M\000\006G\000\007L\000\010M\000\tO\000\nH\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UploadInputVoiceResponse

@implementation UploadInputVoiceResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasEndFlag, endFlag;
@dynamic hasText, text;

typedef struct UploadInputVoiceResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t endFlag;
  BaseResponse *baseResponse;
  SKBuiltinBuffer_t *text;
} UploadInputVoiceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = UploadInputVoiceResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UploadInputVoiceResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endFlag",
        .dataTypeSpecific.className = NULL,
        .number = UploadInputVoiceResponse_FieldNumber_EndFlag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UploadInputVoiceResponse__storage_, endFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "text",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = UploadInputVoiceResponse_FieldNumber_Text,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UploadInputVoiceResponse__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UploadInputVoiceResponse class]
                                     rootClass:[MmvoiceaddrRoot class]
                                          file:MmvoiceaddrRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UploadInputVoiceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002G\000\003D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
