// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmemotion.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mmemotion.pbobjc.h"
#import "Mmbuiltintype.pbobjc.h"
#import "Mmbase.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmemotionRoot

@implementation MmemotionRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MmemotionRoot_FileDescriptor

static GPBFileDescriptor *MmemotionRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"micromsg"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - EmotionCDNUrl

@implementation EmotionCDNUrl

@dynamic hasURL, URL;
@dynamic hasAesKey, aesKey;
@dynamic hasFileSize, fileSize;

typedef struct EmotionCDNUrl__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fileSize;
  NSString *URL;
  NSString *aesKey;
} EmotionCDNUrl__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionCDNUrl_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionCDNUrl__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aesKey",
        .dataTypeSpecific.className = NULL,
        .number = EmotionCDNUrl_FieldNumber_AesKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmotionCDNUrl__storage_, aesKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.className = NULL,
        .number = EmotionCDNUrl_FieldNumber_FileSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EmotionCDNUrl__storage_, fileSize),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionCDNUrl class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionCDNUrl__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\001!!\000\002F\000\003H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionSummary

@implementation EmotionSummary

@dynamic hasProductId, productId;
@dynamic hasIconURL, iconURL;
@dynamic hasPackName, packName;
@dynamic hasPackDesc, packDesc;
@dynamic hasPackAuthInfo, packAuthInfo;
@dynamic hasPackPrice, packPrice;
@dynamic hasPackType, packType;
@dynamic hasPackFlag, packFlag;
@dynamic hasCoverURL, coverURL;
@dynamic hasPackExpire, packExpire;
@dynamic hasPackCopyright, packCopyright;
@dynamic hasTimestamp, timestamp;
@dynamic hasPanelURL, panelURL;
@dynamic hasPriceNum, priceNum;
@dynamic hasPriceType, priceType;
@dynamic hasSendInfo, sendInfo;
@dynamic hasTimeLimitStr, timeLimitStr;
@dynamic hasIntroduce, introduce;
@dynamic hasTagUri, tagUri;

typedef struct EmotionSummary__storage_ {
  uint32_t _has_storage_[1];
  uint32_t packType;
  uint32_t packFlag;
  uint32_t packExpire;
  uint32_t timestamp;
  NSString *productId;
  NSString *iconURL;
  NSString *packName;
  NSString *packDesc;
  NSString *packAuthInfo;
  NSString *packPrice;
  NSString *coverURL;
  NSString *packCopyright;
  NSString *panelURL;
  NSString *priceNum;
  NSString *priceType;
  NSString *sendInfo;
  NSString *timeLimitStr;
  NSString *introduce;
  NSString *tagUri;
} EmotionSummary__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_ProductId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iconURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_IconURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, iconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packName",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_PackName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, packName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packDesc",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_PackDesc,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, packDesc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packAuthInfo",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_PackAuthInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, packAuthInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packPrice",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_PackPrice,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, packPrice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packType",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_PackType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, packType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "packFlag",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_PackFlag,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, packFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "coverURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_CoverURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, coverURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packExpire",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_PackExpire,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, packExpire),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "packCopyright",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_PackCopyright,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, packCopyright),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_Timestamp,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "panelURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_PanelURL,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, panelURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priceNum",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_PriceNum,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, priceNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priceType",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_PriceType,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, priceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sendInfo",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_SendInfo,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, sendInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeLimitStr",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_TimeLimitStr,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, timeLimitStr),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "introduce",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_Introduce,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, introduce),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tagUri",
        .dataTypeSpecific.className = NULL,
        .number = EmotionSummary_FieldNumber_TagUri,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(EmotionSummary__storage_, tagUri),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionSummary class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionSummary__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\023\001HA\000\002E!!\000\003H\000\004H\000\005L\000\006I\000\007H\000\010H\000\tF!!\000\nJ\000\013M\000\014"
        "I\000\rF!!\000\016H\000\017I\000\020H\000\021L\000\022I\000\023F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PackThumbExt

@implementation PackThumbExt

@dynamic hasPreviewURL, previewURL;
@dynamic hasDesc, desc;

typedef struct PackThumbExt__storage_ {
  uint32_t _has_storage_[1];
  NSString *previewURL;
  NSString *desc;
} PackThumbExt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "previewURL",
        .dataTypeSpecific.className = NULL,
        .number = PackThumbExt_FieldNumber_PreviewURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PackThumbExt__storage_, previewURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = PackThumbExt_FieldNumber_Desc,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PackThumbExt__storage_, desc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PackThumbExt class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PackThumbExt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H!!\000\002D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionDetail

@implementation EmotionDetail

@dynamic hasProductId, productId;
@dynamic hasIconURL, iconURL;
@dynamic hasPackName, packName;
@dynamic hasPackDesc, packDesc;
@dynamic hasPackAuthInfo, packAuthInfo;
@dynamic hasPackPrice, packPrice;
@dynamic hasPackType, packType;
@dynamic hasPackFlag, packFlag;
@dynamic hasPackThumbCnt, packThumbCnt;
@dynamic packThumbListArray, packThumbListArray_Count;
@dynamic hasCoverURL, coverURL;
@dynamic hasPackExpire, packExpire;
@dynamic hasPackCopyright, packCopyright;
@dynamic hasPriceNum, priceNum;
@dynamic hasPriceType, priceType;
@dynamic hasPanelURL, panelURL;
@dynamic hasConsumeProductId, consumeProductId;
@dynamic hasThumbExtCount, thumbExtCount;
@dynamic thumbExtListArray, thumbExtListArray_Count;
@dynamic hasVersion, version;
@dynamic hasTimeLimitStr, timeLimitStr;
@dynamic hasShareDesc, shareDesc;
@dynamic hasOldRedirectURL, oldRedirectURL;

typedef struct EmotionDetail__storage_ {
  uint32_t _has_storage_[1];
  uint32_t packType;
  uint32_t packFlag;
  uint32_t packThumbCnt;
  uint32_t packExpire;
  uint32_t thumbExtCount;
  int32_t version;
  NSString *productId;
  NSString *iconURL;
  NSString *packName;
  NSString *packDesc;
  NSString *packAuthInfo;
  NSString *packPrice;
  NSMutableArray *packThumbListArray;
  NSString *coverURL;
  NSString *packCopyright;
  NSString *priceNum;
  NSString *priceType;
  NSString *panelURL;
  NSString *consumeProductId;
  NSMutableArray *thumbExtListArray;
  NSString *timeLimitStr;
  NSString *shareDesc;
  NSString *oldRedirectURL;
} EmotionDetail__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_ProductId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iconURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_IconURL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, iconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packName",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_PackName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, packName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packDesc",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_PackDesc,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, packDesc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packAuthInfo",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_PackAuthInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, packAuthInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packPrice",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_PackPrice,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, packPrice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packType",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_PackType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, packType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "packFlag",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_PackFlag,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, packFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "packThumbCnt",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_PackThumbCnt,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, packThumbCnt),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "packThumbListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = EmotionDetail_FieldNumber_PackThumbListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, packThumbListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "coverURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_CoverURL,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, coverURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packExpire",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_PackExpire,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, packExpire),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "packCopyright",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_PackCopyright,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, packCopyright),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priceNum",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_PriceNum,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, priceNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "priceType",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_PriceType,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, priceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "panelURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_PanelURL,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, panelURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "consumeProductId",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_ConsumeProductId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, consumeProductId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "thumbExtCount",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_ThumbExtCount,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, thumbExtCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "thumbExtListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PackThumbExt),
        .number = EmotionDetail_FieldNumber_ThumbExtListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, thumbExtListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_Version,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeLimitStr",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_TimeLimitStr,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, timeLimitStr),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shareDesc",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_ShareDesc,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, shareDesc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "oldRedirectURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDetail_FieldNumber_OldRedirectURL,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(EmotionDetail__storage_, oldRedirectURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionDetail class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionDetail__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\027\001HA\000\002E!!\000\003H\000\004H\000\005L\000\006I\000\007H\000\010H\000\tL\000\n\000PackThu"
        "mbList\000\013F!!\000\014J\000\rM\000\016H\000\017I\000\020F!!\000\021OA\000\022M\000\023\000Th"
        "umbExtList\000\024G\000\025L\000\026I\000\027L!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionBannerImg

@implementation EmotionBannerImg

@dynamic hasImgURL, imgURL;
@dynamic hasWidth, width;
@dynamic hasHeight, height;
@dynamic hasStripURL, stripURL;

typedef struct EmotionBannerImg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t width;
  uint32_t height;
  NSString *imgURL;
  NSString *stripURL;
} EmotionBannerImg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imgURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionBannerImg_FieldNumber_ImgURL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionBannerImg__storage_, imgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "width",
        .dataTypeSpecific.className = NULL,
        .number = EmotionBannerImg_FieldNumber_Width,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmotionBannerImg__storage_, width),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "height",
        .dataTypeSpecific.className = NULL,
        .number = EmotionBannerImg_FieldNumber_Height,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EmotionBannerImg__storage_, height),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "stripURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionBannerImg_FieldNumber_StripURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EmotionBannerImg__storage_, stripURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionBannerImg class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionBannerImg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001D!!\000\002E\000\003F\000\004F!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionBanner

@implementation EmotionBanner

@dynamic hasBannerSummary, bannerSummary;
@dynamic hasBannerImg, bannerImg;

typedef struct EmotionBanner__storage_ {
  uint32_t _has_storage_[1];
  EmotionSummary *bannerSummary;
  EmotionBannerImg *bannerImg;
} EmotionBanner__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bannerSummary",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionSummary),
        .number = EmotionBanner_FieldNumber_BannerSummary,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionBanner__storage_, bannerSummary),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bannerImg",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionBannerImg),
        .number = EmotionBanner_FieldNumber_BannerImg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmotionBanner__storage_, bannerImg),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionBanner class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionBanner__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001M\000\002I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionCell

@implementation EmotionCell

@dynamic hasCellTitle, cellTitle;
@dynamic hasReqType, reqType;
@dynamic hasPosition, position;
@dynamic hasIconURL, iconURL;
@dynamic hasTagURL, tagURL;

typedef struct EmotionCell__storage_ {
  uint32_t _has_storage_[1];
  uint32_t reqType;
  uint32_t position;
  NSString *cellTitle;
  NSString *iconURL;
  NSString *tagURL;
} EmotionCell__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cellTitle",
        .dataTypeSpecific.className = NULL,
        .number = EmotionCell_FieldNumber_CellTitle,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionCell__storage_, cellTitle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reqType",
        .dataTypeSpecific.className = NULL,
        .number = EmotionCell_FieldNumber_ReqType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmotionCell__storage_, reqType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "position",
        .dataTypeSpecific.className = NULL,
        .number = EmotionCell_FieldNumber_Position,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EmotionCell__storage_, position),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "iconURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionCell_FieldNumber_IconURL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EmotionCell__storage_, iconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tagURL",
        .dataTypeSpecific.className = NULL,
        .number = EmotionCell_FieldNumber_TagURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EmotionCell__storage_, tagURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionCell class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionCell__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001I\000\002G\000\003H\000\004E!!\000\005D!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEmotionListRequest

@implementation GetEmotionListRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasReqBuf, reqBuf;
@dynamic hasReqType, reqType;
@dynamic hasScene, scene;

typedef struct GetEmotionListRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t reqType;
  uint32_t scene;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *reqBuf;
} GetEmotionListRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetEmotionListRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEmotionListRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reqBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetEmotionListRequest_FieldNumber_ReqBuf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetEmotionListRequest__storage_, reqBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reqType",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionListRequest_FieldNumber_ReqType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetEmotionListRequest__storage_, reqType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionListRequest_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetEmotionListRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEmotionListRequest class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEmotionListRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002F\000\003G\000\004E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEmotionListResponse

@implementation GetEmotionListResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasReqBuf, reqBuf;
@dynamic hasEmotionCount, emotionCount;
@dynamic emotionListArray, emotionListArray_Count;
@dynamic hasBanner, banner;
@dynamic hasNewBannerCount, newBannerCount;
@dynamic newBannerListArray, newBannerListArray_Count;
@dynamic hasCellCount, cellCount;
@dynamic cellListArray, cellListArray_Count;

typedef struct GetEmotionListResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t emotionCount;
  uint32_t newBannerCount;
  uint32_t cellCount;
  BaseResponse *baseResponse;
  SKBuiltinBuffer_t *reqBuf;
  NSMutableArray *emotionListArray;
  EmotionBanner *banner;
  NSMutableArray *newBannerListArray;
  NSMutableArray *cellListArray;
} GetEmotionListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetEmotionListResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEmotionListResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reqBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetEmotionListResponse_FieldNumber_ReqBuf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetEmotionListResponse__storage_, reqBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "emotionCount",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionListResponse_FieldNumber_EmotionCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetEmotionListResponse__storage_, emotionCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "emotionListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionSummary),
        .number = GetEmotionListResponse_FieldNumber_EmotionListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetEmotionListResponse__storage_, emotionListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "banner",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionBanner),
        .number = GetEmotionListResponse_FieldNumber_Banner,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetEmotionListResponse__storage_, banner),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newBannerCount",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionListResponse_FieldNumber_NewBannerCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetEmotionListResponse__storage_, newBannerCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "newBannerListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionBanner),
        .number = GetEmotionListResponse_FieldNumber_NewBannerListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetEmotionListResponse__storage_, newBannerListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cellCount",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionListResponse_FieldNumber_CellCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetEmotionListResponse__storage_, cellCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cellListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionCell),
        .number = GetEmotionListResponse_FieldNumber_CellListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetEmotionListResponse__storage_, cellListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEmotionListResponse class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEmotionListResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001L\000\002F\000\003L\000\004\000EmotionList\000\005F\000\006N\000\007\000NewBanne"
        "rList\000\010I\000\t\000CellList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEmotionDetailRequest

@implementation GetEmotionDetailRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasProductId, productId;
@dynamic hasScene, scene;
@dynamic hasVersion, version;

typedef struct GetEmotionDetailRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t scene;
  int32_t version;
  BaseRequest *baseRequest;
  NSString *productId;
} GetEmotionDetailRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetEmotionDetailRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEmotionDetailRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionDetailRequest_FieldNumber_ProductId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetEmotionDetailRequest__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionDetailRequest_FieldNumber_Scene,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetEmotionDetailRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionDetailRequest_FieldNumber_Version,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetEmotionDetailRequest__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEmotionDetailRequest class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEmotionDetailRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002HA\000\003E\000\004G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEmotionDetailResponse

@implementation GetEmotionDetailResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasEmotionDetail, emotionDetail;

typedef struct GetEmotionDetailResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  EmotionDetail *emotionDetail;
} GetEmotionDetailResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetEmotionDetailResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEmotionDetailResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "emotionDetail",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionDetail),
        .number = GetEmotionDetailResponse_FieldNumber_EmotionDetail,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetEmotionDetailResponse__storage_, emotionDetail),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEmotionDetailResponse class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEmotionDetailResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002M\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyPurchaseRequest

@implementation VerifyPurchaseRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasReceipt, receipt;
@dynamic hasProductId, productId;
@dynamic hasVerifyType, verifyType;
@dynamic hasPayType, payType;
@dynamic hasPrice, price;
@dynamic hasCurrencyType, currencyType;
@dynamic hasBillNo, billNo;
@dynamic hasPayTime, payTime;
@dynamic hasReceiptSig, receiptSig;
@dynamic hasQuantity, quantity;

typedef struct VerifyPurchaseRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t verifyType;
  uint32_t payType;
  uint32_t payTime;
  uint32_t quantity;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *receipt;
  NSString *productId;
  NSString *price;
  NSString *currencyType;
  NSString *billNo;
  NSString *receiptSig;
} VerifyPurchaseRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = VerifyPurchaseRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "receipt",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = VerifyPurchaseRequest_FieldNumber_Receipt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, receipt),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPurchaseRequest_FieldNumber_ProductId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyType",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPurchaseRequest_FieldNumber_VerifyType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, verifyType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "payType",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPurchaseRequest_FieldNumber_PayType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, payType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPurchaseRequest_FieldNumber_Price,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, price),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currencyType",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPurchaseRequest_FieldNumber_CurrencyType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, currencyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "billNo",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPurchaseRequest_FieldNumber_BillNo,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, billNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payTime",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPurchaseRequest_FieldNumber_PayTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, payTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "receiptSig",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPurchaseRequest_FieldNumber_ReceiptSig,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, receiptSig),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "quantity",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPurchaseRequest_FieldNumber_Quantity,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(VerifyPurchaseRequest__storage_, quantity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyPurchaseRequest class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyPurchaseRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\013\001K\000\002G\000\003HA\000\004J\000\005G\000\006E\000\007L\000\010F\000\tG\000\nJ\000\013H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyPurchaseResponse

@implementation VerifyPurchaseResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasSeriesId, seriesId;
@dynamic hasBizType, bizType;

typedef struct VerifyPurchaseResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t bizType;
  BaseResponse *baseResponse;
  NSString *seriesId;
} VerifyPurchaseResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = VerifyPurchaseResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyPurchaseResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "seriesId",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPurchaseResponse_FieldNumber_SeriesId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyPurchaseResponse__storage_, seriesId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bizType",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPurchaseResponse_FieldNumber_BizType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VerifyPurchaseResponse__storage_, bizType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyPurchaseResponse class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyPurchaseResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002GA\000\003G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModEmotionPackRequest

@implementation ModEmotionPackRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasProductId, productId;
@dynamic hasOpCode, opCode;

typedef struct ModEmotionPackRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opCode;
  BaseRequest *baseRequest;
  NSString *productId;
} ModEmotionPackRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ModEmotionPackRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModEmotionPackRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = ModEmotionPackRequest_FieldNumber_ProductId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModEmotionPackRequest__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opCode",
        .dataTypeSpecific.className = NULL,
        .number = ModEmotionPackRequest_FieldNumber_OpCode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModEmotionPackRequest__storage_, opCode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModEmotionPackRequest class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModEmotionPackRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002HA\000\003F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModEmotionPackResponse

@implementation ModEmotionPackResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct ModEmotionPackResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} ModEmotionPackResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ModEmotionPackResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModEmotionPackResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModEmotionPackResponse class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModEmotionPackResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PreparePurchaseRequest

@implementation PreparePurchaseRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasProductId, productId;
@dynamic hasPrice, price;
@dynamic hasCurrencyType, currencyType;
@dynamic hasPayType, payType;
@dynamic hasExtInfo, extInfo;
@dynamic hasQuantity, quantity;

typedef struct PreparePurchaseRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t payType;
  uint32_t quantity;
  BaseRequest *baseRequest;
  NSString *productId;
  NSString *price;
  NSString *currencyType;
  NSString *extInfo;
} PreparePurchaseRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = PreparePurchaseRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PreparePurchaseRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = PreparePurchaseRequest_FieldNumber_ProductId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PreparePurchaseRequest__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = PreparePurchaseRequest_FieldNumber_Price,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PreparePurchaseRequest__storage_, price),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currencyType",
        .dataTypeSpecific.className = NULL,
        .number = PreparePurchaseRequest_FieldNumber_CurrencyType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PreparePurchaseRequest__storage_, currencyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payType",
        .dataTypeSpecific.className = NULL,
        .number = PreparePurchaseRequest_FieldNumber_PayType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PreparePurchaseRequest__storage_, payType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extInfo",
        .dataTypeSpecific.className = NULL,
        .number = PreparePurchaseRequest_FieldNumber_ExtInfo,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PreparePurchaseRequest__storage_, extInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "quantity",
        .dataTypeSpecific.className = NULL,
        .number = PreparePurchaseRequest_FieldNumber_Quantity,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PreparePurchaseRequest__storage_, quantity),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PreparePurchaseRequest class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PreparePurchaseRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001K\000\002HA\000\003E\000\004L\000\005G\000\007G\000\010H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PreparePurchaseResponse

@implementation PreparePurchaseResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasBillNo, billNo;
@dynamic hasTradeToken4TenPay, tradeToken4TenPay;
@dynamic hasPartner4TenPay, partner4TenPay;
@dynamic hasSign4TenPay, sign4TenPay;

typedef struct PreparePurchaseResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *billNo;
  NSString *tradeToken4TenPay;
  NSString *partner4TenPay;
  NSString *sign4TenPay;
} PreparePurchaseResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = PreparePurchaseResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PreparePurchaseResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "billNo",
        .dataTypeSpecific.className = NULL,
        .number = PreparePurchaseResponse_FieldNumber_BillNo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PreparePurchaseResponse__storage_, billNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tradeToken4TenPay",
        .dataTypeSpecific.className = NULL,
        .number = PreparePurchaseResponse_FieldNumber_TradeToken4TenPay,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PreparePurchaseResponse__storage_, tradeToken4TenPay),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "partner4TenPay",
        .dataTypeSpecific.className = NULL,
        .number = PreparePurchaseResponse_FieldNumber_Partner4TenPay,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PreparePurchaseResponse__storage_, partner4TenPay),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign4TenPay",
        .dataTypeSpecific.className = NULL,
        .number = PreparePurchaseResponse_FieldNumber_Sign4TenPay,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PreparePurchaseResponse__storage_, sign4TenPay),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PreparePurchaseResponse class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PreparePurchaseResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001L\000\002F\000\003Q\000\004N\000\005K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExchangeEmotionPackRequest

@implementation ExchangeEmotionPackRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasProductId, productId;
@dynamic hasSeriesId, seriesId;

typedef struct ExchangeEmotionPackRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *productId;
  NSString *seriesId;
} ExchangeEmotionPackRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ExchangeEmotionPackRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExchangeEmotionPackRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = ExchangeEmotionPackRequest_FieldNumber_ProductId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExchangeEmotionPackRequest__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "seriesId",
        .dataTypeSpecific.className = NULL,
        .number = ExchangeEmotionPackRequest_FieldNumber_SeriesId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExchangeEmotionPackRequest__storage_, seriesId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExchangeEmotionPackRequest class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExchangeEmotionPackRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002HA\000\003GA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExchangeEmotionPackResponse

@implementation ExchangeEmotionPackResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasDownloadInfo, downloadInfo;

typedef struct ExchangeEmotionPackResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  EmotionCDNUrl *downloadInfo;
} ExchangeEmotionPackResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ExchangeEmotionPackResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExchangeEmotionPackResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "downloadInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionCDNUrl),
        .number = ExchangeEmotionPackResponse_FieldNumber_DownloadInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExchangeEmotionPackResponse__storage_, downloadInfo),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExchangeEmotionPackResponse class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExchangeEmotionPackResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CancelPurchaseRequest

@implementation CancelPurchaseRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasProductId, productId;
@dynamic hasVerifyType, verifyType;
@dynamic hasPayType, payType;
@dynamic hasPrice, price;
@dynamic hasCurrencyType, currencyType;
@dynamic hasBillNo, billNo;
@dynamic hasPayTime, payTime;
@dynamic hasErrorCode, errorCode;
@dynamic hasErrorDescription, errorDescription;

typedef struct CancelPurchaseRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t verifyType;
  uint32_t payType;
  uint32_t payTime;
  int32_t errorCode;
  BaseRequest *baseRequest;
  NSString *productId;
  NSString *price;
  NSString *currencyType;
  NSString *billNo;
  NSString *errorDescription;
} CancelPurchaseRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = CancelPurchaseRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CancelPurchaseRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = CancelPurchaseRequest_FieldNumber_ProductId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CancelPurchaseRequest__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyType",
        .dataTypeSpecific.className = NULL,
        .number = CancelPurchaseRequest_FieldNumber_VerifyType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CancelPurchaseRequest__storage_, verifyType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "payType",
        .dataTypeSpecific.className = NULL,
        .number = CancelPurchaseRequest_FieldNumber_PayType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CancelPurchaseRequest__storage_, payType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "price",
        .dataTypeSpecific.className = NULL,
        .number = CancelPurchaseRequest_FieldNumber_Price,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CancelPurchaseRequest__storage_, price),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currencyType",
        .dataTypeSpecific.className = NULL,
        .number = CancelPurchaseRequest_FieldNumber_CurrencyType,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CancelPurchaseRequest__storage_, currencyType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "billNo",
        .dataTypeSpecific.className = NULL,
        .number = CancelPurchaseRequest_FieldNumber_BillNo,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CancelPurchaseRequest__storage_, billNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payTime",
        .dataTypeSpecific.className = NULL,
        .number = CancelPurchaseRequest_FieldNumber_PayTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(CancelPurchaseRequest__storage_, payTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "errorCode",
        .dataTypeSpecific.className = NULL,
        .number = CancelPurchaseRequest_FieldNumber_ErrorCode,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(CancelPurchaseRequest__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "errorDescription",
        .dataTypeSpecific.className = NULL,
        .number = CancelPurchaseRequest_FieldNumber_ErrorDescription,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(CancelPurchaseRequest__storage_, errorDescription),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CancelPurchaseRequest class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CancelPurchaseRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\001K\000\002HA\000\003J\000\004G\000\005E\000\006L\000\007F\000\010G\000\tI\000\nP\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CancelPurchaseResponse

@implementation CancelPurchaseResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct CancelPurchaseResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} CancelPurchaseResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = CancelPurchaseResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CancelPurchaseResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CancelPurchaseResponse class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CancelPurchaseResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionMember

@implementation EmotionMember

@dynamic hasUserName, userName;

typedef struct EmotionMember__storage_ {
  uint32_t _has_storage_[1];
  NSString *userName;
} EmotionMember__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = EmotionMember_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionMember__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionMember class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionMember__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MemberStatus

@implementation MemberStatus

@dynamic hasUserName, userName;
@dynamic hasStatus, status;

typedef struct MemberStatus__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  NSString *userName;
} MemberStatus__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = MemberStatus_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MemberStatus__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = MemberStatus_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MemberStatus__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MemberStatus class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MemberStatus__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyEmotionPresentationRequest

@implementation VerifyEmotionPresentationRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasProductId, productId;
@dynamic hasMemberCount, memberCount;
@dynamic memberListArray, memberListArray_Count;

typedef struct VerifyEmotionPresentationRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t memberCount;
  BaseRequest *baseRequest;
  NSString *productId;
  NSMutableArray *memberListArray;
} VerifyEmotionPresentationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = VerifyEmotionPresentationRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyEmotionPresentationRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = VerifyEmotionPresentationRequest_FieldNumber_ProductId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyEmotionPresentationRequest__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.className = NULL,
        .number = VerifyEmotionPresentationRequest_FieldNumber_MemberCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VerifyEmotionPresentationRequest__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "memberListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionMember),
        .number = VerifyEmotionPresentationRequest_FieldNumber_MemberListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VerifyEmotionPresentationRequest__storage_, memberListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyEmotionPresentationRequest class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyEmotionPresentationRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002HA\000\003K\000\004\000MemberList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyEmotionPresentationResponse

@implementation VerifyEmotionPresentationResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasMemberCount, memberCount;
@dynamic statusListArray, statusListArray_Count;

typedef struct VerifyEmotionPresentationResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t memberCount;
  BaseResponse *baseResponse;
  NSMutableArray *statusListArray;
} VerifyEmotionPresentationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = VerifyEmotionPresentationResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyEmotionPresentationResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "memberCount",
        .dataTypeSpecific.className = NULL,
        .number = VerifyEmotionPresentationResponse_FieldNumber_MemberCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyEmotionPresentationResponse__storage_, memberCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "statusListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MemberStatus),
        .number = VerifyEmotionPresentationResponse_FieldNumber_StatusListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(VerifyEmotionPresentationResponse__storage_, statusListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyEmotionPresentationResponse class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyEmotionPresentationResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002K\000\003\000StatusList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LangDesc

@implementation LangDesc

@dynamic hasLang, lang;
@dynamic hasDesc, desc;

typedef struct LangDesc__storage_ {
  uint32_t _has_storage_[1];
  NSString *lang;
  NSString *desc;
} LangDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lang",
        .dataTypeSpecific.className = NULL,
        .number = LangDesc_FieldNumber_Lang,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LangDesc__storage_, lang),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "desc",
        .dataTypeSpecific.className = NULL,
        .number = LangDesc_FieldNumber_Desc,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LangDesc__storage_, desc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LangDesc class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LangDesc__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001D\000\002D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmotionDesc

@implementation EmotionDesc

@dynamic hasMd5, md5;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct EmotionDesc__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSString *md5;
  NSMutableArray *listArray;
} EmotionDesc__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "md5",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDesc_FieldNumber_Md5,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmotionDesc__storage_, md5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = EmotionDesc_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmotionDesc__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LangDesc),
        .number = EmotionDesc_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(EmotionDesc__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmotionDesc class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmotionDesc__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001C\000\002E\000\003\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEmotionDescRequest

@implementation GetEmotionDescRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasProductId, productId;

typedef struct GetEmotionDescRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *productId;
} GetEmotionDescRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetEmotionDescRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEmotionDescRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionDescRequest_FieldNumber_ProductId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetEmotionDescRequest__storage_, productId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEmotionDescRequest class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEmotionDescRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002HA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetEmotionDescResponse

@implementation GetEmotionDescResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;
@dynamic hasClickFlag, clickFlag;
@dynamic hasButtonDesc, buttonDesc;
@dynamic hasDownLoadFlag, downLoadFlag;

typedef struct GetEmotionDescResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  uint32_t clickFlag;
  uint32_t downLoadFlag;
  BaseResponse *baseResponse;
  NSMutableArray *listArray;
  NSString *buttonDesc;
} GetEmotionDescResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetEmotionDescResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetEmotionDescResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionDescResponse_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetEmotionDescResponse__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(EmotionDesc),
        .number = GetEmotionDescResponse_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetEmotionDescResponse__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clickFlag",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionDescResponse_FieldNumber_ClickFlag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetEmotionDescResponse__storage_, clickFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "buttonDesc",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionDescResponse_FieldNumber_ButtonDesc,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetEmotionDescResponse__storage_, buttonDesc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "downLoadFlag",
        .dataTypeSpecific.className = NULL,
        .number = GetEmotionDescResponse_FieldNumber_DownLoadFlag,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetEmotionDescResponse__storage_, downLoadFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetEmotionDescResponse class]
                                     rootClass:[MmemotionRoot class]
                                          file:MmemotionRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetEmotionDescResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001L\000\002E\000\003\000List\000\004I\000\005J\000\006L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
