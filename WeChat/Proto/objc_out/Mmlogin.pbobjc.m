// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmlogin.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mmlogin.pbobjc.h"
#import "Mmbuiltintype.pbobjc.h"
#import "Mmbase.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmloginRoot

@implementation MmloginRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MmloginRoot_FileDescriptor

static GPBFileDescriptor *MmloginRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"micromsg"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - ECDHKey

@implementation ECDHKey

@dynamic hasNid, nid;
@dynamic hasKey, key;

typedef struct ECDHKey__storage_ {
  uint32_t _has_storage_[1];
  int32_t nid;
  SKBuiltinBuffer_t *key;
} ECDHKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nid",
        .dataTypeSpecific.className = NULL,
        .number = ECDHKey_FieldNumber_Nid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ECDHKey__storage_, nid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ECDHKey_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ECDHKey__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ECDHKey class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ECDHKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001C\000\002C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewRegRequest

@implementation NewRegRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasPwd, pwd;
@dynamic hasNickName, nickName;
@dynamic hasBindUin, bindUin;
@dynamic hasBindEmail, bindEmail;
@dynamic hasBindMobile, bindMobile;
@dynamic hasTicket, ticket;
@dynamic hasBuiltinIpseq, builtinIpseq;
@dynamic hasDlsrc, dlsrc;
@dynamic hasRegMode, regMode;
@dynamic hasTimeZone, timeZone;
@dynamic hasLanguage, language;
@dynamic hasForceReg, forceReg;
@dynamic hasRealCountry, realCountry;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasAlias, alias;
@dynamic hasVerifySignature, verifySignature;
@dynamic hasVerifyContent, verifyContent;
@dynamic hasHasHeadImg, hasHeadImg;
@dynamic hasSuggestRet, suggestRet;
@dynamic hasClientSeqId, clientSeqId;
@dynamic hasAdSource, adSource;
@dynamic hasAndroidId, androidId;
@dynamic hasMacAddr, macAddr;
@dynamic hasAndroidInstallRef, androidInstallRef;
@dynamic hasClientFingerprint, clientFingerprint;
@dynamic hasCliPubEcdhkey, cliPubEcdhkey;
@dynamic hasGoogleAid, googleAid;
@dynamic hasBundleId, bundleId;
@dynamic hasBioSigTicket, bioSigTicket;
@dynamic hasBioSigCheckType, bioSigCheckType;
@dynamic hasClientCheckData, clientCheckData;
@dynamic hasMobileCheckType, mobileCheckType;
@dynamic hasRegSessionId, regSessionId;
@dynamic hasPrivacyPolicyCountry, privacyPolicyCountry;

typedef struct NewRegRequest__storage_ {
  uint32_t _has_storage_[2];
  uint32_t bindUin;
  uint32_t builtinIpseq;
  uint32_t dlsrc;
  uint32_t regMode;
  uint32_t forceReg;
  uint32_t hasHeadImg;
  uint32_t suggestRet;
  uint32_t bioSigCheckType;
  uint32_t mobileCheckType;
  BaseRequest *baseRequest;
  NSString *userName;
  NSString *pwd;
  NSString *nickName;
  NSString *bindEmail;
  NSString *bindMobile;
  NSString *ticket;
  NSString *timeZone;
  NSString *language;
  NSString *realCountry;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *alias;
  NSString *verifySignature;
  NSString *verifyContent;
  NSString *clientSeqId;
  NSString *adSource;
  NSString *androidId;
  NSString *macAddr;
  NSString *androidInstallRef;
  NSString *clientFingerprint;
  ECDHKey *cliPubEcdhkey;
  NSString *googleAid;
  NSString *bundleId;
  NSString *bioSigTicket;
  NSString *clientCheckData;
  NSString *regSessionId;
  NSString *privacyPolicyCountry;
} NewRegRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = NewRegRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_Pwd,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, pwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_NickName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindUin",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_BindUin,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, bindUin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bindEmail",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_BindEmail,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, bindEmail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindMobile",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_BindMobile,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, bindMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_Ticket,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, ticket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIpseq",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_BuiltinIpseq,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, builtinIpseq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dlsrc",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_Dlsrc,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, dlsrc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "regMode",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_RegMode,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, regMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_TimeZone,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_Language,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "forceReg",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_ForceReg,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, forceReg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "realCountry",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_RealCountry,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, realCountry),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewRegRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_Alias,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, alias),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifySignature",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_VerifySignature,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, verifySignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyContent",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_VerifyContent,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, verifyContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hasHeadImg",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_HasHeadImg,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, hasHeadImg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "suggestRet",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_SuggestRet,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, suggestRet),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_ClientSeqId,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adSource",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_AdSource,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, adSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidId",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_AndroidId,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, androidId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "macAddr",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_MacAddr,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, macAddr),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "androidInstallRef",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_AndroidInstallRef,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, androidInstallRef),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientFingerprint",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_ClientFingerprint,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, clientFingerprint),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cliPubEcdhkey",
        .dataTypeSpecific.className = GPBStringifySymbol(ECDHKey),
        .number = NewRegRequest_FieldNumber_CliPubEcdhkey,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, cliPubEcdhkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "googleAid",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_GoogleAid,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, googleAid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundleId",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_BundleId,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, bundleId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bioSigTicket",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_BioSigTicket,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, bioSigTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bioSigCheckType",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_BioSigCheckType,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, bioSigCheckType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientCheckData",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_ClientCheckData,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, clientCheckData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobileCheckType",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_MobileCheckType,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, mobileCheckType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "regSessionId",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_RegSessionId,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, regSessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "privacyPolicyCountry",
        .dataTypeSpecific.className = NULL,
        .number = NewRegRequest_FieldNumber_PrivacyPolicyCountry,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(NewRegRequest__storage_, privacyPolicyCountry),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewRegRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewRegRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "$\001K\000\002H\000\003C\000\004H\000\005G\000\006I\000\007J\000\010F\000\014Hb\002\000\rc\002\000\016G\000\017H\000"
        "\020H\000\021H\000\022K\000\023N\000\024E\000\025O\000\026M\000\027J\000\030J\000\037JA\000 H\000!HA\000\"G"
        "\000#Q\000$Q\000%Gd\002\000&I\000\'GA\000)\014\000*\017\000+\017\000,\017\000-\014\000.\024\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SecAuthRegKeySect

@implementation SecAuthRegKeySect

@dynamic hasAutoAuthKey, autoAuthKey;
@dynamic hasSvrPubEcdhkey, svrPubEcdhkey;
@dynamic hasSessionKey, sessionKey;
@dynamic hasAuthResultFlag, authResultFlag;

typedef struct SecAuthRegKeySect__storage_ {
  uint32_t _has_storage_[1];
  uint32_t authResultFlag;
  SKBuiltinBuffer_t *autoAuthKey;
  ECDHKey *svrPubEcdhkey;
  SKBuiltinBuffer_t *sessionKey;
} SecAuthRegKeySect__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "autoAuthKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = SecAuthRegKeySect_FieldNumber_AutoAuthKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SecAuthRegKeySect__storage_, autoAuthKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "svrPubEcdhkey",
        .dataTypeSpecific.className = GPBStringifySymbol(ECDHKey),
        .number = SecAuthRegKeySect_FieldNumber_SvrPubEcdhkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SecAuthRegKeySect__storage_, svrPubEcdhkey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sessionKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = SecAuthRegKeySect_FieldNumber_SessionKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SecAuthRegKeySect__storage_, sessionKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authResultFlag",
        .dataTypeSpecific.className = NULL,
        .number = SecAuthRegKeySect_FieldNumber_AuthResultFlag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SecAuthRegKeySect__storage_, authResultFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SecAuthRegKeySect class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SecAuthRegKeySect__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002Gd\002\000\003J\000\004N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewRegResponse

@implementation NewRegResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasUin, uin;
@dynamic hasSessionKey, sessionKey;
@dynamic hasOfficialUserName, officialUserName;
@dynamic hasOfficialNickName, officialNickName;
@dynamic hasQqmicroBlogUserName, qqmicroBlogUserName;
@dynamic hasBindEmail, bindEmail;
@dynamic hasPushMailStatus, pushMailStatus;
@dynamic hasSendCardBitFlag, sendCardBitFlag;
@dynamic hasPushMailSettingTicket, pushMailSettingTicket;
@dynamic hasBuiltinIplist, builtinIplist;
@dynamic hasFsurl, fsurl;
@dynamic hasUserName, userName;
@dynamic hasStatus, status;
@dynamic hasNetworkControl, networkControl;
@dynamic hasReturnFlag, returnFlag;
@dynamic hasRegType, regType;
@dynamic hasAuthKey, authKey;
@dynamic hasPluginKeyList, pluginKeyList;
@dynamic hasPassword, password;
@dynamic hasProfileFlag, profileFlag;
@dynamic hasNewHostList, newHostList;
@dynamic hasAutoAuthTicket, autoAuthTicket;
@dynamic hasDnsInfo, dnsInfo;
@dynamic hasStepTicket, stepTicket;
@dynamic hasVerifySignature, verifySignature;
@dynamic hasVerifyBuff, verifyBuff;
@dynamic hasShowStyle, showStyle;
@dynamic hasSnsDnsInfo, snsDnsInfo;
@dynamic hasAppDnsInfo, appDnsInfo;
@dynamic hasSecAuthRegKeySect, secAuthRegKeySect;
@dynamic hasMmtlsControlBitFlag, mmtlsControlBitFlag;
@dynamic hasServerTime, serverTime;

typedef struct NewRegResponse__storage_ {
  uint32_t _has_storage_[2];
  uint32_t uin;
  uint32_t pushMailStatus;
  uint32_t sendCardBitFlag;
  uint32_t status;
  uint32_t returnFlag;
  uint32_t regType;
  uint32_t profileFlag;
  uint32_t mmtlsControlBitFlag;
  uint32_t serverTime;
  BaseResponse *baseResponse;
  NSString *sessionKey;
  NSString *officialUserName;
  NSString *officialNickName;
  NSString *qqmicroBlogUserName;
  NSString *bindEmail;
  NSString *pushMailSettingTicket;
  BuiltinIPList *builtinIplist;
  NSString *fsurl;
  NSString *userName;
  NetworkControl *networkControl;
  NSString *authKey;
  PluginKeyList *pluginKeyList;
  NSString *password;
  HostList *newHostList;
  NSString *autoAuthTicket;
  CDNDnsInfo *dnsInfo;
  NSString *stepTicket;
  NSString *verifySignature;
  SKBuiltinBuffer_t *verifyBuff;
  ShowStyleKey *showStyle;
  CDNDnsInfo *snsDnsInfo;
  CDNDnsInfo *appDnsInfo;
  SecAuthRegKeySect *secAuthRegKeySect;
} NewRegResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = NewRegResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_Uin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, uin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionKey",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_SessionKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, sessionKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "officialUserName",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_OfficialUserName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, officialUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "officialNickName",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_OfficialNickName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, officialNickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qqmicroBlogUserName",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_QqmicroBlogUserName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, qqmicroBlogUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindEmail",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_BindEmail,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, bindEmail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushMailStatus",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_PushMailStatus,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, pushMailStatus),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sendCardBitFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_SendCardBitFlag,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, sendCardBitFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pushMailSettingTicket",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_PushMailSettingTicket,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, pushMailSettingTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIplist",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList),
        .number = NewRegResponse_FieldNumber_BuiltinIplist,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, builtinIplist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fsurl",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_Fsurl,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, fsurl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_UserName,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_Status,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "networkControl",
        .dataTypeSpecific.className = GPBStringifySymbol(NetworkControl),
        .number = NewRegResponse_FieldNumber_NetworkControl,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, networkControl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "returnFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_ReturnFlag,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, returnFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "regType",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_RegType,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, regType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "authKey",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_AuthKey,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, authKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pluginKeyList",
        .dataTypeSpecific.className = GPBStringifySymbol(PluginKeyList),
        .number = NewRegResponse_FieldNumber_PluginKeyList,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, pluginKeyList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_Password,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, password),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "profileFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_ProfileFlag,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, profileFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "newHostList",
        .dataTypeSpecific.className = GPBStringifySymbol(HostList),
        .number = NewRegResponse_FieldNumber_NewHostList,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, newHostList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoAuthTicket",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_AutoAuthTicket,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, autoAuthTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dnsInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(CDNDnsInfo),
        .number = NewRegResponse_FieldNumber_DnsInfo,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, dnsInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stepTicket",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_StepTicket,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, stepTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifySignature",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_VerifySignature,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, verifySignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewRegResponse_FieldNumber_VerifyBuff,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, verifyBuff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "showStyle",
        .dataTypeSpecific.className = GPBStringifySymbol(ShowStyleKey),
        .number = NewRegResponse_FieldNumber_ShowStyle,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, showStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "snsDnsInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(CDNDnsInfo),
        .number = NewRegResponse_FieldNumber_SnsDnsInfo,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, snsDnsInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appDnsInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(CDNDnsInfo),
        .number = NewRegResponse_FieldNumber_AppDnsInfo,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, appDnsInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "secAuthRegKeySect",
        .dataTypeSpecific.className = GPBStringifySymbol(SecAuthRegKeySect),
        .number = NewRegResponse_FieldNumber_SecAuthRegKeySect,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, secAuthRegKeySect),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mmtlsControlBitFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_MmtlsControlBitFlag,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, mmtlsControlBitFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "serverTime",
        .dataTypeSpecific.className = NULL,
        .number = NewRegResponse_FieldNumber_ServerTime,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(NewRegResponse__storage_, serverTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewRegResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewRegResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "!\001L\000\002C\000\003J\000\004P\000\005P\000\006c\020\000\007I\000\010N\000\tO\000\nU\000\016Hb\003\000\017e\000"
        "\020H\000\021F\000\022N\000\023J\000\024G\000\025G\000\026M\000\027H\000\030K\000\031K\000\032N\000\033G\000\034J\000\035"
        "O\000\036J\000\037I\000 J\000!J\000\"Q\000#\023\000$\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetSuggestAliasRequest

@implementation GetSuggestAliasRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasRegBindName, regBindName;
@dynamic hasRegTicket, regTicket;
@dynamic hasNickName, nickName;
@dynamic hasInputAlias, inputAlias;
@dynamic hasVerifySignature, verifySignature;
@dynamic hasVerifyContent, verifyContent;
@dynamic hasRegMode, regMode;
@dynamic hasLanguage, language;
@dynamic hasClientSeqId, clientSeqId;

typedef struct GetSuggestAliasRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t regMode;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *regBindName;
  NSString *regTicket;
  NSString *nickName;
  NSString *inputAlias;
  NSString *verifySignature;
  NSString *verifyContent;
  NSString *language;
  NSString *clientSeqId;
} GetSuggestAliasRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetSuggestAliasRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetSuggestAliasRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetSuggestAliasRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetSuggestAliasRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "regBindName",
        .dataTypeSpecific.className = NULL,
        .number = GetSuggestAliasRequest_FieldNumber_RegBindName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetSuggestAliasRequest__storage_, regBindName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "regTicket",
        .dataTypeSpecific.className = NULL,
        .number = GetSuggestAliasRequest_FieldNumber_RegTicket,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetSuggestAliasRequest__storage_, regTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = GetSuggestAliasRequest_FieldNumber_NickName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetSuggestAliasRequest__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputAlias",
        .dataTypeSpecific.className = NULL,
        .number = GetSuggestAliasRequest_FieldNumber_InputAlias,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetSuggestAliasRequest__storage_, inputAlias),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifySignature",
        .dataTypeSpecific.className = NULL,
        .number = GetSuggestAliasRequest_FieldNumber_VerifySignature,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetSuggestAliasRequest__storage_, verifySignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyContent",
        .dataTypeSpecific.className = NULL,
        .number = GetSuggestAliasRequest_FieldNumber_VerifyContent,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetSuggestAliasRequest__storage_, verifyContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "regMode",
        .dataTypeSpecific.className = NULL,
        .number = GetSuggestAliasRequest_FieldNumber_RegMode,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GetSuggestAliasRequest__storage_, regMode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = GetSuggestAliasRequest_FieldNumber_Language,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(GetSuggestAliasRequest__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = GetSuggestAliasRequest_FieldNumber_ClientSeqId,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(GetSuggestAliasRequest__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetSuggestAliasRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetSuggestAliasRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\013\001K\000\002N\000\003K\000\004I\000\005H\000\006J\000\007O\000\010M\000\tG\000\nH\000\013JA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetSuggestAliasResponse

@implementation GetSuggestAliasResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;
@dynamic hasVerifySignature, verifySignature;
@dynamic hasVerifyBuff, verifyBuff;
@dynamic hasUserNameRet, userNameRet;

typedef struct GetSuggestAliasResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  int32_t userNameRet;
  BaseResponse *baseResponse;
  NSMutableArray *listArray;
  NSString *verifySignature;
  SKBuiltinBuffer_t *verifyBuff;
} GetSuggestAliasResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetSuggestAliasResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetSuggestAliasResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = GetSuggestAliasResponse_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetSuggestAliasResponse__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = GetSuggestAliasResponse_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetSuggestAliasResponse__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "verifySignature",
        .dataTypeSpecific.className = NULL,
        .number = GetSuggestAliasResponse_FieldNumber_VerifySignature,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetSuggestAliasResponse__storage_, verifySignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetSuggestAliasResponse_FieldNumber_VerifyBuff,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetSuggestAliasResponse__storage_, verifyBuff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userNameRet",
        .dataTypeSpecific.className = NULL,
        .number = GetSuggestAliasResponse_FieldNumber_UserNameRet,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetSuggestAliasResponse__storage_, userNameRet),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetSuggestAliasResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetSuggestAliasResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001L\000\002E\000\003\000List\000\004O\000\005J\000\006K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindOpMobileRequest

@implementation BindOpMobileRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasMobile, mobile;
@dynamic hasOpcode, opcode;
@dynamic hasVerifycode, verifycode;
@dynamic hasDialFlag, dialFlag;
@dynamic hasDialLang, dialLang;
@dynamic hasAuthTicket, authTicket;
@dynamic hasForceReg, forceReg;
@dynamic hasSafeDeviceName, safeDeviceName;
@dynamic hasSafeDeviceType, safeDeviceType;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasLanguage, language;
@dynamic hasInputMobileRetrys, inputMobileRetrys;
@dynamic hasAdjustRet, adjustRet;
@dynamic hasClientSeqId, clientSeqId;
@dynamic hasMobileCheckType, mobileCheckType;
@dynamic hasRegSessionId, regSessionId;
@dynamic hasSpamBuffer, spamBuffer;
@dynamic hasExtSpamInfo, extSpamInfo;

typedef struct BindOpMobileRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t opcode;
  int32_t dialFlag;
  uint32_t forceReg;
  uint32_t inputMobileRetrys;
  uint32_t adjustRet;
  int32_t mobileCheckType;
  BaseRequest *baseRequest;
  NSString *userName;
  NSString *mobile;
  NSString *verifycode;
  NSString *dialLang;
  NSString *authTicket;
  NSString *safeDeviceName;
  NSString *safeDeviceType;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *language;
  NSString *clientSeqId;
  NSString *regSessionId;
  SKBuiltinBuffer_t *spamBuffer;
  SKBuiltinBuffer_t *extSpamInfo;
} BindOpMobileRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BindOpMobileRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobile",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_Mobile,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, mobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_Opcode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "verifycode",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_Verifycode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, verifycode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dialFlag",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_DialFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, dialFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dialLang",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_DialLang,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, dialLang),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_AuthTicket,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, authTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "forceReg",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_ForceReg,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, forceReg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "safeDeviceName",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_SafeDeviceName,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, safeDeviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "safeDeviceType",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_SafeDeviceType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, safeDeviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindOpMobileRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_Language,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputMobileRetrys",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_InputMobileRetrys,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, inputMobileRetrys),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "adjustRet",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_AdjustRet,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, adjustRet),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_ClientSeqId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobileCheckType",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_MobileCheckType,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, mobileCheckType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "regSessionId",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileRequest_FieldNumber_RegSessionId,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, regSessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "spamBuffer",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindOpMobileRequest_FieldNumber_SpamBuffer,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, spamBuffer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extSpamInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindOpMobileRequest_FieldNumber_ExtSpamInfo,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(BindOpMobileRequest__storage_, extSpamInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindOpMobileRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindOpMobileRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\024\001K\000\002H\000\003F\000\004F\000\005J\000\006H\000\007H\000\010J\000\tH\000\nN\000\013N\000\014N\000\rH\000"
        "\016Q\000\017I\000\020JA\000\021\017\000\022\014\000\023\n\000\024\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindOpMobileResponse

@implementation BindOpMobileResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasTicket, ticket;
@dynamic hasSmsNo, smsNo;
@dynamic hasNeedSetPwd, needSetPwd;
@dynamic hasPwd, pwd;
@dynamic hasUsername, username;
@dynamic hasNewHostList, newHostList;
@dynamic hasBuiltinIplist, builtinIplist;
@dynamic hasNetworkControl, networkControl;
@dynamic hasAuthTicket, authTicket;
@dynamic hasSafeDevice, safeDevice;
@dynamic hasCc, cc;
@dynamic hasObsoleteItem1, obsoleteItem1;
@dynamic hasSafeDeviceList, safeDeviceList;
@dynamic hasPureMobile, pureMobile;
@dynamic hasFormatedMobile, formatedMobile;
@dynamic hasShowStyle, showStyle;
@dynamic hasMmtlsControlBitFlag, mmtlsControlBitFlag;
@dynamic hasSmsUpCode, smsUpCode;
@dynamic hasSmsUpMobile, smsUpMobile;
@dynamic hasMobileCheckType, mobileCheckType;
@dynamic hasRegSessionId, regSessionId;

typedef struct BindOpMobileResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t needSetPwd;
  uint32_t safeDevice;
  uint32_t obsoleteItem1;
  int32_t mmtlsControlBitFlag;
  int32_t mobileCheckType;
  BaseResponse *baseResponse;
  NSString *ticket;
  NSString *smsNo;
  NSString *pwd;
  NSString *username;
  HostList *newHostList;
  BuiltinIPList *builtinIplist;
  NetworkControl *networkControl;
  NSString *authTicket;
  NSString *cc;
  SafeDeviceList *safeDeviceList;
  NSString *pureMobile;
  NSString *formatedMobile;
  ShowStyleKey *showStyle;
  NSString *smsUpCode;
  NSString *smsUpMobile;
  NSString *regSessionId;
} BindOpMobileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BindOpMobileResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_Ticket,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, ticket),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smsNo",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_SmsNo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, smsNo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "needSetPwd",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_NeedSetPwd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, needSetPwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_Pwd,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, pwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_Username,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, username),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newHostList",
        .dataTypeSpecific.className = GPBStringifySymbol(HostList),
        .number = BindOpMobileResponse_FieldNumber_NewHostList,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, newHostList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "builtinIplist",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList),
        .number = BindOpMobileResponse_FieldNumber_BuiltinIplist,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, builtinIplist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkControl",
        .dataTypeSpecific.className = GPBStringifySymbol(NetworkControl),
        .number = BindOpMobileResponse_FieldNumber_NetworkControl,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, networkControl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_AuthTicket,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, authTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "safeDevice",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_SafeDevice,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, safeDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cc",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_Cc,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, cc),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "obsoleteItem1",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_ObsoleteItem1,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, obsoleteItem1),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "safeDeviceList",
        .dataTypeSpecific.className = GPBStringifySymbol(SafeDeviceList),
        .number = BindOpMobileResponse_FieldNumber_SafeDeviceList,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, safeDeviceList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pureMobile",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_PureMobile,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, pureMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "formatedMobile",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_FormatedMobile,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, formatedMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "showStyle",
        .dataTypeSpecific.className = GPBStringifySymbol(ShowStyleKey),
        .number = BindOpMobileResponse_FieldNumber_ShowStyle,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, showStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mmtlsControlBitFlag",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_MmtlsControlBitFlag,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, mmtlsControlBitFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "smsUpCode",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_SmsUpCode,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, smsUpCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "smsUpMobile",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_SmsUpMobile,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, smsUpMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobileCheckType",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_MobileCheckType,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, mobileCheckType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "regSessionId",
        .dataTypeSpecific.className = NULL,
        .number = BindOpMobileResponse_FieldNumber_RegSessionId,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(BindOpMobileResponse__storage_, regSessionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindOpMobileResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindOpMobileResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\025\001L\000\003E\000\004J\000\005C\000\006H\000\007K\000\010Hb\003\000\tN\000\nJ\000\013J\000\014b\000\rM\000\016"
        "N\000\017J\000\020N\000\021I\000\022\023\000\023\t\000\024\013\000\025\017\000\026\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmailRegRequest

@implementation EmailRegRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasOpcode, opcode;
@dynamic hasEmail, email;
@dynamic hasLanguage, language;
@dynamic hasPwd, pwd;
@dynamic hasVerifyCode, verifyCode;
@dynamic hasClientSeqId, clientSeqId;
@dynamic hasRealCountry, realCountry;
@dynamic hasVerifyScene, verifyScene;

typedef struct EmailRegRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opcode;
  uint32_t verifyScene;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *email;
  NSString *language;
  NSString *pwd;
  NSString *verifyCode;
  NSString *clientSeqId;
  NSString *realCountry;
} EmailRegRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = EmailRegRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmailRegRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = EmailRegRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmailRegRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = EmailRegRequest_FieldNumber_Opcode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EmailRegRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "email",
        .dataTypeSpecific.className = NULL,
        .number = EmailRegRequest_FieldNumber_Email,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EmailRegRequest__storage_, email),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = EmailRegRequest_FieldNumber_Language,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EmailRegRequest__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = EmailRegRequest_FieldNumber_Pwd,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EmailRegRequest__storage_, pwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyCode",
        .dataTypeSpecific.className = NULL,
        .number = EmailRegRequest_FieldNumber_VerifyCode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(EmailRegRequest__storage_, verifyCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = EmailRegRequest_FieldNumber_ClientSeqId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(EmailRegRequest__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realCountry",
        .dataTypeSpecific.className = NULL,
        .number = EmailRegRequest_FieldNumber_RealCountry,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(EmailRegRequest__storage_, realCountry),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyScene",
        .dataTypeSpecific.className = NULL,
        .number = EmailRegRequest_FieldNumber_VerifyScene,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(EmailRegRequest__storage_, verifyScene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmailRegRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmailRegRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\001K\000\002N\000\003F\000\004E\000\005H\000\006C\000\007J\000\010JA\000\tK\000\nK\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EmailRegResponse

@implementation EmailRegResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasTicket, ticket;
@dynamic hasBuiltinIplist, builtinIplist;
@dynamic hasNewHostList, newHostList;
@dynamic hasShowStyle, showStyle;
@dynamic hasNetworkControl, networkControl;

typedef struct EmailRegResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *ticket;
  BuiltinIPList *builtinIplist;
  HostList *newHostList;
  ShowStyleKey *showStyle;
  NetworkControl *networkControl;
} EmailRegResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = EmailRegResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EmailRegResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = EmailRegResponse_FieldNumber_Ticket,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EmailRegResponse__storage_, ticket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIplist",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList),
        .number = EmailRegResponse_FieldNumber_BuiltinIplist,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EmailRegResponse__storage_, builtinIplist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newHostList",
        .dataTypeSpecific.className = GPBStringifySymbol(HostList),
        .number = EmailRegResponse_FieldNumber_NewHostList,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EmailRegResponse__storage_, newHostList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "showStyle",
        .dataTypeSpecific.className = GPBStringifySymbol(ShowStyleKey),
        .number = EmailRegResponse_FieldNumber_ShowStyle,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EmailRegResponse__storage_, showStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkControl",
        .dataTypeSpecific.className = GPBStringifySymbol(NetworkControl),
        .number = EmailRegResponse_FieldNumber_NetworkControl,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(EmailRegResponse__storage_, networkControl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EmailRegResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EmailRegResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001L\000\002F\000\003Hb\003\000\004K\000\005I\000\006N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetEmailPwdRequest

@implementation SetEmailPwdRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasPwd, pwd;
@dynamic hasTicket, ticket;

typedef struct SetEmailPwdRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *pwd;
  NSString *ticket;
} SetEmailPwdRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = SetEmailPwdRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetEmailPwdRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = SetEmailPwdRequest_FieldNumber_Pwd,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetEmailPwdRequest__storage_, pwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = SetEmailPwdRequest_FieldNumber_Ticket,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SetEmailPwdRequest__storage_, ticket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetEmailPwdRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetEmailPwdRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002C\000\003F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetEmailPwdResponse

@implementation SetEmailPwdResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct SetEmailPwdResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} SetEmailPwdResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = SetEmailPwdResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetEmailPwdResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetEmailPwdResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetEmailPwdResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateSafeDeviceRequest

@implementation UpdateSafeDeviceRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUuid, uuid;
@dynamic hasName, name;
@dynamic hasDeviceType, deviceType;

typedef struct UpdateSafeDeviceRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *uuid;
  NSString *name;
  NSString *deviceType;
} UpdateSafeDeviceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = UpdateSafeDeviceRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateSafeDeviceRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = UpdateSafeDeviceRequest_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateSafeDeviceRequest__storage_, uuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = UpdateSafeDeviceRequest_FieldNumber_Name,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UpdateSafeDeviceRequest__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = UpdateSafeDeviceRequest_FieldNumber_DeviceType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UpdateSafeDeviceRequest__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateSafeDeviceRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateSafeDeviceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002D\000\003D\000\004J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UpdateSafeDeviceResponse

@implementation UpdateSafeDeviceResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasSafeDevice, safeDevice;

typedef struct UpdateSafeDeviceResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t safeDevice;
  BaseResponse *baseResponse;
} UpdateSafeDeviceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = UpdateSafeDeviceResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UpdateSafeDeviceResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "safeDevice",
        .dataTypeSpecific.className = NULL,
        .number = UpdateSafeDeviceResponse_FieldNumber_SafeDevice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UpdateSafeDeviceResponse__storage_, safeDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UpdateSafeDeviceResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UpdateSafeDeviceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelSafeDeviceRequest

@implementation DelSafeDeviceRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUuid, uuid;

typedef struct DelSafeDeviceRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *uuid;
} DelSafeDeviceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = DelSafeDeviceRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelSafeDeviceRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = DelSafeDeviceRequest_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelSafeDeviceRequest__storage_, uuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelSafeDeviceRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelSafeDeviceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelSafeDeviceResponse

@implementation DelSafeDeviceResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasSafeDevice, safeDevice;

typedef struct DelSafeDeviceResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t safeDevice;
  BaseResponse *baseResponse;
} DelSafeDeviceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = DelSafeDeviceResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelSafeDeviceResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "safeDevice",
        .dataTypeSpecific.className = NULL,
        .number = DelSafeDeviceResponse_FieldNumber_SafeDevice,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelSafeDeviceResponse__storage_, safeDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelSafeDeviceResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelSafeDeviceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindSafeMobileRequest

@implementation BindSafeMobileRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasMobile, mobile;
@dynamic hasOpcode, opcode;

typedef struct BindSafeMobileRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t opcode;
  BaseRequest *baseRequest;
  NSString *mobile;
} BindSafeMobileRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BindSafeMobileRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindSafeMobileRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "mobile",
        .dataTypeSpecific.className = NULL,
        .number = BindSafeMobileRequest_FieldNumber_Mobile,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindSafeMobileRequest__storage_, mobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = BindSafeMobileRequest_FieldNumber_Opcode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindSafeMobileRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindSafeMobileRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindSafeMobileRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002F\000\003F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindSafeMobileResponse

@implementation BindSafeMobileResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct BindSafeMobileResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} BindSafeMobileResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BindSafeMobileResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindSafeMobileResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindSafeMobileResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindSafeMobileResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindQQRequest

@implementation BindQQRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasQq, qq;
@dynamic hasPwd, pwd;
@dynamic hasPwd2, pwd2;
@dynamic hasImgSid, imgSid;
@dynamic hasImgCode, imgCode;
@dynamic hasOpcode, opcode;
@dynamic hasImgEncryptKey, imgEncryptKey;
@dynamic hasKsid, ksid;
@dynamic hasSetAsMainAcct, setAsMainAcct;
@dynamic hasSafeDeviceName, safeDeviceName;
@dynamic hasSafeDeviceType, safeDeviceType;
@dynamic hasWtloginReqBuff, wtloginReqBuff;

typedef struct BindQQRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t qq;
  uint32_t opcode;
  uint32_t setAsMainAcct;
  BaseRequest *baseRequest;
  NSString *pwd;
  NSString *pwd2;
  NSString *imgSid;
  NSString *imgCode;
  SKBuiltinString_t *imgEncryptKey;
  SKBuiltinBuffer_t *ksid;
  NSString *safeDeviceName;
  NSString *safeDeviceType;
  SKBuiltinBuffer_t *wtloginReqBuff;
} BindQQRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BindQQRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "qq",
        .dataTypeSpecific.className = NULL,
        .number = BindQQRequest_FieldNumber_Qq,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, qq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = BindQQRequest_FieldNumber_Pwd,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, pwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd2",
        .dataTypeSpecific.className = NULL,
        .number = BindQQRequest_FieldNumber_Pwd2,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, pwd2),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgSid",
        .dataTypeSpecific.className = NULL,
        .number = BindQQRequest_FieldNumber_ImgSid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, imgSid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgCode",
        .dataTypeSpecific.className = NULL,
        .number = BindQQRequest_FieldNumber_ImgCode,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, imgCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = BindQQRequest_FieldNumber_Opcode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "imgEncryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = BindQQRequest_FieldNumber_ImgEncryptKey,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, imgEncryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ksid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindQQRequest_FieldNumber_Ksid,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, ksid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setAsMainAcct",
        .dataTypeSpecific.className = NULL,
        .number = BindQQRequest_FieldNumber_SetAsMainAcct,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, setAsMainAcct),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "safeDeviceName",
        .dataTypeSpecific.className = NULL,
        .number = BindQQRequest_FieldNumber_SafeDeviceName,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, safeDeviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "safeDeviceType",
        .dataTypeSpecific.className = NULL,
        .number = BindQQRequest_FieldNumber_SafeDeviceType,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, safeDeviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wtloginReqBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindQQRequest_FieldNumber_WtloginReqBuff,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(BindQQRequest__storage_, wtloginReqBuff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindQQRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindQQRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\r\001K\000\002b\000\003C\000\004D\000\005F\000\006G\000\007c\003\000\010M\000\tb\002\000\nM\000\013N\000\014N\000\r"
        "c\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindQQResponse

@implementation BindQQResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasImgSid, imgSid;
@dynamic hasImgBuf, imgBuf;
@dynamic hasPushMailStatus, pushMailStatus;
@dynamic hasPrivateMsgStatus, privateMsgStatus;
@dynamic hasMicroBlogName, microBlogName;
@dynamic hasStatus, status;
@dynamic hasQqmailSkey, qqmailSkey;
@dynamic hasImgEncryptKey, imgEncryptKey;
@dynamic hasA2Key, a2Key;
@dynamic hasKsid, ksid;
@dynamic hasSafeDeviceList, safeDeviceList;
@dynamic hasSafeDevice, safeDevice;
@dynamic hasWtloginRspBuff, wtloginRspBuff;

typedef struct BindQQResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t pushMailStatus;
  uint32_t privateMsgStatus;
  uint32_t status;
  uint32_t safeDevice;
  BaseResponse *baseResponse;
  NSString *imgSid;
  SKBuiltinBuffer_t *imgBuf;
  NSString *microBlogName;
  NSString *qqmailSkey;
  SKBuiltinString_t *imgEncryptKey;
  SKBuiltinBuffer_t *a2Key;
  SKBuiltinBuffer_t *ksid;
  SafeDeviceList *safeDeviceList;
  SKBuiltinBuffer_t *wtloginRspBuff;
} BindQQResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BindQQResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgSid",
        .dataTypeSpecific.className = NULL,
        .number = BindQQResponse_FieldNumber_ImgSid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, imgSid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindQQResponse_FieldNumber_ImgBuf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, imgBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pushMailStatus",
        .dataTypeSpecific.className = NULL,
        .number = BindQQResponse_FieldNumber_PushMailStatus,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, pushMailStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "privateMsgStatus",
        .dataTypeSpecific.className = NULL,
        .number = BindQQResponse_FieldNumber_PrivateMsgStatus,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, privateMsgStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "microBlogName",
        .dataTypeSpecific.className = NULL,
        .number = BindQQResponse_FieldNumber_MicroBlogName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, microBlogName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = BindQQResponse_FieldNumber_Status,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "qqmailSkey",
        .dataTypeSpecific.className = NULL,
        .number = BindQQResponse_FieldNumber_QqmailSkey,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, qqmailSkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgEncryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = BindQQResponse_FieldNumber_ImgEncryptKey,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, imgEncryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "a2Key",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindQQResponse_FieldNumber_A2Key,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, a2Key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ksid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindQQResponse_FieldNumber_Ksid,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, ksid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "safeDeviceList",
        .dataTypeSpecific.className = GPBStringifySymbol(SafeDeviceList),
        .number = BindQQResponse_FieldNumber_SafeDeviceList,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, safeDeviceList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "safeDevice",
        .dataTypeSpecific.className = NULL,
        .number = BindQQResponse_FieldNumber_SafeDevice,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, safeDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "wtloginRspBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BindQQResponse_FieldNumber_WtloginRspBuff,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(BindQQResponse__storage_, wtloginRspBuff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindQQResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindQQResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\016\001L\000\002F\000\003F\000\004N\000\005P\000\006M\000\007F\000\010c\007\000\tM\000\nE\000\013b\002\000\014N\000\r"
        "J\000\016c\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResetPwdRequest

@implementation ResetPwdRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasOpCode, opCode;
@dynamic hasPwd, pwd;

typedef struct ResetPwdRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opCode;
  BaseRequest *baseRequest;
  NSString *pwd;
} ResetPwdRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ResetPwdRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResetPwdRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opCode",
        .dataTypeSpecific.className = NULL,
        .number = ResetPwdRequest_FieldNumber_OpCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResetPwdRequest__storage_, opCode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = ResetPwdRequest_FieldNumber_Pwd,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResetPwdRequest__storage_, pwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResetPwdRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResetPwdRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002F\000\003C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResetPwdResponse

@implementation ResetPwdResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasURL, URL;

typedef struct ResetPwdResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *URL;
} ResetPwdResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ResetPwdResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResetPwdResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ResetPwdResponse_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResetPwdResponse__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResetPwdResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResetPwdResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002\001!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnBindQQRequest

@implementation UnBindQQRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasTicket, ticket;

typedef struct UnBindQQRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *ticket;
} UnBindQQRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = UnBindQQRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnBindQQRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = UnBindQQRequest_FieldNumber_Ticket,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnBindQQRequest__storage_, ticket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnBindQQRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnBindQQRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnBindQQResponse

@implementation UnBindQQResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct UnBindQQResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} UnBindQQResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = UnBindQQResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnBindQQResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnBindQQResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnBindQQResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckUnBindRequest

@implementation CheckUnBindRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasBindType, bindType;

typedef struct CheckUnBindRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t bindType;
  BaseRequest *baseRequest;
} CheckUnBindRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = CheckUnBindRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckUnBindRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bindType",
        .dataTypeSpecific.className = NULL,
        .number = CheckUnBindRequest_FieldNumber_BindType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckUnBindRequest__storage_, bindType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckUnBindRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckUnBindRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckUnBindResponse

@implementation CheckUnBindResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasRandomPasswd, randomPasswd;
@dynamic hasCanUnbindNotice, canUnbindNotice;

typedef struct CheckUnBindResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *randomPasswd;
  NSString *canUnbindNotice;
} CheckUnBindResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = CheckUnBindResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckUnBindResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomPasswd",
        .dataTypeSpecific.className = NULL,
        .number = CheckUnBindResponse_FieldNumber_RandomPasswd,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckUnBindResponse__storage_, randomPasswd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "canUnbindNotice",
        .dataTypeSpecific.className = NULL,
        .number = CheckUnBindResponse_FieldNumber_CanUnbindNotice,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CheckUnBindResponse__storage_, canUnbindNotice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckUnBindResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckUnBindResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002L\000\003O\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FaceBookAuthRequest

@implementation FaceBookAuthRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasOpType, opType;
@dynamic hasAccessToken, accessToken;
@dynamic hasRandomEncryKey, randomEncryKey;

typedef struct FaceBookAuthRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opType;
  BaseRequest *baseRequest;
  NSString *accessToken;
  NSString *randomEncryKey;
} FaceBookAuthRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = FaceBookAuthRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FaceBookAuthRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opType",
        .dataTypeSpecific.className = NULL,
        .number = FaceBookAuthRequest_FieldNumber_OpType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FaceBookAuthRequest__storage_, opType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "accessToken",
        .dataTypeSpecific.className = NULL,
        .number = FaceBookAuthRequest_FieldNumber_AccessToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FaceBookAuthRequest__storage_, accessToken),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = NULL,
        .number = FaceBookAuthRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FaceBookAuthRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FaceBookAuthRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FaceBookAuthRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002F\000\003K\000\004N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FaceBookAuthResponse

@implementation FaceBookAuthResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasFbuserId, fbuserId;
@dynamic hasFbuserName, fbuserName;

typedef struct FaceBookAuthResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *fbuserName;
  uint64_t fbuserId;
} FaceBookAuthResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = FaceBookAuthResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FaceBookAuthResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fbuserId",
        .dataTypeSpecific.className = NULL,
        .number = FaceBookAuthResponse_FieldNumber_FbuserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FaceBookAuthResponse__storage_, fbuserId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fbuserName",
        .dataTypeSpecific.className = NULL,
        .number = FaceBookAuthResponse_FieldNumber_FbuserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FaceBookAuthResponse__storage_, fbuserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FaceBookAuthResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FaceBookAuthResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002c\004A\000\003c\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegEquipmentRequest

@implementation RegEquipmentRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasType, type;
@dynamic hasSerialNumber, serialNumber;
@dynamic hasImei, imei;
@dynamic hasMac, mac;
@dynamic hasNickName, nickName;
@dynamic hasBuiltinIpseq, builtinIpseq;
@dynamic hasDlsrc, dlsrc;
@dynamic hasRegMode, regMode;
@dynamic hasTimeZone, timeZone;
@dynamic hasLanguage, language;
@dynamic hasForceReg, forceReg;
@dynamic hasRealCountry, realCountry;
@dynamic hasRandomEncryKey, randomEncryKey;

typedef struct RegEquipmentRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t builtinIpseq;
  uint32_t dlsrc;
  uint32_t regMode;
  uint32_t forceReg;
  BaseRequest *baseRequest;
  NSString *serialNumber;
  NSString *imei;
  NSString *mac;
  NSString *nickName;
  NSString *timeZone;
  NSString *language;
  NSString *realCountry;
  SKBuiltinBuffer_t *randomEncryKey;
} RegEquipmentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = RegEquipmentRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentRequest_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "serialNumber",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentRequest_FieldNumber_SerialNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, serialNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imei",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentRequest_FieldNumber_Imei,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, imei),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mac",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentRequest_FieldNumber_Mac,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, mac),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentRequest_FieldNumber_NickName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIpseq",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentRequest_FieldNumber_BuiltinIpseq,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, builtinIpseq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dlsrc",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentRequest_FieldNumber_Dlsrc,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, dlsrc),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "regMode",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentRequest_FieldNumber_RegMode,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, regMode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentRequest_FieldNumber_TimeZone,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentRequest_FieldNumber_Language,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "forceReg",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentRequest_FieldNumber_ForceReg,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, forceReg),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "realCountry",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentRequest_FieldNumber_RealCountry,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, realCountry),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = RegEquipmentRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(RegEquipmentRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegEquipmentRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegEquipmentRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\016\001K\000\002D\000\003L\000\004d\000\005c\000\006H\000\007Hb\002\000\010c\002\000\tG\000\nH\000\013H\000\014H\000"
        "\rK\000\016N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegEquipmentResponse

@implementation RegEquipmentResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasUin, uin;
@dynamic hasSessionKey, sessionKey;
@dynamic hasOfficialUserName, officialUserName;
@dynamic hasOfficialNickName, officialNickName;
@dynamic hasQqmicroBlogUserName, qqmicroBlogUserName;
@dynamic hasBindEmail, bindEmail;
@dynamic hasPushMailStatus, pushMailStatus;
@dynamic hasSendCardBitFlag, sendCardBitFlag;
@dynamic hasPushMailSettingTicket, pushMailSettingTicket;
@dynamic hasBuiltinIplist, builtinIplist;
@dynamic hasFsurl, fsurl;
@dynamic hasUserName, userName;
@dynamic hasStatus, status;
@dynamic hasNetworkControl, networkControl;
@dynamic hasReturnFlag, returnFlag;
@dynamic hasRegType, regType;
@dynamic hasAuthKey, authKey;
@dynamic hasPluginKeyList, pluginKeyList;
@dynamic hasPassword, password;
@dynamic hasProfileFlag, profileFlag;
@dynamic hasNewHostList, newHostList;

typedef struct RegEquipmentResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t uin;
  uint32_t pushMailStatus;
  uint32_t sendCardBitFlag;
  uint32_t status;
  uint32_t returnFlag;
  uint32_t regType;
  uint32_t profileFlag;
  BaseResponse *baseResponse;
  NSString *sessionKey;
  NSString *officialUserName;
  NSString *officialNickName;
  NSString *qqmicroBlogUserName;
  NSString *bindEmail;
  NSString *pushMailSettingTicket;
  BuiltinIPList *builtinIplist;
  NSString *fsurl;
  NSString *userName;
  NetworkControl *networkControl;
  NSString *authKey;
  PluginKeyList *pluginKeyList;
  NSString *password;
  HostList *newHostList;
} RegEquipmentResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = RegEquipmentResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_Uin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, uin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionKey",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_SessionKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, sessionKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "officialUserName",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_OfficialUserName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, officialUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "officialNickName",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_OfficialNickName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, officialNickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qqmicroBlogUserName",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_QqmicroBlogUserName,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, qqmicroBlogUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindEmail",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_BindEmail,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, bindEmail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushMailStatus",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_PushMailStatus,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, pushMailStatus),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sendCardBitFlag",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_SendCardBitFlag,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, sendCardBitFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pushMailSettingTicket",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_PushMailSettingTicket,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, pushMailSettingTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIplist",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList),
        .number = RegEquipmentResponse_FieldNumber_BuiltinIplist,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, builtinIplist),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fsurl",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_Fsurl,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, fsurl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_UserName,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_Status,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "networkControl",
        .dataTypeSpecific.className = GPBStringifySymbol(NetworkControl),
        .number = RegEquipmentResponse_FieldNumber_NetworkControl,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, networkControl),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "returnFlag",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_ReturnFlag,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, returnFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "regType",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_RegType,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, regType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "authKey",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_AuthKey,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, authKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pluginKeyList",
        .dataTypeSpecific.className = GPBStringifySymbol(PluginKeyList),
        .number = RegEquipmentResponse_FieldNumber_PluginKeyList,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, pluginKeyList),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_Password,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, password),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "profileFlag",
        .dataTypeSpecific.className = NULL,
        .number = RegEquipmentResponse_FieldNumber_ProfileFlag,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, profileFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "newHostList",
        .dataTypeSpecific.className = GPBStringifySymbol(HostList),
        .number = RegEquipmentResponse_FieldNumber_NewHostList,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(RegEquipmentResponse__storage_, newHostList),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegEquipmentResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegEquipmentResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\026\001L\000\002C\000\003J\000\004P\000\005P\000\006c\020\000\007I\000\010N\000\tO\000\nU\000\016Hb\003\000\017e\000"
        "\020H\000\021F\000\022N\000\023J\000\024G\000\025G\000\026M\000\027H\000\030K\000\031K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResetEquipmentRequest

@implementation ResetEquipmentRequest

@dynamic hasBaseRequest, baseRequest;

typedef struct ResetEquipmentRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
} ResetEquipmentRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ResetEquipmentRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResetEquipmentRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResetEquipmentRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResetEquipmentRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResetEquipmentResponse

@implementation ResetEquipmentResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct ResetEquipmentResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} ResetEquipmentResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ResetEquipmentResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResetEquipmentResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResetEquipmentResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResetEquipmentResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetPwdRequest

@implementation SetPwdRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasPassword, password;
@dynamic hasTicket, ticket;
@dynamic hasAutoAuthKey, autoAuthKey;

typedef struct SetPwdRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *password;
  NSString *ticket;
  SKBuiltinBuffer_t *autoAuthKey;
} SetPwdRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = SetPwdRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetPwdRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = SetPwdRequest_FieldNumber_Password,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetPwdRequest__storage_, password),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = SetPwdRequest_FieldNumber_Ticket,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SetPwdRequest__storage_, ticket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "autoAuthKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = SetPwdRequest_FieldNumber_AutoAuthKey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SetPwdRequest__storage_, autoAuthKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetPwdRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetPwdRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002H\000\003F\000\004K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetPwdResponse

@implementation SetPwdResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasAutoAuthKey, autoAuthKey;

typedef struct SetPwdResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  SKBuiltinBuffer_t *autoAuthKey;
} SetPwdResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = SetPwdResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetPwdResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoAuthKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = SetPwdResponse_FieldNumber_AutoAuthKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetPwdResponse__storage_, autoAuthKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetPwdResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetPwdResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryHasPswdRequest

@implementation QueryHasPswdRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasScene, scene;

typedef struct QueryHasPswdRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t scene;
  BaseRequest *baseRequest;
} QueryHasPswdRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = QueryHasPswdRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryHasPswdRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = QueryHasPswdRequest_FieldNumber_Scene,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QueryHasPswdRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryHasPswdRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryHasPswdRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QueryHasPswdResponse

@implementation QueryHasPswdResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct QueryHasPswdResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} QueryHasPswdResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = QueryHasPswdResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QueryHasPswdResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QueryHasPswdResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QueryHasPswdResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyPswdRequest

@implementation VerifyPswdRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasOpCode, opCode;
@dynamic hasPwd1, pwd1;
@dynamic hasPwd2, pwd2;
@dynamic hasImgSid, imgSid;
@dynamic hasImgCode, imgCode;
@dynamic hasImgEncryptKey, imgEncryptKey;
@dynamic hasKsid, ksid;
@dynamic hasScence, scence;
@dynamic hasWtloginReqBuff, wtloginReqBuff;

typedef struct VerifyPswdRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opCode;
  uint32_t scence;
  BaseRequest *baseRequest;
  NSString *pwd1;
  NSString *pwd2;
  SKBuiltinString_t *imgSid;
  SKBuiltinString_t *imgCode;
  SKBuiltinString_t *imgEncryptKey;
  SKBuiltinBuffer_t *ksid;
  SKBuiltinBuffer_t *wtloginReqBuff;
} VerifyPswdRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = VerifyPswdRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyPswdRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opCode",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPswdRequest_FieldNumber_OpCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyPswdRequest__storage_, opCode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pwd1",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPswdRequest_FieldNumber_Pwd1,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VerifyPswdRequest__storage_, pwd1),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd2",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPswdRequest_FieldNumber_Pwd2,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VerifyPswdRequest__storage_, pwd2),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgSid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = VerifyPswdRequest_FieldNumber_ImgSid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VerifyPswdRequest__storage_, imgSid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgCode",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = VerifyPswdRequest_FieldNumber_ImgCode,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VerifyPswdRequest__storage_, imgCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgEncryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = VerifyPswdRequest_FieldNumber_ImgEncryptKey,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VerifyPswdRequest__storage_, imgEncryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ksid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = VerifyPswdRequest_FieldNumber_Ksid,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(VerifyPswdRequest__storage_, ksid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scence",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPswdRequest_FieldNumber_Scence,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(VerifyPswdRequest__storage_, scence),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "wtloginReqBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = VerifyPswdRequest_FieldNumber_WtloginReqBuff,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(VerifyPswdRequest__storage_, wtloginReqBuff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyPswdRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyPswdRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\001K\000\002F\000\003D\000\004D\000\005F\000\006G\000\007M\000\010b\002\000\tF\000\nc\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyPswdResponse

@implementation VerifyPswdResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasImgSid, imgSid;
@dynamic hasImgBuf, imgBuf;
@dynamic hasTicket, ticket;
@dynamic hasImgEncryptKey, imgEncryptKey;
@dynamic hasA2Key, a2Key;
@dynamic hasKsid, ksid;
@dynamic hasAuthKey, authKey;
@dynamic hasWtloginRspBuff, wtloginRspBuff;

typedef struct VerifyPswdResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  SKBuiltinString_t *imgSid;
  SKBuiltinBuffer_t *imgBuf;
  NSString *ticket;
  SKBuiltinString_t *imgEncryptKey;
  SKBuiltinBuffer_t *a2Key;
  SKBuiltinBuffer_t *ksid;
  NSString *authKey;
  SKBuiltinBuffer_t *wtloginRspBuff;
} VerifyPswdResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = VerifyPswdResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyPswdResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgSid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = VerifyPswdResponse_FieldNumber_ImgSid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyPswdResponse__storage_, imgSid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = VerifyPswdResponse_FieldNumber_ImgBuf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VerifyPswdResponse__storage_, imgBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPswdResponse_FieldNumber_Ticket,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VerifyPswdResponse__storage_, ticket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgEncryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = VerifyPswdResponse_FieldNumber_ImgEncryptKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(VerifyPswdResponse__storage_, imgEncryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "a2Key",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = VerifyPswdResponse_FieldNumber_A2Key,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(VerifyPswdResponse__storage_, a2Key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ksid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = VerifyPswdResponse_FieldNumber_Ksid,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(VerifyPswdResponse__storage_, ksid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authKey",
        .dataTypeSpecific.className = NULL,
        .number = VerifyPswdResponse_FieldNumber_AuthKey,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(VerifyPswdResponse__storage_, authKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wtloginRspBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = VerifyPswdResponse_FieldNumber_WtloginRspBuff,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(VerifyPswdResponse__storage_, wtloginRspBuff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyPswdResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyPswdResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001L\000\002F\000\003F\000\004F\000\005M\000\006E\000\007b\002\000\010G\000\tc\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResetPawInfo

@implementation ResetPawInfo

@dynamic hasCreateTime, createTime;
@dynamic hasIsReset, isReset;
@dynamic hasId_p, id_p;

typedef struct ResetPawInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t createTime;
  uint32_t isReset;
  uint32_t id_p;
} ResetPawInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = ResetPawInfo_FieldNumber_CreateTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResetPawInfo__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isReset",
        .dataTypeSpecific.className = NULL,
        .number = ResetPawInfo_FieldNumber_IsReset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResetPawInfo__storage_, isReset),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = ResetPawInfo_FieldNumber_Id_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResetPawInfo__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResetPawInfo class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResetPawInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001J\000\002G\000\003\000ID\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ApplyResetPawRequest

@implementation ApplyResetPawRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasType, type;
@dynamic hasResetInfo, resetInfo;
@dynamic hasGetMethod, getMethod;
@dynamic hasRandomEncryKey, randomEncryKey;

typedef struct ApplyResetPawRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  uint32_t getMethod;
  BaseRequest *baseRequest;
  NSString *resetInfo;
  SKBuiltinBuffer_t *randomEncryKey;
} ApplyResetPawRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ApplyResetPawRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ApplyResetPawRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ApplyResetPawRequest_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ApplyResetPawRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "resetInfo",
        .dataTypeSpecific.className = NULL,
        .number = ApplyResetPawRequest_FieldNumber_ResetInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ApplyResetPawRequest__storage_, resetInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "getMethod",
        .dataTypeSpecific.className = NULL,
        .number = ApplyResetPawRequest_FieldNumber_GetMethod,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ApplyResetPawRequest__storage_, getMethod),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ApplyResetPawRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ApplyResetPawRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ApplyResetPawRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ApplyResetPawRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001K\000\002D\000\003I\000\004I\000\005N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ApplyResetPawResponse

@implementation ApplyResetPawResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct ApplyResetPawResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} ApplyResetPawResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ApplyResetPawResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ApplyResetPawResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ApplyResetPawResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ApplyResetPawResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetWeiBoURLReq

@implementation GetWeiBoURLReq

@dynamic hasBaseRequest, baseRequest;
@dynamic hasA2Key, a2Key;
@dynamic hasUserName, userName;
@dynamic hasScene, scene;
@dynamic hasBlogUserName, blogUserName;
@dynamic hasA2KeyNew, a2KeyNew;

typedef struct GetWeiBoURLReq__storage_ {
  uint32_t _has_storage_[1];
  uint32_t scene;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *a2Key;
  NSString *userName;
  NSString *blogUserName;
  SKBuiltinBuffer_t *a2KeyNew;
} GetWeiBoURLReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetWeiBoURLReq_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetWeiBoURLReq__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "a2Key",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetWeiBoURLReq_FieldNumber_A2Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetWeiBoURLReq__storage_, a2Key),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = GetWeiBoURLReq_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetWeiBoURLReq__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = GetWeiBoURLReq_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetWeiBoURLReq__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blogUserName",
        .dataTypeSpecific.className = NULL,
        .number = GetWeiBoURLReq_FieldNumber_BlogUserName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetWeiBoURLReq__storage_, blogUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "a2KeyNew",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetWeiBoURLReq_FieldNumber_A2KeyNew,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetWeiBoURLReq__storage_, a2KeyNew),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetWeiBoURLReq class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetWeiBoURLReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001K\000\002E\000\003H\000\004E\000\005L\000\006H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetWeiBoURLResp

@implementation GetWeiBoURLResp

@dynamic hasBaseResponse, baseResponse;
@dynamic hasURL, URL;

typedef struct GetWeiBoURLResp__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *URL;
} GetWeiBoURLResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetWeiBoURLResp_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetWeiBoURLResp__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = GetWeiBoURLResp_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetWeiBoURLResp__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetWeiBoURLResp class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetWeiBoURLResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002\003\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetUserNameRequest

@implementation GetUserNameRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasBindUin, bindUin;
@dynamic hasNickName, nickName;
@dynamic hasTicket, ticket;
@dynamic hasPwd, pwd;
@dynamic hasMobile, mobile;
@dynamic hasOpCode, opCode;

typedef struct GetUserNameRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t bindUin;
  uint32_t opCode;
  BaseRequest *baseRequest;
  NSString *nickName;
  NSString *ticket;
  NSString *pwd;
  NSString *mobile;
} GetUserNameRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetUserNameRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetUserNameRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bindUin",
        .dataTypeSpecific.className = NULL,
        .number = GetUserNameRequest_FieldNumber_BindUin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetUserNameRequest__storage_, bindUin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = GetUserNameRequest_FieldNumber_NickName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetUserNameRequest__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = GetUserNameRequest_FieldNumber_Ticket,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetUserNameRequest__storage_, ticket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = GetUserNameRequest_FieldNumber_Pwd,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetUserNameRequest__storage_, pwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mobile",
        .dataTypeSpecific.className = NULL,
        .number = GetUserNameRequest_FieldNumber_Mobile,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetUserNameRequest__storage_, mobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opCode",
        .dataTypeSpecific.className = NULL,
        .number = GetUserNameRequest_FieldNumber_OpCode,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetUserNameRequest__storage_, opCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetUserNameRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetUserNameRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001K\000\002G\000\003H\000\004F\000\005C\000\006F\000\007F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetUserNameResponse

@implementation GetUserNameResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasUserName, userName;
@dynamic hasTicket, ticket;

typedef struct GetUserNameResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *userName;
  NSString *ticket;
} GetUserNameResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetUserNameResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetUserNameResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = GetUserNameResponse_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetUserNameResponse__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = GetUserNameResponse_FieldNumber_Ticket,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetUserNameResponse__storage_, ticket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetUserNameResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetUserNameResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002H\000\003F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IphoneRegRequest

@implementation IphoneRegRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasToken, token;
@dynamic hasSound, sound;
@dynamic hasStatus, status;
@dynamic hasVoipSound, voipSound;
@dynamic hasTokenCert, tokenCert;
@dynamic hasTokenEnv, tokenEnv;
@dynamic hasTokenScene, tokenScene;

typedef struct IphoneRegRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  uint32_t tokenCert;
  uint32_t tokenEnv;
  uint32_t tokenScene;
  BaseRequest *baseRequest;
  NSString *token;
  NSString *sound;
  NSString *voipSound;
} IphoneRegRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = IphoneRegRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IphoneRegRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = IphoneRegRequest_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IphoneRegRequest__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sound",
        .dataTypeSpecific.className = NULL,
        .number = IphoneRegRequest_FieldNumber_Sound,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IphoneRegRequest__storage_, sound),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = IphoneRegRequest_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IphoneRegRequest__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "voipSound",
        .dataTypeSpecific.className = NULL,
        .number = IphoneRegRequest_FieldNumber_VoipSound,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IphoneRegRequest__storage_, voipSound),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tokenCert",
        .dataTypeSpecific.className = NULL,
        .number = IphoneRegRequest_FieldNumber_TokenCert,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(IphoneRegRequest__storage_, tokenCert),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tokenEnv",
        .dataTypeSpecific.className = NULL,
        .number = IphoneRegRequest_FieldNumber_TokenEnv,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(IphoneRegRequest__storage_, tokenEnv),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "tokenScene",
        .dataTypeSpecific.className = NULL,
        .number = IphoneRegRequest_FieldNumber_TokenScene,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(IphoneRegRequest__storage_, tokenScene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IphoneRegRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IphoneRegRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001K\000\002E\000\003E\000\004F\000\005I\000\006I\000\007H\000\010J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IphoneRegResponse

@implementation IphoneRegResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct IphoneRegResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} IphoneRegResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = IphoneRegResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IphoneRegResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IphoneRegResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IphoneRegResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IphoneUnRegRequest

@implementation IphoneUnRegRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasToken, token;

typedef struct IphoneUnRegRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *token;
} IphoneUnRegRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = IphoneUnRegRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IphoneUnRegRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = IphoneUnRegRequest_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IphoneUnRegRequest__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IphoneUnRegRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IphoneUnRegRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - IphoneUnRegResponse

@implementation IphoneUnRegResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct IphoneUnRegResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} IphoneUnRegResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = IphoneUnRegResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IphoneUnRegResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IphoneUnRegResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IphoneUnRegResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WinphoneRegRequest

@implementation WinphoneRegRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUri, uri;

typedef struct WinphoneRegRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *uri;
} WinphoneRegRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = WinphoneRegRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WinphoneRegRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uri",
        .dataTypeSpecific.className = NULL,
        .number = WinphoneRegRequest_FieldNumber_Uri,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WinphoneRegRequest__storage_, uri),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WinphoneRegRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WinphoneRegRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WinphoneRegResponse

@implementation WinphoneRegResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct WinphoneRegResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} WinphoneRegResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = WinphoneRegResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WinphoneRegResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WinphoneRegResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WinphoneRegResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WinphoneUnRegRequest

@implementation WinphoneUnRegRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUri, uri;

typedef struct WinphoneUnRegRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *uri;
} WinphoneUnRegRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = WinphoneUnRegRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WinphoneUnRegRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uri",
        .dataTypeSpecific.className = NULL,
        .number = WinphoneUnRegRequest_FieldNumber_Uri,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WinphoneUnRegRequest__storage_, uri),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WinphoneUnRegRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WinphoneUnRegRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WinphoneUnRegResponse

@implementation WinphoneUnRegResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct WinphoneUnRegResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} WinphoneUnRegResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = WinphoneUnRegResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WinphoneUnRegResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WinphoneUnRegResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WinphoneUnRegResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AshaRegRequest

@implementation AshaRegRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasNid, nid;

typedef struct AshaRegRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *nid;
} AshaRegRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = AshaRegRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AshaRegRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nid",
        .dataTypeSpecific.className = NULL,
        .number = AshaRegRequest_FieldNumber_Nid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AshaRegRequest__storage_, nid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AshaRegRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AshaRegRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AshaRegResponse

@implementation AshaRegResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct AshaRegResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} AshaRegResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = AshaRegResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AshaRegResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AshaRegResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AshaRegResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AshaUnRegRequest

@implementation AshaUnRegRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasNid, nid;

typedef struct AshaUnRegRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *nid;
} AshaUnRegRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = AshaUnRegRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AshaUnRegRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nid",
        .dataTypeSpecific.className = NULL,
        .number = AshaUnRegRequest_FieldNumber_Nid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AshaUnRegRequest__storage_, nid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AshaUnRegRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AshaUnRegRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AshaUnRegResponse

@implementation AshaUnRegResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct AshaUnRegResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} AshaUnRegResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = AshaUnRegResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AshaUnRegResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AshaUnRegResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AshaUnRegResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlackBerryRegRequest

@implementation BlackBerryRegRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasPin, pin;
@dynamic hasPort, port;

typedef struct BlackBerryRegRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t port;
  BaseRequest *baseRequest;
  NSString *pin;
} BlackBerryRegRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BlackBerryRegRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlackBerryRegRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pin",
        .dataTypeSpecific.className = NULL,
        .number = BlackBerryRegRequest_FieldNumber_Pin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlackBerryRegRequest__storage_, pin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = BlackBerryRegRequest_FieldNumber_Port,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlackBerryRegRequest__storage_, port),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlackBerryRegRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlackBerryRegRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002C\000\003D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlackBerryRegResponse

@implementation BlackBerryRegResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct BlackBerryRegResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} BlackBerryRegResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BlackBerryRegResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlackBerryRegResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlackBerryRegResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlackBerryRegResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlackBerryUnRegRequest

@implementation BlackBerryUnRegRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasPin, pin;

typedef struct BlackBerryUnRegRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *pin;
} BlackBerryUnRegRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BlackBerryUnRegRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlackBerryUnRegRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pin",
        .dataTypeSpecific.className = NULL,
        .number = BlackBerryUnRegRequest_FieldNumber_Pin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlackBerryUnRegRequest__storage_, pin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlackBerryUnRegRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlackBerryUnRegRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlackBerryUnRegResponse

@implementation BlackBerryUnRegResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct BlackBerryUnRegResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} BlackBerryUnRegResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BlackBerryUnRegResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlackBerryUnRegResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlackBerryUnRegResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlackBerryUnRegResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AndroidGCMRegRequest

@implementation AndroidGCMRegRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasToken, token;

typedef struct AndroidGCMRegRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *token;
} AndroidGCMRegRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = AndroidGCMRegRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AndroidGCMRegRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = AndroidGCMRegRequest_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AndroidGCMRegRequest__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AndroidGCMRegRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AndroidGCMRegRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AndroidGCMRegResponse

@implementation AndroidGCMRegResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct AndroidGCMRegResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} AndroidGCMRegResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = AndroidGCMRegResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AndroidGCMRegResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AndroidGCMRegResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AndroidGCMRegResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AndroidGCMUnRegRequest

@implementation AndroidGCMUnRegRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasToken, token;

typedef struct AndroidGCMUnRegRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *token;
} AndroidGCMUnRegRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = AndroidGCMUnRegRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AndroidGCMUnRegRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = AndroidGCMUnRegRequest_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AndroidGCMUnRegRequest__storage_, token),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AndroidGCMUnRegRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AndroidGCMUnRegRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AndroidGCMUnRegResponse

@implementation AndroidGCMUnRegResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct AndroidGCMUnRegResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} AndroidGCMUnRegResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = AndroidGCMUnRegResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AndroidGCMUnRegResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AndroidGCMUnRegResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AndroidGCMUnRegResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RSACert

@implementation RSACert

@dynamic hasKeyN, keyN;
@dynamic hasKeyE, keyE;

typedef struct RSACert__storage_ {
  uint32_t _has_storage_[1];
  NSString *keyN;
  NSString *keyE;
} RSACert__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "keyN",
        .dataTypeSpecific.className = NULL,
        .number = RSACert_FieldNumber_KeyN,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RSACert__storage_, keyN),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "keyE",
        .dataTypeSpecific.className = NULL,
        .number = RSACert_FieldNumber_KeyE,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RSACert__storage_, keyE),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RSACert class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RSACert__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001D\000\002D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetCertRequest

@implementation GetCertRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasCurrentCertVersion, currentCertVersion;

typedef struct GetCertRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t currentCertVersion;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *randomEncryKey;
} GetCertRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetCertRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetCertRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetCertRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetCertRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "currentCertVersion",
        .dataTypeSpecific.className = NULL,
        .number = GetCertRequest_FieldNumber_CurrentCertVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetCertRequest__storage_, currentCertVersion),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetCertRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetCertRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002N\000\003R\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetCertResponse

@implementation GetCertResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCertValue, certValue;
@dynamic hasCertVersion, certVersion;

typedef struct GetCertResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t certVersion;
  BaseResponse *baseResponse;
  RSACert *certValue;
} GetCertResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetCertResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetCertResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "certValue",
        .dataTypeSpecific.className = GPBStringifySymbol(RSACert),
        .number = GetCertResponse_FieldNumber_CertValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetCertResponse__storage_, certValue),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "certVersion",
        .dataTypeSpecific.className = NULL,
        .number = GetCertResponse_FieldNumber_CertVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetCertResponse__storage_, certVersion),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetCertResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetCertResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002I\000\003K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewAuthRsaReqData

@implementation NewAuthRsaReqData

@dynamic hasRandomEncryKey, randomEncryKey;

typedef struct NewAuthRsaReqData__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinBuffer_t *randomEncryKey;
} NewAuthRsaReqData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthRsaReqData_FieldNumber_RandomEncryKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewAuthRsaReqData__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewAuthRsaReqData class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewAuthRsaReqData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001N\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewAuthRequest

@implementation NewAuthRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasPwd, pwd;
@dynamic hasImgSid, imgSid;
@dynamic hasImgCode, imgCode;
@dynamic hasPwd2, pwd2;
@dynamic hasBuiltinIpseq, builtinIpseq;
@dynamic hasExtPwd, extPwd;
@dynamic hasExtPwd2, extPwd2;
@dynamic hasTimeZone, timeZone;
@dynamic hasLanguage, language;
@dynamic hasImei, imei;
@dynamic hasChannel, channel;
@dynamic hasIphoneVer, iphoneVer;
@dynamic hasImgEncryptKey, imgEncryptKey;
@dynamic hasKsid, ksid;
@dynamic hasTimeStamp, timeStamp;
@dynamic hasDeviceBrand, deviceBrand;
@dynamic hasDeviceModel, deviceModel;
@dynamic hasOstype, ostype;
@dynamic hasDeviceType, deviceType;
@dynamic hasSoftType, softType;
@dynamic hasAuthTicket, authTicket;
@dynamic hasRealCountry, realCountry;
@dynamic hasSignature, signature;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasAutoAuthTicket, autoAuthTicket;
@dynamic hasDeviceName, deviceName;
@dynamic hasWtloginReqBuff, wtloginReqBuff;
@dynamic hasInputType, inputType;
@dynamic hasClientSeqId, clientSeqId;
@dynamic hasBundleId, bundleId;
@dynamic hasAdSource, adSource;
@dynamic hasCliDbencryptKey, cliDbencryptKey;
@dynamic hasCliDbencryptInfo, cliDbencryptInfo;
@dynamic hasVerifySignature, verifySignature;
@dynamic hasVerifyContent, verifyContent;
@dynamic hasSessionMode, sessionMode;

typedef struct NewAuthRequest__storage_ {
  uint32_t _has_storage_[2];
  uint32_t builtinIpseq;
  int32_t channel;
  uint32_t timeStamp;
  uint32_t inputType;
  uint32_t sessionMode;
  BaseRequest *baseRequest;
  SKBuiltinString_t *userName;
  SKBuiltinString_t *pwd;
  SKBuiltinString_t *imgSid;
  SKBuiltinString_t *imgCode;
  NSString *pwd2;
  NSString *extPwd;
  NSString *extPwd2;
  NSString *timeZone;
  NSString *language;
  NSString *imei;
  NSString *iphoneVer;
  SKBuiltinString_t *imgEncryptKey;
  SKBuiltinBuffer_t *ksid;
  NSString *deviceBrand;
  NSString *deviceModel;
  NSString *ostype;
  NSString *deviceType;
  NSString *softType;
  NSString *authTicket;
  NSString *realCountry;
  NSString *signature;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *autoAuthTicket;
  NSString *deviceName;
  SKBuiltinBuffer_t *wtloginReqBuff;
  NSString *clientSeqId;
  NSString *bundleId;
  NSString *adSource;
  SKBuiltinBuffer_t *cliDbencryptKey;
  SKBuiltinBuffer_t *cliDbencryptInfo;
  NSString *verifySignature;
  NSString *verifyContent;
} NewAuthRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = NewAuthRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthRequest_FieldNumber_Pwd,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, pwd),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgSid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthRequest_FieldNumber_ImgSid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, imgSid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgCode",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthRequest_FieldNumber_ImgCode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, imgCode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pwd2",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_Pwd2,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, pwd2),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIpseq",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_BuiltinIpseq,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, builtinIpseq),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extPwd",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_ExtPwd,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, extPwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extPwd2",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_ExtPwd2,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, extPwd2),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_TimeZone,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_Language,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imei",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_Imei,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, imei),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_Channel,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, channel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "iphoneVer",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_IphoneVer,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, iphoneVer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgEncryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthRequest_FieldNumber_ImgEncryptKey,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, imgEncryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ksid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthRequest_FieldNumber_Ksid,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, ksid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_TimeStamp,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceBrand",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_DeviceBrand,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, deviceBrand),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModel",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_DeviceModel,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, deviceModel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ostype",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_Ostype,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, ostype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_DeviceType,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "softType",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_SoftType,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, softType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_AuthTicket,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, authTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realCountry",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_RealCountry,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, realCountry),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_Signature,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoAuthTicket",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_AutoAuthTicket,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, autoAuthTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_DeviceName,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wtloginReqBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthRequest_FieldNumber_WtloginReqBuff,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, wtloginReqBuff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "inputType",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_InputType,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, inputType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_ClientSeqId,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundleId",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_BundleId,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, bundleId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adSource",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_AdSource,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, adSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "cliDbencryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthRequest_FieldNumber_CliDbencryptKey,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, cliDbencryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliDbencryptInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthRequest_FieldNumber_CliDbencryptInfo,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, cliDbencryptInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "verifySignature",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_VerifySignature,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, verifySignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyContent",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_VerifyContent,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, verifyContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sessionMode",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthRequest_FieldNumber_SessionMode,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(NewAuthRequest__storage_, sessionMode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewAuthRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewAuthRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "&\001K\000\002H\000\003C\000\004F\000\005G\000\006D\000\007Hb\002\000\010\006\000\t\007\000\nH\000\013H\000\014d\000\r"
        "G\000\016b\007\000\017M\000\020b\002\000\021I\000\022K\000\023K\000\024c\003\000\025J\000\026H\000\027J\000\030K\000\031I"
        "\000\032N\000\033N\000\034J\000\035c\013\000\036I\000\037JA\000 GA\000!H\000\"Db\t\000#Db\n\000$O"
        "\000%M\000&K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewAuthResponse

@implementation NewAuthResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasUin, uin;
@dynamic hasUserName, userName;
@dynamic hasNickName, nickName;
@dynamic hasBindUin, bindUin;
@dynamic hasBindEmail, bindEmail;
@dynamic hasBindMobile, bindMobile;
@dynamic hasStatus, status;
@dynamic hasSessionKey, sessionKey;
@dynamic hasImgSid, imgSid;
@dynamic hasImgBuf, imgBuf;
@dynamic hasOfficialUserName, officialUserName;
@dynamic hasOfficialNickName, officialNickName;
@dynamic hasQqmicroBlogUserName, qqmicroBlogUserName;
@dynamic hasQqmicroBlogStatus, qqmicroBlogStatus;
@dynamic hasNewVersion, newVersion;
@dynamic hasTicket, ticket;
@dynamic hasPushMailStatus, pushMailStatus;
@dynamic hasSendCardBitFlag, sendCardBitFlag;
@dynamic hasPushMailSettingTicket, pushMailSettingTicket;
@dynamic hasBuiltinIplist, builtinIplist;
@dynamic hasFsurl, fsurl;
@dynamic hasNetworkControl, networkControl;
@dynamic hasPluginFlag, pluginFlag;
@dynamic hasAlias, alias;
@dynamic hasRegType, regType;
@dynamic hasAuthKey, authKey;
@dynamic hasSid, sid;
@dynamic hasPluginKeyList, pluginKeyList;
@dynamic hasImgEncryptKey, imgEncryptKey;
@dynamic hasA2Key, a2Key;
@dynamic hasKsid, ksid;
@dynamic hasProfileFlag, profileFlag;
@dynamic hasPassword, password;
@dynamic hasTimeStamp, timeStamp;
@dynamic hasIsAutoReg, isAutoReg;
@dynamic hasKickResponse, kickResponse;
@dynamic hasApplyBetaURL, applyBetaURL;
@dynamic hasDeviceInfoXml, deviceInfoXml;
@dynamic hasSoftConfigXml, softConfigXml;
@dynamic hasNewHostList, newHostList;
@dynamic hasAuthTicket, authTicket;
@dynamic hasSafeDevice, safeDevice;
@dynamic hasObsoleteItem1, obsoleteItem1;
@dynamic hasNeedSetEmailPwd, needSetEmailPwd;
@dynamic hasHintMsg, hintMsg;
@dynamic hasAutoAuthTicket, autoAuthTicket;
@dynamic hasDnsInfo, dnsInfo;
@dynamic hasNextAuthType, nextAuthType;
@dynamic hasWtloginRspBuff, wtloginRspBuff;
@dynamic hasShowStyle, showStyle;
@dynamic hasCliDbencryptKey, cliDbencryptKey;
@dynamic hasCliDbencryptInfo, cliDbencryptInfo;
@dynamic hasFlag, flag;
@dynamic hasSnsDnsInfo, snsDnsInfo;
@dynamic hasAppDnsInfo, appDnsInfo;
@dynamic hasVerifySignature, verifySignature;
@dynamic hasVerifyBuff, verifyBuff;

typedef struct NewAuthResponse__storage_ {
  uint32_t _has_storage_[2];
  uint32_t uin;
  uint32_t bindUin;
  uint32_t status;
  uint32_t qqmicroBlogStatus;
  uint32_t newVersion;
  uint32_t pushMailStatus;
  uint32_t sendCardBitFlag;
  uint32_t pluginFlag;
  uint32_t regType;
  uint32_t profileFlag;
  uint32_t timeStamp;
  uint32_t isAutoReg;
  uint32_t safeDevice;
  uint32_t obsoleteItem1;
  uint32_t needSetEmailPwd;
  uint32_t nextAuthType;
  uint32_t flag;
  BaseResponse *baseResponse;
  SKBuiltinString_t *userName;
  SKBuiltinString_t *nickName;
  SKBuiltinString_t *bindEmail;
  SKBuiltinString_t *bindMobile;
  NSData *sessionKey;
  SKBuiltinString_t *imgSid;
  SKBuiltinBuffer_t *imgBuf;
  SKBuiltinString_t *officialUserName;
  SKBuiltinString_t *officialNickName;
  SKBuiltinString_t *qqmicroBlogUserName;
  NSString *ticket;
  NSString *pushMailSettingTicket;
  BuiltinIPList *builtinIplist;
  NSString *fsurl;
  NetworkControl *networkControl;
  NSString *alias;
  NSString *authKey;
  NSString *sid;
  PluginKeyList *pluginKeyList;
  SKBuiltinString_t *imgEncryptKey;
  SKBuiltinBuffer_t *a2Key;
  SKBuiltinBuffer_t *ksid;
  NSString *password;
  NSString *kickResponse;
  NSString *applyBetaURL;
  NSString *deviceInfoXml;
  NSString *softConfigXml;
  HostList *newHostList;
  NSString *authTicket;
  NSString *hintMsg;
  NSString *autoAuthTicket;
  CDNDnsInfo *dnsInfo;
  SKBuiltinBuffer_t *wtloginRspBuff;
  ShowStyleKey *showStyle;
  SKBuiltinBuffer_t *cliDbencryptKey;
  SKBuiltinBuffer_t *cliDbencryptInfo;
  CDNDnsInfo *snsDnsInfo;
  CDNDnsInfo *appDnsInfo;
  NSString *verifySignature;
  SKBuiltinBuffer_t *verifyBuff;
} NewAuthResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = NewAuthResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_Uin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, uin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthResponse_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthResponse_FieldNumber_NickName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bindUin",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_BindUin,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, bindUin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bindEmail",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthResponse_FieldNumber_BindEmail,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, bindEmail),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bindMobile",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthResponse_FieldNumber_BindMobile,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, bindMobile),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_Status,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionKey",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_SessionKey,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, sessionKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "imgSid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthResponse_FieldNumber_ImgSid,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, imgSid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthResponse_FieldNumber_ImgBuf,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, imgBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "officialUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthResponse_FieldNumber_OfficialUserName,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, officialUserName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "officialNickName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthResponse_FieldNumber_OfficialNickName,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, officialNickName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "qqmicroBlogUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthResponse_FieldNumber_QqmicroBlogUserName,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, qqmicroBlogUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "qqmicroBlogStatus",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_QqmicroBlogStatus,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, qqmicroBlogStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "newVersion",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_NewVersion,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, newVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "ticket",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_Ticket,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, ticket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushMailStatus",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_PushMailStatus,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, pushMailStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sendCardBitFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_SendCardBitFlag,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, sendCardBitFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pushMailSettingTicket",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_PushMailSettingTicket,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, pushMailSettingTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIplist",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList),
        .number = NewAuthResponse_FieldNumber_BuiltinIplist,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, builtinIplist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fsurl",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_Fsurl,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, fsurl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "networkControl",
        .dataTypeSpecific.className = GPBStringifySymbol(NetworkControl),
        .number = NewAuthResponse_FieldNumber_NetworkControl,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, networkControl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pluginFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_PluginFlag,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, pluginFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_Alias,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, alias),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "regType",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_RegType,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, regType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "authKey",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_AuthKey,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, authKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sid",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_Sid,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, sid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pluginKeyList",
        .dataTypeSpecific.className = GPBStringifySymbol(PluginKeyList),
        .number = NewAuthResponse_FieldNumber_PluginKeyList,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, pluginKeyList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgEncryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = NewAuthResponse_FieldNumber_ImgEncryptKey,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, imgEncryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "a2Key",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthResponse_FieldNumber_A2Key,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, a2Key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ksid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthResponse_FieldNumber_Ksid,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, ksid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "profileFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_ProfileFlag,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, profileFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_Password,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, password),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_TimeStamp,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "isAutoReg",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_IsAutoReg,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, isAutoReg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "kickResponse",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_KickResponse,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, kickResponse),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "applyBetaURL",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_ApplyBetaURL,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, applyBetaURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceInfoXml",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_DeviceInfoXml,
        .hasIndex = 38,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, deviceInfoXml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "softConfigXml",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_SoftConfigXml,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, softConfigXml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newHostList",
        .dataTypeSpecific.className = GPBStringifySymbol(HostList),
        .number = NewAuthResponse_FieldNumber_NewHostList,
        .hasIndex = 40,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, newHostList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_AuthTicket,
        .hasIndex = 41,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, authTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "safeDevice",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_SafeDevice,
        .hasIndex = 42,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, safeDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "obsoleteItem1",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_ObsoleteItem1,
        .hasIndex = 43,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, obsoleteItem1),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "needSetEmailPwd",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_NeedSetEmailPwd,
        .hasIndex = 44,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, needSetEmailPwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "hintMsg",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_HintMsg,
        .hasIndex = 45,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, hintMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "autoAuthTicket",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_AutoAuthTicket,
        .hasIndex = 46,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, autoAuthTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dnsInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(CDNDnsInfo),
        .number = NewAuthResponse_FieldNumber_DnsInfo,
        .hasIndex = 47,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, dnsInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nextAuthType",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_NextAuthType,
        .hasIndex = 48,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, nextAuthType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "wtloginRspBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthResponse_FieldNumber_WtloginRspBuff,
        .hasIndex = 49,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, wtloginRspBuff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "showStyle",
        .dataTypeSpecific.className = GPBStringifySymbol(ShowStyleKey),
        .number = NewAuthResponse_FieldNumber_ShowStyle,
        .hasIndex = 50,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, showStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliDbencryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthResponse_FieldNumber_CliDbencryptKey,
        .hasIndex = 51,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, cliDbencryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliDbencryptInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthResponse_FieldNumber_CliDbencryptInfo,
        .hasIndex = 52,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, cliDbencryptInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_Flag,
        .hasIndex = 53,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, flag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "snsDnsInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(CDNDnsInfo),
        .number = NewAuthResponse_FieldNumber_SnsDnsInfo,
        .hasIndex = 54,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, snsDnsInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appDnsInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(CDNDnsInfo),
        .number = NewAuthResponse_FieldNumber_AppDnsInfo,
        .hasIndex = 55,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, appDnsInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "verifySignature",
        .dataTypeSpecific.className = NULL,
        .number = NewAuthResponse_FieldNumber_VerifySignature,
        .hasIndex = 56,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, verifySignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = NewAuthResponse_FieldNumber_VerifyBuff,
        .hasIndex = 57,
        .offset = (uint32_t)offsetof(NewAuthResponse__storage_, verifyBuff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewAuthResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewAuthResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        ":\001L\000\002C\000\003H\000\004H\000\005G\000\006I\000\007J\000\010F\000\tJ\000\nF\000\013F\000\014P\000\rP\000"
        "\016c\020\000\017c\016\000\020J\000\021F\000\022N\000\023O\000\024U\000\025Hb\003\000\026e\000\027N\000\030J\000\031E\000"
        "\032G\000\033G\000\034C\000\035M\000\036M\000\037E\000 b\002\000!K\000\"H\000#I\000$I\000%L\000&J!"
        "!\000\'M\000(M\000)K\000*J\000+J\000,M\000-O\000.G\000/N\0000G\0001L\0002c\013\0003"
        "I\0004Db\t\0005Db\n\0006D\0007J\0008J\0009O\000:J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindGoogleContactRequest

@implementation BindGoogleContactRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasOpcode, opcode;
@dynamic hasGoogleContactName, googleContactName;
@dynamic hasForce, force;

typedef struct BindGoogleContactRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opcode;
  uint32_t force;
  BaseRequest *baseRequest;
  NSString *googleContactName;
} BindGoogleContactRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BindGoogleContactRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindGoogleContactRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = BindGoogleContactRequest_FieldNumber_Opcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindGoogleContactRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "googleContactName",
        .dataTypeSpecific.className = NULL,
        .number = BindGoogleContactRequest_FieldNumber_GoogleContactName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindGoogleContactRequest__storage_, googleContactName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "force",
        .dataTypeSpecific.className = NULL,
        .number = BindGoogleContactRequest_FieldNumber_Force,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BindGoogleContactRequest__storage_, force),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindGoogleContactRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindGoogleContactRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002F\000\003Q\000\004E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindGoogleContactResponse

@implementation BindGoogleContactResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct BindGoogleContactResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} BindGoogleContactResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BindGoogleContactResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindGoogleContactResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindGoogleContactResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindGoogleContactResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindLinkedinContactRequest

@implementation BindLinkedinContactRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasOpcode, opcode;
@dynamic hasVisible, visible;
@dynamic hasLinkedinMemberId, linkedinMemberId;
@dynamic hasLinkedinName, linkedinName;
@dynamic hasLinkedinPublicURL, linkedinPublicURL;
@dynamic hasTimestamp, timestamp;
@dynamic hasNounce, nounce;
@dynamic hasLinkedinSignature, linkedinSignature;
@dynamic hasLinkedinReturnSignature, linkedinReturnSignature;

typedef struct BindLinkedinContactRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opcode;
  uint32_t visible;
  BaseRequest *baseRequest;
  NSString *linkedinMemberId;
  NSString *linkedinName;
  NSString *linkedinPublicURL;
  NSString *timestamp;
  NSString *nounce;
  NSString *linkedinSignature;
  NSString *linkedinReturnSignature;
} BindLinkedinContactRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BindLinkedinContactRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindLinkedinContactRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = BindLinkedinContactRequest_FieldNumber_Opcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindLinkedinContactRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "visible",
        .dataTypeSpecific.className = NULL,
        .number = BindLinkedinContactRequest_FieldNumber_Visible,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindLinkedinContactRequest__storage_, visible),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "linkedinMemberId",
        .dataTypeSpecific.className = NULL,
        .number = BindLinkedinContactRequest_FieldNumber_LinkedinMemberId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BindLinkedinContactRequest__storage_, linkedinMemberId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linkedinName",
        .dataTypeSpecific.className = NULL,
        .number = BindLinkedinContactRequest_FieldNumber_LinkedinName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BindLinkedinContactRequest__storage_, linkedinName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linkedinPublicURL",
        .dataTypeSpecific.className = NULL,
        .number = BindLinkedinContactRequest_FieldNumber_LinkedinPublicURL,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BindLinkedinContactRequest__storage_, linkedinPublicURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = BindLinkedinContactRequest_FieldNumber_Timestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BindLinkedinContactRequest__storage_, timestamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nounce",
        .dataTypeSpecific.className = NULL,
        .number = BindLinkedinContactRequest_FieldNumber_Nounce,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BindLinkedinContactRequest__storage_, nounce),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linkedinSignature",
        .dataTypeSpecific.className = NULL,
        .number = BindLinkedinContactRequest_FieldNumber_LinkedinSignature,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BindLinkedinContactRequest__storage_, linkedinSignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "linkedinReturnSignature",
        .dataTypeSpecific.className = NULL,
        .number = BindLinkedinContactRequest_FieldNumber_LinkedinReturnSignature,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BindLinkedinContactRequest__storage_, linkedinReturnSignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindLinkedinContactRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindLinkedinContactRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\001K\000\002F\000\003G\000\004OA\000\005L\000\006O!!\000\007I\000\010F\000\tQ\000\nW\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindLinkedinContactResponse

@implementation BindLinkedinContactResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct BindLinkedinContactResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} BindLinkedinContactResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BindLinkedinContactResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindLinkedinContactResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindLinkedinContactResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindLinkedinContactResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnBindLinkedinContactRequest

@implementation UnBindLinkedinContactRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasOpcode, opcode;

typedef struct UnBindLinkedinContactRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opcode;
  BaseRequest *baseRequest;
} UnBindLinkedinContactRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = UnBindLinkedinContactRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnBindLinkedinContactRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = UnBindLinkedinContactRequest_FieldNumber_Opcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnBindLinkedinContactRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnBindLinkedinContactRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnBindLinkedinContactRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnBindLinkedinContactResponse

@implementation UnBindLinkedinContactResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct UnBindLinkedinContactResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} UnBindLinkedinContactResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = UnBindLinkedinContactResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnBindLinkedinContactResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnBindLinkedinContactResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnBindLinkedinContactResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginQRCodeNotify

@implementation LoginQRCodeNotify

@dynamic hasUuid, uuid;
@dynamic hasStatus, status;
@dynamic hasUserName, userName;
@dynamic hasPwd, pwd;
@dynamic hasHeadImgURL, headImgURL;
@dynamic hasPushLoginUrlexpiredTime, pushLoginUrlexpiredTime;
@dynamic hasNickName, nickName;
@dynamic hasExpiredTime, expiredTime;
@dynamic hasPairWaitTip, pairWaitTip;
@dynamic hasAuthorClientVersion, authorClientVersion;
@dynamic hasAuthorDeviceType, authorDeviceType;

typedef struct LoginQRCodeNotify__storage_ {
  uint32_t _has_storage_[1];
  uint32_t status;
  uint32_t pushLoginUrlexpiredTime;
  uint32_t expiredTime;
  uint32_t authorClientVersion;
  NSString *uuid;
  NSString *userName;
  NSString *pwd;
  NSString *headImgURL;
  NSString *nickName;
  NSString *pairWaitTip;
  NSString *authorDeviceType;
} LoginQRCodeNotify__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = LoginQRCodeNotify_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LoginQRCodeNotify__storage_, uuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = LoginQRCodeNotify_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LoginQRCodeNotify__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = LoginQRCodeNotify_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LoginQRCodeNotify__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = LoginQRCodeNotify_FieldNumber_Pwd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LoginQRCodeNotify__storage_, pwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "headImgURL",
        .dataTypeSpecific.className = NULL,
        .number = LoginQRCodeNotify_FieldNumber_HeadImgURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LoginQRCodeNotify__storage_, headImgURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushLoginUrlexpiredTime",
        .dataTypeSpecific.className = NULL,
        .number = LoginQRCodeNotify_FieldNumber_PushLoginUrlexpiredTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(LoginQRCodeNotify__storage_, pushLoginUrlexpiredTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = LoginQRCodeNotify_FieldNumber_NickName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(LoginQRCodeNotify__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expiredTime",
        .dataTypeSpecific.className = NULL,
        .number = LoginQRCodeNotify_FieldNumber_ExpiredTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(LoginQRCodeNotify__storage_, expiredTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pairWaitTip",
        .dataTypeSpecific.className = NULL,
        .number = LoginQRCodeNotify_FieldNumber_PairWaitTip,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LoginQRCodeNotify__storage_, pairWaitTip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authorClientVersion",
        .dataTypeSpecific.className = NULL,
        .number = LoginQRCodeNotify_FieldNumber_AuthorClientVersion,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LoginQRCodeNotify__storage_, authorClientVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "authorDeviceType",
        .dataTypeSpecific.className = NULL,
        .number = LoginQRCodeNotify_FieldNumber_AuthorDeviceType,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(LoginQRCodeNotify__storage_, authorDeviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginQRCodeNotify class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LoginQRCodeNotify__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\013\001d\000\002F\000\003H\000\004C\000\005J\000\006Jc\n\000\007H\000\010K\000\tK\000\nS\000\013P\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LoginQRCodeNotifyPkg

@implementation LoginQRCodeNotifyPkg

@dynamic hasNotifyData, notifyData;
@dynamic hasOpcode, opcode;

typedef struct LoginQRCodeNotifyPkg__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opcode;
  SKBuiltinBuffer_t *notifyData;
} LoginQRCodeNotifyPkg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notifyData",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = LoginQRCodeNotifyPkg_FieldNumber_NotifyData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LoginQRCodeNotifyPkg__storage_, notifyData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = LoginQRCodeNotifyPkg_FieldNumber_Opcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LoginQRCodeNotifyPkg__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LoginQRCodeNotifyPkg class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LoginQRCodeNotifyPkg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002c\003\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLoginQRCodeRequest

@implementation GetLoginQRCodeRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasOpcode, opcode;
@dynamic hasDeviceName, deviceName;
@dynamic hasUserName, userName;
@dynamic hasHardwareExtra, hardwareExtra;
@dynamic hasSoftType, softType;
@dynamic hasExtDevLoginType, extDevLoginType;
@dynamic hasMsgContextPubKey, msgContextPubKey;

typedef struct GetLoginQRCodeRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opcode;
  uint32_t hardwareExtra;
  int32_t extDevLoginType;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *deviceName;
  NSString *userName;
  NSString *softType;
  SKBuiltinBuffer_t *msgContextPubKey;
} GetLoginQRCodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetLoginQRCodeRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_Opcode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_DeviceName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_UserName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hardwareExtra",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_HardwareExtra,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, hardwareExtra),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "softType",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_SoftType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, softType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extDevLoginType",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_ExtDevLoginType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, extDevLoginType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgContextPubKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeRequest_FieldNumber_MsgContextPubKey,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, msgContextPubKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLoginQRCodeRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLoginQRCodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001K\000\002N\000\003c\003\000\004J\000\005H\000\006\r\000\007\010\000\010\017\000\t\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLoginQRCodeResponse

@implementation GetLoginQRCodeResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasQrcode, qrcode;
@dynamic hasUuid, uuid;
@dynamic hasCheckTime, checkTime;
@dynamic hasNotifyKey, notifyKey;
@dynamic hasExpiredTime, expiredTime;
@dynamic hasBlueToothBroadCastUuid, blueToothBroadCastUuid;
@dynamic hasBlueToothBroadCastContent, blueToothBroadCastContent;

typedef struct GetLoginQRCodeResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t checkTime;
  uint32_t expiredTime;
  BaseResponse *baseResponse;
  SKBuiltinBuffer_t *qrcode;
  NSString *uuid;
  SKBuiltinBuffer_t *notifyKey;
  NSString *blueToothBroadCastUuid;
  SKBuiltinBuffer_t *blueToothBroadCastContent;
} GetLoginQRCodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetLoginQRCodeResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "qrcode",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeResponse_FieldNumber_Qrcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, qrcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_Uuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, uuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checkTime",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_CheckTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, checkTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "notifyKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeResponse_FieldNumber_NotifyKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, notifyKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "expiredTime",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_ExpiredTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, expiredTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blueToothBroadCastUuid",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_BlueToothBroadCastUuid,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, blueToothBroadCastUuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blueToothBroadCastContent",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeResponse_FieldNumber_BlueToothBroadCastContent,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, blueToothBroadCastContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLoginQRCodeResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLoginQRCodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001L\000\002c\003\000\003d\000\004I\000\005I\000\006K\000\007Sc\000\010Y\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckLoginQRCodeRequest

@implementation CheckLoginQRCodeRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasUuid, uuid;
@dynamic hasTimeStamp, timeStamp;
@dynamic hasOpcode, opcode;

typedef struct CheckLoginQRCodeRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t timeStamp;
  uint32_t opcode;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *uuid;
} CheckLoginQRCodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = CheckLoginQRCodeRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = CheckLoginQRCodeRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeRequest_FieldNumber_Uuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, uuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeRequest_FieldNumber_TimeStamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeRequest_FieldNumber_Opcode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckLoginQRCodeRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckLoginQRCodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001K\000\002N\000\003d\000\004I\000\005c\003\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckLoginQRCodeResponse

@implementation CheckLoginQRCodeResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasNotifyPkg, notifyPkg;

typedef struct CheckLoginQRCodeResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  LoginQRCodeNotifyPkg *notifyPkg;
} CheckLoginQRCodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = CheckLoginQRCodeResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notifyPkg",
        .dataTypeSpecific.className = GPBStringifySymbol(LoginQRCodeNotifyPkg),
        .number = CheckLoginQRCodeResponse_FieldNumber_NotifyPkg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse__storage_, notifyPkg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckLoginQRCodeResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckLoginQRCodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\003I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLoginURLRequest

@implementation GetLoginURLRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUuid, uuid;
@dynamic hasFromDeviceId, fromDeviceId;

typedef struct GetLoginURLRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *uuid;
  NSData *fromDeviceId;
} GetLoginURLRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetLoginURLRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLoginURLRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginURLRequest_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLoginURLRequest__storage_, uuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fromDeviceId",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginURLRequest_FieldNumber_FromDeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLoginURLRequest__storage_, fromDeviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLoginURLRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLoginURLRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002d\000\003KA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLoginURLResponse

@implementation GetLoginURLResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasURL, URL;

typedef struct GetLoginURLResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *URL;
} GetLoginURLResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetLoginURLResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLoginURLResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginURLResponse_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLoginURLResponse__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLoginURLResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLoginURLResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001L\000\002\003\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushLoginURLRequest

@implementation PushLoginURLRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasAutoAuthTicket, autoAuthTicket;
@dynamic hasClientId, clientId;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasOpcode, opcode;
@dynamic hasDeviceName, deviceName;
@dynamic hasAutoAuthKey, autoAuthKey;

typedef struct PushLoginURLRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opcode;
  BaseRequest *baseRequest;
  NSString *userName;
  NSString *autoAuthTicket;
  NSString *clientId;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *deviceName;
  SKBuiltinBuffer_t *autoAuthKey;
} PushLoginURLRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = PushLoginURLRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushLoginURLRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = PushLoginURLRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushLoginURLRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "autoAuthTicket",
        .dataTypeSpecific.className = NULL,
        .number = PushLoginURLRequest_FieldNumber_AutoAuthTicket,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PushLoginURLRequest__storage_, autoAuthTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientId",
        .dataTypeSpecific.className = NULL,
        .number = PushLoginURLRequest_FieldNumber_ClientId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PushLoginURLRequest__storage_, clientId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = PushLoginURLRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PushLoginURLRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = PushLoginURLRequest_FieldNumber_Opcode,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PushLoginURLRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = PushLoginURLRequest_FieldNumber_DeviceName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PushLoginURLRequest__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "autoAuthKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = PushLoginURLRequest_FieldNumber_AutoAuthKey,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PushLoginURLRequest__storage_, autoAuthKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushLoginURLRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushLoginURLRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001K\000\002H\000\003N\000\004GA\000\005N\000\006c\003\000\007J\000\010K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PushLoginURLResponse

@implementation PushLoginURLResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasUuid, uuid;
@dynamic hasNotifyKey, notifyKey;
@dynamic hasCheckTime, checkTime;
@dynamic hasExpiredTime, expiredTime;
@dynamic hasBlueToothBroadCastUuid, blueToothBroadCastUuid;
@dynamic hasBlueToothBroadCastContent, blueToothBroadCastContent;

typedef struct PushLoginURLResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t checkTime;
  uint32_t expiredTime;
  BaseResponse *baseResponse;
  NSString *uuid;
  SKBuiltinBuffer_t *notifyKey;
  NSString *blueToothBroadCastUuid;
  SKBuiltinBuffer_t *blueToothBroadCastContent;
} PushLoginURLResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = PushLoginURLResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PushLoginURLResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = PushLoginURLResponse_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PushLoginURLResponse__storage_, uuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "notifyKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = PushLoginURLResponse_FieldNumber_NotifyKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PushLoginURLResponse__storage_, notifyKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "checkTime",
        .dataTypeSpecific.className = NULL,
        .number = PushLoginURLResponse_FieldNumber_CheckTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PushLoginURLResponse__storage_, checkTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "expiredTime",
        .dataTypeSpecific.className = NULL,
        .number = PushLoginURLResponse_FieldNumber_ExpiredTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PushLoginURLResponse__storage_, expiredTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blueToothBroadCastUuid",
        .dataTypeSpecific.className = NULL,
        .number = PushLoginURLResponse_FieldNumber_BlueToothBroadCastUuid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PushLoginURLResponse__storage_, blueToothBroadCastUuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blueToothBroadCastContent",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = PushLoginURLResponse_FieldNumber_BlueToothBroadCastContent,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PushLoginURLResponse__storage_, blueToothBroadCastContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PushLoginURLResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PushLoginURLResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001L\000\002d\000\003I\000\004I\000\005K\000\006Sc\000\007Y\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlueToothBindLoginRequest

@implementation BlueToothBindLoginRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasURL, URL;
@dynamic hasOpcode, opcode;

typedef struct BlueToothBindLoginRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opcode;
  BaseRequest *baseRequest;
  NSString *URL;
} BlueToothBindLoginRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BlueToothBindLoginRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlueToothBindLoginRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothBindLoginRequest_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlueToothBindLoginRequest__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothBindLoginRequest_FieldNumber_Opcode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlueToothBindLoginRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlueToothBindLoginRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlueToothBindLoginRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002\003\000\003c\003\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlueToothBindLoginResponse

@implementation BlueToothBindLoginResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasDeviceName, deviceName;
@dynamic hasExpiredTime, expiredTime;
@dynamic hasUuid, uuid;
@dynamic hasBlueToothBroadCastUuid, blueToothBroadCastUuid;

typedef struct BlueToothBindLoginResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t expiredTime;
  BaseResponse *baseResponse;
  NSString *deviceName;
  NSString *uuid;
  NSString *blueToothBroadCastUuid;
} BlueToothBindLoginResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BlueToothBindLoginResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlueToothBindLoginResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothBindLoginResponse_FieldNumber_DeviceName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlueToothBindLoginResponse__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "expiredTime",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothBindLoginResponse_FieldNumber_ExpiredTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlueToothBindLoginResponse__storage_, expiredTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothBindLoginResponse_FieldNumber_Uuid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlueToothBindLoginResponse__storage_, uuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blueToothBroadCastUuid",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothBindLoginResponse_FieldNumber_BlueToothBroadCastUuid,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BlueToothBindLoginResponse__storage_, blueToothBroadCastUuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlueToothBindLoginResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlueToothBindLoginResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001L\000\002J\000\003K\000\004d\000\005Sc\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlueToothAutoLoginRequest

@implementation BlueToothAutoLoginRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasUuid, uuid;
@dynamic hasAutoAuthTicket, autoAuthTicket;
@dynamic hasLoginInfoData, loginInfoData;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasBlueToothBroadCastUuid, blueToothBroadCastUuid;

typedef struct BlueToothAutoLoginRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *userName;
  NSString *uuid;
  NSString *autoAuthTicket;
  SKBuiltinBuffer_t *loginInfoData;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *blueToothBroadCastUuid;
} BlueToothAutoLoginRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BlueToothAutoLoginRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothAutoLoginRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothAutoLoginRequest_FieldNumber_Uuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginRequest__storage_, uuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "autoAuthTicket",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothAutoLoginRequest_FieldNumber_AutoAuthTicket,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginRequest__storage_, autoAuthTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "loginInfoData",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BlueToothAutoLoginRequest_FieldNumber_LoginInfoData,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginRequest__storage_, loginInfoData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BlueToothAutoLoginRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blueToothBroadCastUuid",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothAutoLoginRequest_FieldNumber_BlueToothBroadCastUuid,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginRequest__storage_, blueToothBroadCastUuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlueToothAutoLoginRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlueToothAutoLoginRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001K\000\002H\000\003d\000\004N\000\005M\000\006N\000\007Sc\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlueToothAutoLoginResponse

@implementation BlueToothAutoLoginResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasUserName, userName;
@dynamic hasPassword, password;

typedef struct BlueToothAutoLoginResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  NSString *userName;
  NSString *password;
} BlueToothAutoLoginResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BlueToothAutoLoginResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothAutoLoginResponse_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginResponse__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothAutoLoginResponse_FieldNumber_Password,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginResponse__storage_, password),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlueToothAutoLoginResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlueToothAutoLoginResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002H\000\003H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlueToothAutoLoginInfoPkg

@implementation BlueToothAutoLoginInfoPkg

@dynamic hasSalt, salt;
@dynamic hasData_p, data_p;

typedef struct BlueToothAutoLoginInfoPkg__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinBuffer_t *salt;
  SKBuiltinBuffer_t *data_p;
} BlueToothAutoLoginInfoPkg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "salt",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BlueToothAutoLoginInfoPkg_FieldNumber_Salt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginInfoPkg__storage_, salt),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BlueToothAutoLoginInfoPkg_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginInfoPkg__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlueToothAutoLoginInfoPkg class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlueToothAutoLoginInfoPkg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001D\000\002\000Data\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlueToothAutoLoginInfo

@implementation BlueToothAutoLoginInfo

@dynamic hasUin, uin;
@dynamic hasDeviceType, deviceType;
@dynamic hasClientVersion, clientVersion;
@dynamic hasDeviceId, deviceId;

typedef struct BlueToothAutoLoginInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t uin;
  uint32_t clientVersion;
  NSString *deviceType;
  NSData *deviceId;
} BlueToothAutoLoginInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothAutoLoginInfo_FieldNumber_Uin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginInfo__storage_, uin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothAutoLoginInfo_FieldNumber_DeviceType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginInfo__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothAutoLoginInfo_FieldNumber_ClientVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginInfo__storage_, clientVersion),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = BlueToothAutoLoginInfo_FieldNumber_DeviceId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlueToothAutoLoginInfo__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlueToothAutoLoginInfo class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlueToothAutoLoginInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001C\000\002J\000\003M\000\004GA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindBlackberryPPIDRequest

@implementation BindBlackberryPPIDRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasOpcode, opcode;
@dynamic hasBbppid, bbppid;
@dynamic hasBbpin, bbpin;
@dynamic hasBbmnickName, bbmnickName;
@dynamic hasForce, force;

typedef struct BindBlackberryPPIDRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opcode;
  uint32_t force;
  BaseRequest *baseRequest;
  NSString *bbppid;
  NSString *bbpin;
  NSString *bbmnickName;
} BindBlackberryPPIDRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BindBlackberryPPIDRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindBlackberryPPIDRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = BindBlackberryPPIDRequest_FieldNumber_Opcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BindBlackberryPPIDRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bbppid",
        .dataTypeSpecific.className = NULL,
        .number = BindBlackberryPPIDRequest_FieldNumber_Bbppid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BindBlackberryPPIDRequest__storage_, bbppid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bbpin",
        .dataTypeSpecific.className = NULL,
        .number = BindBlackberryPPIDRequest_FieldNumber_Bbpin,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BindBlackberryPPIDRequest__storage_, bbpin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bbmnickName",
        .dataTypeSpecific.className = NULL,
        .number = BindBlackberryPPIDRequest_FieldNumber_BbmnickName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BindBlackberryPPIDRequest__storage_, bbmnickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "force",
        .dataTypeSpecific.className = NULL,
        .number = BindBlackberryPPIDRequest_FieldNumber_Force,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BindBlackberryPPIDRequest__storage_, force),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindBlackberryPPIDRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindBlackberryPPIDRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001K\000\002F\000\003f\000\004e\000\005d\007\000\006E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BindBlackberryPPIDResponse

@implementation BindBlackberryPPIDResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct BindBlackberryPPIDResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} BindBlackberryPPIDResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BindBlackberryPPIDResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BindBlackberryPPIDResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BindBlackberryPPIDResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BindBlackberryPPIDResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LockWebDeviceRequest

@implementation LockWebDeviceRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasOpcode, opcode;
@dynamic hasBlueToothBroadCastUuid, blueToothBroadCastUuid;
@dynamic hasBlueToothBroadCastContent, blueToothBroadCastContent;

typedef struct LockWebDeviceRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t opcode;
  BaseRequest *baseRequest;
  NSString *blueToothBroadCastUuid;
  SKBuiltinBuffer_t *blueToothBroadCastContent;
} LockWebDeviceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = LockWebDeviceRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LockWebDeviceRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = LockWebDeviceRequest_FieldNumber_Opcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LockWebDeviceRequest__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "blueToothBroadCastUuid",
        .dataTypeSpecific.className = NULL,
        .number = LockWebDeviceRequest_FieldNumber_BlueToothBroadCastUuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LockWebDeviceRequest__storage_, blueToothBroadCastUuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blueToothBroadCastContent",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = LockWebDeviceRequest_FieldNumber_BlueToothBroadCastContent,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LockWebDeviceRequest__storage_, blueToothBroadCastContent),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LockWebDeviceRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LockWebDeviceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002c\003\000\003Sc\000\004Y\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LockWebDeviceResponse

@implementation LockWebDeviceResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct LockWebDeviceResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} LockWebDeviceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = LockWebDeviceResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LockWebDeviceResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LockWebDeviceResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LockWebDeviceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIosExtensionKeyRequest

@implementation GetIosExtensionKeyRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasExtensionSessionType, extensionSessionType;
@dynamic hasExtensionDeviceId, extensionDeviceId;

typedef struct GetIosExtensionKeyRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t extensionSessionType;
  BaseRequest *baseRequest;
  NSData *extensionDeviceId;
} GetIosExtensionKeyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetIosExtensionKeyRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIosExtensionKeyRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionSessionType",
        .dataTypeSpecific.className = NULL,
        .number = GetIosExtensionKeyRequest_FieldNumber_ExtensionSessionType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIosExtensionKeyRequest__storage_, extensionSessionType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "extensionDeviceId",
        .dataTypeSpecific.className = NULL,
        .number = GetIosExtensionKeyRequest_FieldNumber_ExtensionDeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetIosExtensionKeyRequest__storage_, extensionDeviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIosExtensionKeyRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIosExtensionKeyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002T\000\003Q\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExtSession

@implementation ExtSession

@dynamic hasSessionType, sessionType;
@dynamic hasSessionKey, sessionKey;
@dynamic hasServerId, serverId;

typedef struct ExtSession__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sessionType;
  SKBuiltinBuffer_t *sessionKey;
  SKBuiltinBuffer_t *serverId;
} ExtSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionType",
        .dataTypeSpecific.className = NULL,
        .number = ExtSession_FieldNumber_SessionType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExtSession__storage_, sessionType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sessionKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ExtSession_FieldNumber_SessionKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExtSession__storage_, sessionKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serverId",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ExtSession_FieldNumber_ServerId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ExtSession__storage_, serverId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExtSession class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExtSession__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002J\000\003H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetIosExtensionKeyResponse

@implementation GetIosExtensionKeyResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasKey, key;
@dynamic hasExtensionSession, extensionSession;

typedef struct GetIosExtensionKeyResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  SKBuiltinBuffer_t *key;
  ExtSession *extensionSession;
} GetIosExtensionKeyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetIosExtensionKeyResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetIosExtensionKeyResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetIosExtensionKeyResponse_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetIosExtensionKeyResponse__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionSession",
        .dataTypeSpecific.className = GPBStringifySymbol(ExtSession),
        .number = GetIosExtensionKeyResponse_FieldNumber_ExtensionSession,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetIosExtensionKeyResponse__storage_, extensionSession),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetIosExtensionKeyResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetIosExtensionKeyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002C\000\003P\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PatternLockBuffer

@implementation PatternLockBuffer

@dynamic hasUin, uin;
@dynamic hasVersion, version;
@dynamic hasSvrpatternhash, svrpatternhash;
@dynamic hasLockstatus, lockstatus;
@dynamic hasSign, sign;

typedef struct PatternLockBuffer__storage_ {
  uint32_t _has_storage_[1];
  uint32_t uin;
  uint32_t version;
  uint32_t lockstatus;
  SKBuiltinBuffer_t *svrpatternhash;
  SKBuiltinBuffer_t *sign;
} PatternLockBuffer__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = PatternLockBuffer_FieldNumber_Uin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PatternLockBuffer__storage_, uin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = PatternLockBuffer_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PatternLockBuffer__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "svrpatternhash",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = PatternLockBuffer_FieldNumber_Svrpatternhash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PatternLockBuffer__storage_, svrpatternhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lockstatus",
        .dataTypeSpecific.className = NULL,
        .number = PatternLockBuffer_FieldNumber_Lockstatus,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PatternLockBuffer__storage_, lockstatus),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = PatternLockBuffer_FieldNumber_Sign,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PatternLockBuffer__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PatternLockBuffer class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PatternLockBuffer__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterNewPatternLockRequest

@implementation RegisterNewPatternLockRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasPaytoken, paytoken;
@dynamic hasPatternhash, patternhash;
@dynamic hasCmd, cmd;

typedef struct RegisterNewPatternLockRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t cmd;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *paytoken;
  SKBuiltinBuffer_t *patternhash;
} RegisterNewPatternLockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = RegisterNewPatternLockRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterNewPatternLockRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "paytoken",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = RegisterNewPatternLockRequest_FieldNumber_Paytoken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegisterNewPatternLockRequest__storage_, paytoken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "patternhash",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = RegisterNewPatternLockRequest_FieldNumber_Patternhash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RegisterNewPatternLockRequest__storage_, patternhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cmd",
        .dataTypeSpecific.className = NULL,
        .number = RegisterNewPatternLockRequest_FieldNumber_Cmd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RegisterNewPatternLockRequest__storage_, cmd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterNewPatternLockRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterNewPatternLockRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RegisterNewPatternLockResponse

@implementation RegisterNewPatternLockResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasPatternlockbuf, patternlockbuf;

typedef struct RegisterNewPatternLockResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  PatternLockBuffer *patternlockbuf;
} RegisterNewPatternLockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = RegisterNewPatternLockResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RegisterNewPatternLockResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "patternlockbuf",
        .dataTypeSpecific.className = GPBStringifySymbol(PatternLockBuffer),
        .number = RegisterNewPatternLockResponse_FieldNumber_Patternlockbuf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RegisterNewPatternLockResponse__storage_, patternlockbuf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RegisterNewPatternLockResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RegisterNewPatternLockResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpPatternLockRequest

@implementation OpPatternLockRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasCmd, cmd;
@dynamic hasNowpatternhash, nowpatternhash;
@dynamic hasNewpatternhash, newpatternhash;

typedef struct OpPatternLockRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t cmd;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *nowpatternhash;
  SKBuiltinBuffer_t *newpatternhash;
} OpPatternLockRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = OpPatternLockRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OpPatternLockRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cmd",
        .dataTypeSpecific.className = NULL,
        .number = OpPatternLockRequest_FieldNumber_Cmd,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OpPatternLockRequest__storage_, cmd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "nowpatternhash",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = OpPatternLockRequest_FieldNumber_Nowpatternhash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OpPatternLockRequest__storage_, nowpatternhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newpatternhash",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = OpPatternLockRequest_FieldNumber_Newpatternhash,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OpPatternLockRequest__storage_, newpatternhash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpPatternLockRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpPatternLockRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpPatternLockResponse

@implementation OpPatternLockResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasPatternlockbuf, patternlockbuf;

typedef struct OpPatternLockResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  PatternLockBuffer *patternlockbuf;
} OpPatternLockResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = OpPatternLockResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OpPatternLockResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "patternlockbuf",
        .dataTypeSpecific.className = GPBStringifySymbol(PatternLockBuffer),
        .number = OpPatternLockResponse_FieldNumber_Patternlockbuf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OpPatternLockResponse__storage_, patternlockbuf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpPatternLockResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpPatternLockResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WTLoginImgReqInfo

@implementation WTLoginImgReqInfo

@dynamic hasImgSid, imgSid;
@dynamic hasImgCode, imgCode;
@dynamic hasImgEncryptKey, imgEncryptKey;
@dynamic hasKsid, ksid;

typedef struct WTLoginImgReqInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *imgSid;
  NSString *imgCode;
  NSString *imgEncryptKey;
  SKBuiltinBuffer_t *ksid;
} WTLoginImgReqInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imgSid",
        .dataTypeSpecific.className = NULL,
        .number = WTLoginImgReqInfo_FieldNumber_ImgSid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WTLoginImgReqInfo__storage_, imgSid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgCode",
        .dataTypeSpecific.className = NULL,
        .number = WTLoginImgReqInfo_FieldNumber_ImgCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WTLoginImgReqInfo__storage_, imgCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgEncryptKey",
        .dataTypeSpecific.className = NULL,
        .number = WTLoginImgReqInfo_FieldNumber_ImgEncryptKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WTLoginImgReqInfo__storage_, imgEncryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ksid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = WTLoginImgReqInfo_FieldNumber_Ksid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WTLoginImgReqInfo__storage_, ksid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WTLoginImgReqInfo class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WTLoginImgReqInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001F\000\002G\000\003M\000\004b\002\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WTLoginImgRespInfo

@implementation WTLoginImgRespInfo

@dynamic hasImgEncryptKey, imgEncryptKey;
@dynamic hasKsid, ksid;
@dynamic hasImgSid, imgSid;
@dynamic hasImgBuf, imgBuf;

typedef struct WTLoginImgRespInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *imgEncryptKey;
  SKBuiltinBuffer_t *ksid;
  NSString *imgSid;
  SKBuiltinBuffer_t *imgBuf;
} WTLoginImgRespInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "imgEncryptKey",
        .dataTypeSpecific.className = NULL,
        .number = WTLoginImgRespInfo_FieldNumber_ImgEncryptKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WTLoginImgRespInfo__storage_, imgEncryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ksid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = WTLoginImgRespInfo_FieldNumber_Ksid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WTLoginImgRespInfo__storage_, ksid),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imgSid",
        .dataTypeSpecific.className = NULL,
        .number = WTLoginImgRespInfo_FieldNumber_ImgSid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(WTLoginImgRespInfo__storage_, imgSid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "imgBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = WTLoginImgRespInfo_FieldNumber_ImgBuf,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(WTLoginImgRespInfo__storage_, imgBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WTLoginImgRespInfo class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WTLoginImgRespInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001M\000\002b\002\000\003F\000\004F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WxVerifyCodeReqInfo

@implementation WxVerifyCodeReqInfo

@dynamic hasVerifySignature, verifySignature;
@dynamic hasVerifyContent, verifyContent;

typedef struct WxVerifyCodeReqInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *verifySignature;
  NSString *verifyContent;
} WxVerifyCodeReqInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "verifySignature",
        .dataTypeSpecific.className = NULL,
        .number = WxVerifyCodeReqInfo_FieldNumber_VerifySignature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WxVerifyCodeReqInfo__storage_, verifySignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyContent",
        .dataTypeSpecific.className = NULL,
        .number = WxVerifyCodeReqInfo_FieldNumber_VerifyContent,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WxVerifyCodeReqInfo__storage_, verifyContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WxVerifyCodeReqInfo class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WxVerifyCodeReqInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001O\000\002M\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WxVerifyCodeRespInfo

@implementation WxVerifyCodeRespInfo

@dynamic hasVerifySignature, verifySignature;
@dynamic hasVerifyBuff, verifyBuff;

typedef struct WxVerifyCodeRespInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *verifySignature;
  SKBuiltinBuffer_t *verifyBuff;
} WxVerifyCodeRespInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "verifySignature",
        .dataTypeSpecific.className = NULL,
        .number = WxVerifyCodeRespInfo_FieldNumber_VerifySignature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WxVerifyCodeRespInfo__storage_, verifySignature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "verifyBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = WxVerifyCodeRespInfo_FieldNumber_VerifyBuff,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WxVerifyCodeRespInfo__storage_, verifyBuff),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WxVerifyCodeRespInfo class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WxVerifyCodeRespInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001O\000\002J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BaseAuthReqInfo

@implementation BaseAuthReqInfo

@dynamic hasWtloginReqBuff, wtloginReqBuff;
@dynamic hasWtloginImgReqInfo, wtloginImgReqInfo;
@dynamic hasWxVerifyCodeReqInfo, wxVerifyCodeReqInfo;
@dynamic hasCliDbencryptKey, cliDbencryptKey;
@dynamic hasCliDbencryptInfo, cliDbencryptInfo;
@dynamic hasAuthReqFlag, authReqFlag;
@dynamic hasAuthTicket, authTicket;

typedef struct BaseAuthReqInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t authReqFlag;
  SKBuiltinBuffer_t *wtloginReqBuff;
  WTLoginImgReqInfo *wtloginImgReqInfo;
  WxVerifyCodeReqInfo *wxVerifyCodeReqInfo;
  SKBuiltinBuffer_t *cliDbencryptKey;
  SKBuiltinBuffer_t *cliDbencryptInfo;
  NSString *authTicket;
} BaseAuthReqInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wtloginReqBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BaseAuthReqInfo_FieldNumber_WtloginReqBuff,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, wtloginReqBuff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wtloginImgReqInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(WTLoginImgReqInfo),
        .number = BaseAuthReqInfo_FieldNumber_WtloginImgReqInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, wtloginImgReqInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wxVerifyCodeReqInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(WxVerifyCodeReqInfo),
        .number = BaseAuthReqInfo_FieldNumber_WxVerifyCodeReqInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, wxVerifyCodeReqInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliDbencryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BaseAuthReqInfo_FieldNumber_CliDbencryptKey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, cliDbencryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliDbencryptInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BaseAuthReqInfo_FieldNumber_CliDbencryptInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, cliDbencryptInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authReqFlag",
        .dataTypeSpecific.className = NULL,
        .number = BaseAuthReqInfo_FieldNumber_AuthReqFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, authReqFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = NULL,
        .number = BaseAuthReqInfo_FieldNumber_AuthTicket,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BaseAuthReqInfo__storage_, authTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BaseAuthReqInfo class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BaseAuthReqInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001c\013\000\002c\016\000\003S\000\004Db\t\000\005Db\n\000\006K\000\007J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthRsaReqData

@implementation ManualAuthRsaReqData

@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasCliPubEcdhkey, cliPubEcdhkey;
@dynamic hasUserName, userName;
@dynamic hasPwd, pwd;
@dynamic hasPwd2, pwd2;

typedef struct ManualAuthRsaReqData__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinBuffer_t *randomEncryKey;
  ECDHKey *cliPubEcdhkey;
  NSString *userName;
  NSString *pwd;
  NSString *pwd2;
} ManualAuthRsaReqData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ManualAuthRsaReqData_FieldNumber_RandomEncryKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliPubEcdhkey",
        .dataTypeSpecific.className = GPBStringifySymbol(ECDHKey),
        .number = ManualAuthRsaReqData_FieldNumber_CliPubEcdhkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, cliPubEcdhkey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthRsaReqData_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthRsaReqData_FieldNumber_Pwd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, pwd),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd2",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthRsaReqData_FieldNumber_Pwd2,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ManualAuthRsaReqData__storage_, pwd2),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthRsaReqData class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthRsaReqData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001N\000\002Gd\002\000\003H\000\004C\000\005D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MMClientCheckData

@implementation MMClientCheckData

@dynamic hasEnType, enType;
@dynamic hasTag2, tag2;
@dynamic hasContent, content;

typedef struct MMClientCheckData__storage_ {
  uint32_t _has_storage_[1];
  int32_t tag2;
  NSString *enType;
  NSData *content;
} MMClientCheckData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "enType",
        .dataTypeSpecific.className = NULL,
        .number = MMClientCheckData_FieldNumber_EnType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MMClientCheckData__storage_, enType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag2",
        .dataTypeSpecific.className = NULL,
        .number = MMClientCheckData_FieldNumber_Tag2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MMClientCheckData__storage_, tag2),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = MMClientCheckData_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MMClientCheckData__storage_, content),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MMClientCheckData class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MMClientCheckData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthAesReqData

@implementation ManualAuthAesReqData

@dynamic hasBaseRequest, baseRequest;
@dynamic hasBaseReqInfo, baseReqInfo;
@dynamic hasImei, imei;
@dynamic hasSoftType, softType;
@dynamic hasBuiltinIpseq, builtinIpseq;
@dynamic hasClientSeqId, clientSeqId;
@dynamic hasClientSeqIdsign, clientSeqIdsign;
@dynamic hasDeviceName, deviceName;
@dynamic hasDeviceType, deviceType;
@dynamic hasLanguage, language;
@dynamic hasTimeZone, timeZone;
@dynamic hasChannel, channel;
@dynamic hasTimeStamp, timeStamp;
@dynamic hasDeviceBrand, deviceBrand;
@dynamic hasDeviceModel, deviceModel;
@dynamic hasOstype, ostype;
@dynamic hasRealCountry, realCountry;
@dynamic hasBundleId, bundleId;
@dynamic hasAdSource, adSource;
@dynamic hasIphoneVer, iphoneVer;
@dynamic hasInputType, inputType;
@dynamic hasClientCheckData, clientCheckData;

typedef struct ManualAuthAesReqData__storage_ {
  uint32_t _has_storage_[1];
  uint32_t builtinIpseq;
  int32_t channel;
  uint32_t timeStamp;
  uint32_t inputType;
  BaseRequest *baseRequest;
  BaseAuthReqInfo *baseReqInfo;
  NSString *imei;
  NSString *softType;
  NSString *clientSeqId;
  NSString *clientSeqIdsign;
  NSString *deviceName;
  NSString *deviceType;
  NSString *language;
  NSString *timeZone;
  NSString *deviceBrand;
  NSString *deviceModel;
  NSString *ostype;
  NSString *realCountry;
  NSString *bundleId;
  NSString *adSource;
  NSString *iphoneVer;
  SKBuiltinBuffer_t *clientCheckData;
} ManualAuthAesReqData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ManualAuthAesReqData_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "baseReqInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseAuthReqInfo),
        .number = ManualAuthAesReqData_FieldNumber_BaseReqInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, baseReqInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imei",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_Imei,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, imei),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "softType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_SoftType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, softType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIpseq",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_BuiltinIpseq,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, builtinIpseq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_ClientSeqId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "clientSeqIdsign",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_ClientSeqIdsign,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, clientSeqIdsign),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_DeviceName,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_DeviceType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_Language,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_TimeZone,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_Channel,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, channel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_TimeStamp,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceBrand",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_DeviceBrand,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, deviceBrand),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModel",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_DeviceModel,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, deviceModel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ostype",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_Ostype,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, ostype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realCountry",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_RealCountry,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, realCountry),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundleId",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_BundleId,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, bundleId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adSource",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_AdSource,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, adSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iphoneVer",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_IphoneVer,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, iphoneVer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAesReqData_FieldNumber_InputType,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, inputType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientCheckData",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ManualAuthAesReqData_FieldNumber_ClientCheckData,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ManualAuthAesReqData__storage_, clientCheckData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthAesReqData class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthAesReqData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\026\001K\000\002K\000\003d\000\004H\000\005Hb\002\000\006JA\000\007\nb\003\000\010J\000\tJ\000\nH\000\013H\000\r"
        "G\000\016I\000\017K\000\020K\000\021c\003\000\022K\000\023GA\000\024H\000\025b\007\000\026I\000\027\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthRequest

@implementation ManualAuthRequest

@dynamic hasRsaReqData, rsaReqData;
@dynamic hasAesReqData, aesReqData;

typedef struct ManualAuthRequest__storage_ {
  uint32_t _has_storage_[1];
  ManualAuthRsaReqData *rsaReqData;
  ManualAuthAesReqData *aesReqData;
} ManualAuthRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rsaReqData",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthRsaReqData),
        .number = ManualAuthRequest_FieldNumber_RsaReqData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthRequest__storage_, rsaReqData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "aesReqData",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthAesReqData),
        .number = ManualAuthRequest_FieldNumber_AesReqData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthRequest__storage_, aesReqData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AutoAuthRsaReqData

@implementation AutoAuthRsaReqData

@dynamic hasAesEncryptKey, aesEncryptKey;
@dynamic hasCliPubEcdhkey, cliPubEcdhkey;

typedef struct AutoAuthRsaReqData__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinBuffer_t *aesEncryptKey;
  ECDHKey *cliPubEcdhkey;
} AutoAuthRsaReqData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aesEncryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AutoAuthRsaReqData_FieldNumber_AesEncryptKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AutoAuthRsaReqData__storage_, aesEncryptKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliPubEcdhkey",
        .dataTypeSpecific.className = GPBStringifySymbol(ECDHKey),
        .number = AutoAuthRsaReqData_FieldNumber_CliPubEcdhkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AutoAuthRsaReqData__storage_, cliPubEcdhkey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutoAuthRsaReqData class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutoAuthRsaReqData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002M\000\003Gd\002\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AutoAuthKey

@implementation AutoAuthKey

@dynamic hasEncryptKey, encryptKey;
@dynamic hasKey, key;

typedef struct AutoAuthKey__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinBuffer_t *encryptKey;
  SKBuiltinBuffer_t *key;
} AutoAuthKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "encryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AutoAuthKey_FieldNumber_EncryptKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AutoAuthKey__storage_, encryptKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AutoAuthKey_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AutoAuthKey__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutoAuthKey class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutoAuthKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002C\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AutoAuthAesReqData

@implementation AutoAuthAesReqData

@dynamic hasBaseRequest, baseRequest;
@dynamic hasBaseReqInfo, baseReqInfo;
@dynamic hasAutoAuthKey, autoAuthKey;
@dynamic hasImei, imei;
@dynamic hasSoftType, softType;
@dynamic hasBuiltinIpseq, builtinIpseq;
@dynamic hasClientSeqId, clientSeqId;
@dynamic hasSignature, signature;
@dynamic hasDeviceName, deviceName;
@dynamic hasDeviceType, deviceType;
@dynamic hasLanguage, language;
@dynamic hasTimeZone, timeZone;
@dynamic hasChannel, channel;
@dynamic hasClientCheckData, clientCheckData;

typedef struct AutoAuthAesReqData__storage_ {
  uint32_t _has_storage_[1];
  uint32_t builtinIpseq;
  int32_t channel;
  BaseRequest *baseRequest;
  BaseAuthReqInfo *baseReqInfo;
  SKBuiltinBuffer_t *autoAuthKey;
  NSString *imei;
  NSString *softType;
  NSString *clientSeqId;
  NSString *signature;
  NSString *deviceName;
  NSString *deviceType;
  NSString *language;
  NSString *timeZone;
  SKBuiltinBuffer_t *clientCheckData;
} AutoAuthAesReqData__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = AutoAuthAesReqData_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "baseReqInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseAuthReqInfo),
        .number = AutoAuthAesReqData_FieldNumber_BaseReqInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, baseReqInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoAuthKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AutoAuthAesReqData_FieldNumber_AutoAuthKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, autoAuthKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imei",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_Imei,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, imei),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "softType",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_SoftType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, softType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIpseq",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_BuiltinIpseq,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, builtinIpseq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_ClientSeqId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_Signature,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, signature),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_DeviceName,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_DeviceType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_Language,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, language),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_TimeZone,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = AutoAuthAesReqData_FieldNumber_Channel,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, channel),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientCheckData",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AutoAuthAesReqData_FieldNumber_ClientCheckData,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(AutoAuthAesReqData__storage_, clientCheckData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutoAuthAesReqData class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutoAuthAesReqData__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\016\001K\000\002K\000\003K\000\004d\000\005H\000\006Hb\002\000\007JA\000\010I\000\tJ\000\nJ\000\013H\000\014H\000"
        "\rG\000\016\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AutoAuthRequest

@implementation AutoAuthRequest

@dynamic hasRsaReqData, rsaReqData;
@dynamic hasAesReqData, aesReqData;

typedef struct AutoAuthRequest__storage_ {
  uint32_t _has_storage_[1];
  AutoAuthRsaReqData *rsaReqData;
  AutoAuthAesReqData *aesReqData;
} AutoAuthRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rsaReqData",
        .dataTypeSpecific.className = GPBStringifySymbol(AutoAuthRsaReqData),
        .number = AutoAuthRequest_FieldNumber_RsaReqData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AutoAuthRequest__storage_, rsaReqData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "aesReqData",
        .dataTypeSpecific.className = GPBStringifySymbol(AutoAuthAesReqData),
        .number = AutoAuthRequest_FieldNumber_AesReqData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AutoAuthRequest__storage_, aesReqData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AutoAuthRequest class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AutoAuthRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkSectResp

@implementation NetworkSectResp

@dynamic hasNewHostList, newHostList;
@dynamic hasNetworkControl, networkControl;
@dynamic hasBuiltinIplist, builtinIplist;

typedef struct NetworkSectResp__storage_ {
  uint32_t _has_storage_[1];
  HostList *newHostList;
  NetworkControl *networkControl;
  BuiltinIPList *builtinIplist;
} NetworkSectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "newHostList",
        .dataTypeSpecific.className = GPBStringifySymbol(HostList),
        .number = NetworkSectResp_FieldNumber_NewHostList,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NetworkSectResp__storage_, newHostList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkControl",
        .dataTypeSpecific.className = GPBStringifySymbol(NetworkControl),
        .number = NetworkSectResp_FieldNumber_NetworkControl,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NetworkSectResp__storage_, networkControl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "builtinIplist",
        .dataTypeSpecific.className = GPBStringifySymbol(BuiltinIPList),
        .number = NetworkSectResp_FieldNumber_BuiltinIplist,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NetworkSectResp__storage_, builtinIplist),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkSectResp class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NetworkSectResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002N\000\003Hb\003\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthSectResp

@implementation AuthSectResp

@dynamic hasUin, uin;
@dynamic hasSvrPubEcdhkey, svrPubEcdhkey;
@dynamic hasSessionKey, sessionKey;
@dynamic hasAutoAuthKey, autoAuthKey;
@dynamic hasWtloginRspBuffFlag, wtloginRspBuffFlag;
@dynamic hasWtloginRspBuff, wtloginRspBuff;
@dynamic hasWtloginImgRespInfo, wtloginImgRespInfo;
@dynamic hasWxVerifyCodeRespInfo, wxVerifyCodeRespInfo;
@dynamic hasCliDbencryptKey, cliDbencryptKey;
@dynamic hasCliDbencryptInfo, cliDbencryptInfo;
@dynamic hasAuthKey, authKey;
@dynamic hasA2Key, a2Key;
@dynamic hasApplyBetaURL, applyBetaURL;
@dynamic hasShowStyle, showStyle;
@dynamic hasAuthTicket, authTicket;
@dynamic hasNewVersion, newVersion;
@dynamic hasUpdateFlag, updateFlag;
@dynamic hasAuthResultFlag, authResultFlag;
@dynamic hasFsurl, fsurl;
@dynamic hasServerTime, serverTime;

typedef struct AuthSectResp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t uin;
  uint32_t wtloginRspBuffFlag;
  uint32_t newVersion;
  uint32_t updateFlag;
  uint32_t authResultFlag;
  int32_t serverTime;
  ECDHKey *svrPubEcdhkey;
  SKBuiltinBuffer_t *sessionKey;
  SKBuiltinBuffer_t *autoAuthKey;
  SKBuiltinBuffer_t *wtloginRspBuff;
  WTLoginImgRespInfo *wtloginImgRespInfo;
  WxVerifyCodeRespInfo *wxVerifyCodeRespInfo;
  SKBuiltinBuffer_t *cliDbencryptKey;
  SKBuiltinBuffer_t *cliDbencryptInfo;
  NSString *authKey;
  SKBuiltinBuffer_t *a2Key;
  NSString *applyBetaURL;
  ShowStyleKey *showStyle;
  NSString *authTicket;
  NSString *fsurl;
} AuthSectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = AuthSectResp_FieldNumber_Uin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, uin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "svrPubEcdhkey",
        .dataTypeSpecific.className = GPBStringifySymbol(ECDHKey),
        .number = AuthSectResp_FieldNumber_SvrPubEcdhkey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, svrPubEcdhkey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sessionKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AuthSectResp_FieldNumber_SessionKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, sessionKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "autoAuthKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AuthSectResp_FieldNumber_AutoAuthKey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, autoAuthKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wtloginRspBuffFlag",
        .dataTypeSpecific.className = NULL,
        .number = AuthSectResp_FieldNumber_WtloginRspBuffFlag,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, wtloginRspBuffFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "wtloginRspBuff",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AuthSectResp_FieldNumber_WtloginRspBuff,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, wtloginRspBuff),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wtloginImgRespInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(WTLoginImgRespInfo),
        .number = AuthSectResp_FieldNumber_WtloginImgRespInfo,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, wtloginImgRespInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "wxVerifyCodeRespInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(WxVerifyCodeRespInfo),
        .number = AuthSectResp_FieldNumber_WxVerifyCodeRespInfo,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, wxVerifyCodeRespInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliDbencryptKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AuthSectResp_FieldNumber_CliDbencryptKey,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, cliDbencryptKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cliDbencryptInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AuthSectResp_FieldNumber_CliDbencryptInfo,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, cliDbencryptInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authKey",
        .dataTypeSpecific.className = NULL,
        .number = AuthSectResp_FieldNumber_AuthKey,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, authKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "a2Key",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = AuthSectResp_FieldNumber_A2Key,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, a2Key),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "applyBetaURL",
        .dataTypeSpecific.className = NULL,
        .number = AuthSectResp_FieldNumber_ApplyBetaURL,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, applyBetaURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "showStyle",
        .dataTypeSpecific.className = GPBStringifySymbol(ShowStyleKey),
        .number = AuthSectResp_FieldNumber_ShowStyle,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, showStyle),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authTicket",
        .dataTypeSpecific.className = NULL,
        .number = AuthSectResp_FieldNumber_AuthTicket,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, authTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "newVersion",
        .dataTypeSpecific.className = NULL,
        .number = AuthSectResp_FieldNumber_NewVersion,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, newVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "updateFlag",
        .dataTypeSpecific.className = NULL,
        .number = AuthSectResp_FieldNumber_UpdateFlag,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, updateFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "authResultFlag",
        .dataTypeSpecific.className = NULL,
        .number = AuthSectResp_FieldNumber_AuthResultFlag,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, authResultFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fsurl",
        .dataTypeSpecific.className = NULL,
        .number = AuthSectResp_FieldNumber_Fsurl,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, fsurl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serverTime",
        .dataTypeSpecific.className = NULL,
        .number = AuthSectResp_FieldNumber_ServerTime,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(AuthSectResp__storage_, serverTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthSectResp class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthSectResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\024\001C\000\002Gd\002\000\003J\000\004K\000\005c\017\000\006c\013\000\007c\017\000\010T\000\tDb\t\000\nDb\n\000"
        "\013G\000\014E\000\016J!!\000\017I\000\020J\000\021J\000\022J\000\023N\000\024e\000\026\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AcctSectResp

@implementation AcctSectResp

@dynamic hasUserName, userName;
@dynamic hasNickName, nickName;
@dynamic hasBindUin, bindUin;
@dynamic hasBindEmail, bindEmail;
@dynamic hasBindMobile, bindMobile;
@dynamic hasAlias, alias;
@dynamic hasStatus, status;
@dynamic hasPluginFlag, pluginFlag;
@dynamic hasRegType, regType;
@dynamic hasDeviceInfoXml, deviceInfoXml;
@dynamic hasSafeDevice, safeDevice;
@dynamic hasOfficialUserName, officialUserName;
@dynamic hasOfficialNickName, officialNickName;
@dynamic hasPushMailStatus, pushMailStatus;
@dynamic hasFsurl, fsurl;

typedef struct AcctSectResp__storage_ {
  uint32_t _has_storage_[1];
  uint32_t bindUin;
  uint32_t status;
  uint32_t pluginFlag;
  uint32_t regType;
  uint32_t safeDevice;
  uint32_t pushMailStatus;
  NSString *userName;
  NSString *nickName;
  NSString *bindEmail;
  NSString *bindMobile;
  NSString *alias;
  NSString *deviceInfoXml;
  NSString *officialUserName;
  NSString *officialNickName;
  NSString *fsurl;
} AcctSectResp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindUin",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_BindUin,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, bindUin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bindEmail",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_BindEmail,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, bindEmail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindMobile",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_BindMobile,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, bindMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_Alias,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, alias),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_Status,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "pluginFlag",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_PluginFlag,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, pluginFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "regType",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_RegType,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, regType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceInfoXml",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_DeviceInfoXml,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, deviceInfoXml),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "safeDevice",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_SafeDevice,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, safeDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "officialUserName",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_OfficialUserName,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, officialUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "officialNickName",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_OfficialNickName,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, officialNickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushMailStatus",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_PushMailStatus,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, pushMailStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fsurl",
        .dataTypeSpecific.className = NULL,
        .number = AcctSectResp_FieldNumber_Fsurl,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(AcctSectResp__storage_, fsurl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AcctSectResp class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AcctSectResp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\017\001H\000\002H\000\003G\000\004I\000\005J\000\006E\000\010F\000\tJ\000\nG\000\013M\000\014J\000\rP\000\016P\000"
        "\017N\000\020e\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UnifyAuthResponse

@implementation UnifyAuthResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasUnifyAuthSectFlag, unifyAuthSectFlag;
@dynamic hasAuthSectResp, authSectResp;
@dynamic hasAcctSectResp, acctSectResp;
@dynamic hasNetworkSectResp, networkSectResp;

typedef struct UnifyAuthResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t unifyAuthSectFlag;
  BaseResponse *baseResponse;
  AuthSectResp *authSectResp;
  AcctSectResp *acctSectResp;
  NetworkSectResp *networkSectResp;
} UnifyAuthResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = UnifyAuthResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unifyAuthSectFlag",
        .dataTypeSpecific.className = NULL,
        .number = UnifyAuthResponse_FieldNumber_UnifyAuthSectFlag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, unifyAuthSectFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "authSectResp",
        .dataTypeSpecific.className = GPBStringifySymbol(AuthSectResp),
        .number = UnifyAuthResponse_FieldNumber_AuthSectResp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, authSectResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "acctSectResp",
        .dataTypeSpecific.className = GPBStringifySymbol(AcctSectResp),
        .number = UnifyAuthResponse_FieldNumber_AcctSectResp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, acctSectResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkSectResp",
        .dataTypeSpecific.className = GPBStringifySymbol(NetworkSectResp),
        .number = UnifyAuthResponse_FieldNumber_NetworkSectResp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(UnifyAuthResponse__storage_, networkSectResp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UnifyAuthResponse class]
                                     rootClass:[MmloginRoot class]
                                          file:MmloginRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UnifyAuthResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001L\000\002Q\000\003L\000\004L\000\005O\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
