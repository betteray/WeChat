// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmbackup.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Mmbackup.pbobjc.h"
#import "Mmbuiltintype.pbobjc.h"
#import "Mmbase.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmbackupRoot

@implementation MmbackupRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MmbackupRoot_FileDescriptor

static GPBFileDescriptor *MmbackupRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"micromsg"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - Enum TransferTypeEnum

GPBEnumDescriptor *TransferTypeEnum_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "TransferNew\000TransferAddon\000";
    static const int32_t values[] = {
        TransferTypeEnum_TransferNew,
        TransferTypeEnum_TransferAddon,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TransferTypeEnum)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TransferTypeEnum_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TransferTypeEnum_IsValidValue(int32_t value__) {
  switch (value__) {
    case TransferTypeEnum_TransferNew:
    case TransferTypeEnum_TransferAddon:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum CommandTypeEnum

GPBEnumDescriptor *CommandTypeEnum_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CommandRequestToBackup\000CommandConfirmBac"
        "kup\000CommandRequestToRecover\000CommandConfi"
        "rmRecover\000CommandRequestToContinueBackup"
        "\000CommandConfirmContinueBackup\000CommandReq"
        "uestToContinueRecover\000CommandConfirmCont"
        "inueRecover\000";
    static const int32_t values[] = {
        CommandTypeEnum_CommandRequestToBackup,
        CommandTypeEnum_CommandConfirmBackup,
        CommandTypeEnum_CommandRequestToRecover,
        CommandTypeEnum_CommandConfirmRecover,
        CommandTypeEnum_CommandRequestToContinueBackup,
        CommandTypeEnum_CommandConfirmContinueBackup,
        CommandTypeEnum_CommandRequestToContinueRecover,
        CommandTypeEnum_CommandConfirmContinueRecover,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(CommandTypeEnum)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:CommandTypeEnum_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL CommandTypeEnum_IsValidValue(int32_t value__) {
  switch (value__) {
    case CommandTypeEnum_CommandRequestToBackup:
    case CommandTypeEnum_CommandConfirmBackup:
    case CommandTypeEnum_CommandRequestToRecover:
    case CommandTypeEnum_CommandConfirmRecover:
    case CommandTypeEnum_CommandRequestToContinueBackup:
    case CommandTypeEnum_CommandConfirmContinueBackup:
    case CommandTypeEnum_CommandRequestToContinueRecover:
    case CommandTypeEnum_CommandConfirmContinueRecover:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum StartResponseStatusEnum

GPBEnumDescriptor *StartResponseStatusEnum_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "StartResponseSuccess\000StartResponseIdWron"
        "g\000StartResponseSizeWrong\000";
    static const int32_t values[] = {
        StartResponseStatusEnum_StartResponseSuccess,
        StartResponseStatusEnum_StartResponseIdWrong,
        StartResponseStatusEnum_StartResponseSizeWrong,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(StartResponseStatusEnum)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:StartResponseStatusEnum_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL StartResponseStatusEnum_IsValidValue(int32_t value__) {
  switch (value__) {
    case StartResponseStatusEnum_StartResponseSuccess:
    case StartResponseStatusEnum_StartResponseIdWrong:
    case StartResponseStatusEnum_StartResponseSizeWrong:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ConnectInfoAddr

@implementation ConnectInfoAddr

@dynamic hasIp, ip;
@dynamic portArray, portArray_Count;
@dynamic hasPortCount, portCount;

typedef struct ConnectInfoAddr__storage_ {
  uint32_t _has_storage_[1];
  uint32_t portCount;
  NSString *ip;
  GPBUInt32Array *portArray;
} ConnectInfoAddr__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = ConnectInfoAddr_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConnectInfoAddr__storage_, ip),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "portArray",
        .dataTypeSpecific.className = NULL,
        .number = ConnectInfoAddr_FieldNumber_PortArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ConnectInfoAddr__storage_, portArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "portCount",
        .dataTypeSpecific.className = NULL,
        .number = ConnectInfoAddr_FieldNumber_PortCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConnectInfoAddr__storage_, portCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConnectInfoAddr class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConnectInfoAddr__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001b\000\002\000Port\000\003I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BakChatCreateQRCodeRequest

@implementation BakChatCreateQRCodeRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasAddrCount, addrCount;
@dynamic addrListArray, addrListArray_Count;
@dynamic hasPcname, pcname;
@dynamic hasPcacctName, pcacctName;
@dynamic hasScene, scene;
@dynamic hasDataSize, dataSize;
@dynamic hasWifiName, wifiName;
@dynamic hasOp, op;

typedef struct BakChatCreateQRCodeRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t addrCount;
  uint32_t scene;
  int32_t op;
  BaseRequest *baseRequest;
  NSMutableArray *addrListArray;
  NSString *pcname;
  NSString *pcacctName;
  NSString *wifiName;
  uint64_t dataSize;
} BakChatCreateQRCodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BakChatCreateQRCodeRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BakChatCreateQRCodeRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "addrCount",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRCodeRequest_FieldNumber_AddrCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BakChatCreateQRCodeRequest__storage_, addrCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "addrListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ConnectInfoAddr),
        .number = BakChatCreateQRCodeRequest_FieldNumber_AddrListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BakChatCreateQRCodeRequest__storage_, addrListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pcname",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRCodeRequest_FieldNumber_Pcname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BakChatCreateQRCodeRequest__storage_, pcname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcacctName",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRCodeRequest_FieldNumber_PcacctName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BakChatCreateQRCodeRequest__storage_, pcacctName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRCodeRequest_FieldNumber_Scene,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BakChatCreateQRCodeRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dataSize",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRCodeRequest_FieldNumber_DataSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BakChatCreateQRCodeRequest__storage_, dataSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "wifiName",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRCodeRequest_FieldNumber_WifiName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BakChatCreateQRCodeRequest__storage_, wifiName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "op",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRCodeRequest_FieldNumber_Op,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BakChatCreateQRCodeRequest__storage_, op),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BakChatCreateQRCodeRequest class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BakChatCreateQRCodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001K\000\002I\000\003\000AddrList\000\004c\003\000\005c\007\000\006E\000\007H\000\010H\000\tB\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BakChatCreateQRcodeResponse

@implementation BakChatCreateQRcodeResponse

@dynamic hasRet, ret;
@dynamic hasQrcodeBuffer, qrcodeBuffer;
@dynamic hasQrcodeURL, qrcodeURL;
@dynamic hasKey, key;
@dynamic hasHello, hello;
@dynamic hasOk, ok;
@dynamic hasEncryFlag, encryFlag;
@dynamic hasId_p, id_p;
@dynamic hasTickit, tickit;

typedef struct BakChatCreateQRcodeResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t ret;
  uint32_t encryFlag;
  SKBuiltinBuffer_t *qrcodeBuffer;
  NSString *qrcodeURL;
  SKBuiltinBuffer_t *key;
  NSString *hello;
  NSString *ok;
  NSString *id_p;
  NSString *tickit;
} BakChatCreateQRcodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRcodeResponse_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BakChatCreateQRcodeResponse__storage_, ret),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "qrcodeBuffer",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BakChatCreateQRcodeResponse_FieldNumber_QrcodeBuffer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BakChatCreateQRcodeResponse__storage_, qrcodeBuffer),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "qrcodeURL",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRcodeResponse_FieldNumber_QrcodeURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BakChatCreateQRcodeResponse__storage_, qrcodeURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = BakChatCreateQRcodeResponse_FieldNumber_Key,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BakChatCreateQRcodeResponse__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hello",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRcodeResponse_FieldNumber_Hello,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BakChatCreateQRcodeResponse__storage_, hello),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ok",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRcodeResponse_FieldNumber_Ok,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BakChatCreateQRcodeResponse__storage_, ok),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encryFlag",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRcodeResponse_FieldNumber_EncryFlag,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BakChatCreateQRcodeResponse__storage_, encryFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRcodeResponse_FieldNumber_Id_p,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BakChatCreateQRcodeResponse__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tickit",
        .dataTypeSpecific.className = NULL,
        .number = BakChatCreateQRcodeResponse_FieldNumber_Tickit,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BakChatCreateQRcodeResponse__storage_, tickit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BakChatCreateQRcodeResponse class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BakChatCreateQRcodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001C\000\002c\t\000\003c\004!!\000\004C\000\005E\000\006b\000\007I\000\010\000ID\000\tF\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PacketAuthenticateRequest

@implementation PacketAuthenticateRequest

@dynamic hasStep, step;
@dynamic hasId_p, id_p;
@dynamic hasData_p, data_p;
@dynamic hasVersion, version;
@dynamic hasType, type;
@dynamic hasSupportExt, supportExt;

typedef struct PacketAuthenticateRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t step;
  int32_t version;
  int32_t type;
  int32_t supportExt;
  NSString *id_p;
  NSData *data_p;
} PacketAuthenticateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "step",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateRequest_FieldNumber_Step,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PacketAuthenticateRequest__storage_, step),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateRequest_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PacketAuthenticateRequest__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateRequest_FieldNumber_Data_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PacketAuthenticateRequest__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateRequest_FieldNumber_Version,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PacketAuthenticateRequest__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateRequest_FieldNumber_Type,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PacketAuthenticateRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "supportExt",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateRequest_FieldNumber_SupportExt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PacketAuthenticateRequest__storage_, supportExt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PacketAuthenticateRequest class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PacketAuthenticateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001D\000\002\000ID\000\003\000Data\000\004G\000\005D\000\006J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PacketAuthenticateResponse

@implementation PacketAuthenticateResponse

@dynamic hasStep, step;
@dynamic hasStatus, status;
@dynamic hasId_p, id_p;
@dynamic hasData_p, data_p;
@dynamic hasVersion, version;
@dynamic hasType, type;
@dynamic hasSupportExt, supportExt;

typedef struct PacketAuthenticateResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t step;
  int32_t status;
  int32_t version;
  int32_t type;
  int32_t supportExt;
  NSString *id_p;
  NSData *data_p;
} PacketAuthenticateResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "step",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateResponse_FieldNumber_Step,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PacketAuthenticateResponse__storage_, step),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateResponse_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PacketAuthenticateResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateResponse_FieldNumber_Id_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PacketAuthenticateResponse__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateResponse_FieldNumber_Data_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PacketAuthenticateResponse__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateResponse_FieldNumber_Version,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PacketAuthenticateResponse__storage_, version),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateResponse_FieldNumber_Type,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PacketAuthenticateResponse__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "supportExt",
        .dataTypeSpecific.className = NULL,
        .number = PacketAuthenticateResponse_FieldNumber_SupportExt,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PacketAuthenticateResponse__storage_, supportExt),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PacketAuthenticateResponse class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PacketAuthenticateResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001D\000\002F\000\003\000ID\000\004\000Data\000\005G\000\006D\000\007J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupStartGeneralInfo

@implementation BackupStartGeneralInfo

@dynamic hasDeviceId, deviceId;
@dynamic hasDeviceName, deviceName;
@dynamic hasModel, model;
@dynamic hasSystemName, systemName;
@dynamic hasSystemVersion, systemVersion;
@dynamic hasWechatVersion, wechatVersion;
@dynamic hasDeviceFreeSpace, deviceFreeSpace;

typedef struct BackupStartGeneralInfo__storage_ {
  uint32_t _has_storage_[1];
  uint32_t wechatVersion;
  NSString *deviceId;
  NSString *deviceName;
  NSString *model;
  NSString *systemName;
  NSString *systemVersion;
  uint64_t deviceFreeSpace;
} BackupStartGeneralInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartGeneralInfo_FieldNumber_DeviceId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupStartGeneralInfo__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartGeneralInfo_FieldNumber_DeviceName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BackupStartGeneralInfo__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartGeneralInfo_FieldNumber_Model,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BackupStartGeneralInfo__storage_, model),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "systemName",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartGeneralInfo_FieldNumber_SystemName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BackupStartGeneralInfo__storage_, systemName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "systemVersion",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartGeneralInfo_FieldNumber_SystemVersion,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BackupStartGeneralInfo__storage_, systemVersion),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wechatVersion",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartGeneralInfo_FieldNumber_WechatVersion,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BackupStartGeneralInfo__storage_, wechatVersion),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceFreeSpace",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartGeneralInfo_FieldNumber_DeviceFreeSpace,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BackupStartGeneralInfo__storage_, deviceFreeSpace),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupStartGeneralInfo class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupStartGeneralInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001GA\000\002J\000\003E\000\004J\000\005M\000\006M\000\007O\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupStartRequest

@implementation BackupStartRequest

@dynamic hasId_p, id_p;
@dynamic hasBigDataSize, bigDataSize;
@dynamic hasSessionCount, sessionCount;
@dynamic hasMsgCount, msgCount;
@dynamic hasGeneralInfo, generalInfo;
@dynamic hasDataSize, dataSize;
@dynamic hasTransferType, transferType;

typedef struct BackupStartRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t transferType;
  NSString *id_p;
  BackupStartGeneralInfo *generalInfo;
  uint64_t bigDataSize;
  uint64_t sessionCount;
  uint64_t msgCount;
  uint64_t dataSize;
} BackupStartRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupStartRequest__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bigDataSize",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartRequest_FieldNumber_BigDataSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BackupStartRequest__storage_, bigDataSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "sessionCount",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartRequest_FieldNumber_SessionCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BackupStartRequest__storage_, sessionCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "msgCount",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartRequest_FieldNumber_MsgCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BackupStartRequest__storage_, msgCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "generalInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(BackupStartGeneralInfo),
        .number = BackupStartRequest_FieldNumber_GeneralInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BackupStartRequest__storage_, generalInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dataSize",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartRequest_FieldNumber_DataSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BackupStartRequest__storage_, dataSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "transferType",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartRequest_FieldNumber_TransferType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BackupStartRequest__storage_, transferType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupStartRequest class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupStartRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\000ID\000\002K\000\003L\000\004H\000\005K\000\006H\000\007L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupStartResponse

@implementation BackupStartResponse

@dynamic hasId_p, id_p;
@dynamic hasTotalCount, totalCount;
@dynamic hasTotalSize, totalSize;
@dynamic hasStatus, status;
@dynamic hasNetworkState, networkState;
@dynamic hasBigDataSize, bigDataSize;
@dynamic hasGeneralInfo, generalInfo;

typedef struct BackupStartResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  uint32_t networkState;
  NSString *id_p;
  BackupStartGeneralInfo *generalInfo;
  uint64_t totalCount;
  uint64_t totalSize;
  uint64_t bigDataSize;
} BackupStartResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartResponse_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupStartResponse__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalCount",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartResponse_FieldNumber_TotalCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BackupStartResponse__storage_, totalCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "totalSize",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartResponse_FieldNumber_TotalSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BackupStartResponse__storage_, totalSize),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartResponse_FieldNumber_Status,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BackupStartResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "networkState",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartResponse_FieldNumber_NetworkState,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BackupStartResponse__storage_, networkState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "bigDataSize",
        .dataTypeSpecific.className = NULL,
        .number = BackupStartResponse_FieldNumber_BigDataSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BackupStartResponse__storage_, bigDataSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "generalInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(BackupStartGeneralInfo),
        .number = BackupStartResponse_FieldNumber_GeneralInfo,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BackupStartResponse__storage_, generalInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupStartResponse class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupStartResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\000ID\000\002J\000\003I\000\004F\000\005L\000\006K\000\007K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupRequestSession

@implementation BackupRequestSession

@dynamic sessionNameArray, sessionNameArray_Count;
@dynamic timeIntervalArray, timeIntervalArray_Count;

typedef struct BackupRequestSession__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *sessionNameArray;
  GPBInt64Array *timeIntervalArray;
} BackupRequestSession__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionNameArray",
        .dataTypeSpecific.className = NULL,
        .number = BackupRequestSession_FieldNumber_SessionNameArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BackupRequestSession__storage_, sessionNameArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeIntervalArray",
        .dataTypeSpecific.className = NULL,
        .number = BackupRequestSession_FieldNumber_TimeIntervalArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BackupRequestSession__storage_, timeIntervalArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupRequestSession class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupRequestSession__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000SessionName\000\002\000TimeInterval\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupRequestSessionResponse

@implementation BackupRequestSessionResponse

@dynamic sessionNameArray, sessionNameArray_Count;
@dynamic timeIntervalArray, timeIntervalArray_Count;

typedef struct BackupRequestSessionResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *sessionNameArray;
  GPBInt64Array *timeIntervalArray;
} BackupRequestSessionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionNameArray",
        .dataTypeSpecific.className = NULL,
        .number = BackupRequestSessionResponse_FieldNumber_SessionNameArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BackupRequestSessionResponse__storage_, sessionNameArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeIntervalArray",
        .dataTypeSpecific.className = NULL,
        .number = BackupRequestSessionResponse_FieldNumber_TimeIntervalArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BackupRequestSessionResponse__storage_, timeIntervalArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupRequestSessionResponse class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupRequestSessionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000SessionName\000\002\000TimeInterval\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PacketBackupDataPush

@implementation PacketBackupDataPush

@dynamic hasDataId, dataId;
@dynamic hasDataType, dataType;
@dynamic hasDataSize, dataSize;
@dynamic hasStartOffset, startOffset;
@dynamic hasEndOffset, endOffset;
@dynamic hasCheckSum, checkSum;
@dynamic hasData_p, data_p;
@dynamic hasProgress, progress;

typedef struct PacketBackupDataPush__storage_ {
  uint32_t _has_storage_[1];
  int32_t dataType;
  int32_t dataSize;
  int32_t startOffset;
  int32_t endOffset;
  int32_t checkSum;
  int32_t progress;
  NSString *dataId;
  NSData *data_p;
} PacketBackupDataPush__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataId",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataPush_FieldNumber_DataId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PacketBackupDataPush__storage_, dataId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dataType",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataPush_FieldNumber_DataType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PacketBackupDataPush__storage_, dataType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dataSize",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataPush_FieldNumber_DataSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PacketBackupDataPush__storage_, dataSize),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startOffset",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataPush_FieldNumber_StartOffset,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PacketBackupDataPush__storage_, startOffset),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "endOffset",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataPush_FieldNumber_EndOffset,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PacketBackupDataPush__storage_, endOffset),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "checkSum",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataPush_FieldNumber_CheckSum,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(PacketBackupDataPush__storage_, checkSum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataPush_FieldNumber_Data_p,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(PacketBackupDataPush__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "progress",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataPush_FieldNumber_Progress,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(PacketBackupDataPush__storage_, progress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PacketBackupDataPush class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PacketBackupDataPush__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001EA\000\002H\000\003H\000\004K\000\005I\000\006H\000\007\000Data\000\010H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PacketBackupDataResponse

@implementation PacketBackupDataResponse

@dynamic hasDataId, dataId;
@dynamic hasDataType, dataType;
@dynamic hasStartOffset, startOffset;
@dynamic hasEndOffset, endOffset;
@dynamic hasStatus, status;

typedef struct PacketBackupDataResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t dataType;
  int32_t startOffset;
  int32_t endOffset;
  int32_t status;
  NSString *dataId;
} PacketBackupDataResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataId",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataResponse_FieldNumber_DataId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PacketBackupDataResponse__storage_, dataId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dataType",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataResponse_FieldNumber_DataType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PacketBackupDataResponse__storage_, dataType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startOffset",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataResponse_FieldNumber_StartOffset,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PacketBackupDataResponse__storage_, startOffset),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "endOffset",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataResponse_FieldNumber_EndOffset,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PacketBackupDataResponse__storage_, endOffset),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataResponse_FieldNumber_Status,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PacketBackupDataResponse__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PacketBackupDataResponse class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PacketBackupDataResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001EA\000\002H\000\003K\000\004I\000\005F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PacketSvrIDRequest

@implementation PacketSvrIDRequest

@dynamic svrIdArray, svrIdArray_Count;
@dynamic mediaIdArray, mediaIdArray_Count;
@dynamic md5Array, md5Array_Count;
@dynamic hasBakChatName, bakChatName;

typedef struct PacketSvrIDRequest__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *svrIdArray;
  NSMutableArray *mediaIdArray;
  NSMutableArray *md5Array;
  NSString *bakChatName;
} PacketSvrIDRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "svrIdArray",
        .dataTypeSpecific.className = NULL,
        .number = PacketSvrIDRequest_FieldNumber_SvrIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PacketSvrIDRequest__storage_, svrIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "mediaIdArray",
        .dataTypeSpecific.className = NULL,
        .number = PacketSvrIDRequest_FieldNumber_MediaIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PacketSvrIDRequest__storage_, mediaIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "md5Array",
        .dataTypeSpecific.className = NULL,
        .number = PacketSvrIDRequest_FieldNumber_Md5Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PacketSvrIDRequest__storage_, md5Array),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bakChatName",
        .dataTypeSpecific.className = NULL,
        .number = PacketSvrIDRequest_FieldNumber_BakChatName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PacketSvrIDRequest__storage_, bakChatName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PacketSvrIDRequest class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PacketSvrIDRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\000SvrID\000\002\000MediaID\000\003\000MD5\000\004K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PacketSvrIDResponse

@implementation PacketSvrIDResponse

@dynamic svrIdArray, svrIdArray_Count;
@dynamic mediaIdArray, mediaIdArray_Count;
@dynamic md5Array, md5Array_Count;
@dynamic hasBakChatName, bakChatName;

typedef struct PacketSvrIDResponse__storage_ {
  uint32_t _has_storage_[1];
  GPBUInt64Array *svrIdArray;
  NSMutableArray *mediaIdArray;
  NSMutableArray *md5Array;
  NSString *bakChatName;
} PacketSvrIDResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "svrIdArray",
        .dataTypeSpecific.className = NULL,
        .number = PacketSvrIDResponse_FieldNumber_SvrIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PacketSvrIDResponse__storage_, svrIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "mediaIdArray",
        .dataTypeSpecific.className = NULL,
        .number = PacketSvrIDResponse_FieldNumber_MediaIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PacketSvrIDResponse__storage_, mediaIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "md5Array",
        .dataTypeSpecific.className = NULL,
        .number = PacketSvrIDResponse_FieldNumber_Md5Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PacketSvrIDResponse__storage_, md5Array),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bakChatName",
        .dataTypeSpecific.className = NULL,
        .number = PacketSvrIDResponse_FieldNumber_BakChatName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PacketSvrIDResponse__storage_, bakChatName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PacketSvrIDResponse class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PacketSvrIDResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\000SvrID\000\002\000MediaID\000\003\000MD5\000\004K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PacketBackupDataTag

@implementation PacketBackupDataTag

@dynamic hasBakChatName, bakChatName;
@dynamic hasStartTime, startTime;
@dynamic hasEndTime, endTime;
@dynamic hasMsgDataId, msgDataId;
@dynamic hasNickName, nickName;
@dynamic mediaIdlistArray, mediaIdlistArray_Count;

typedef struct PacketBackupDataTag__storage_ {
  uint32_t _has_storage_[1];
  NSString *bakChatName;
  NSString *msgDataId;
  NSString *nickName;
  NSMutableArray *mediaIdlistArray;
  int64_t startTime;
  int64_t endTime;
} PacketBackupDataTag__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bakChatName",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataTag_FieldNumber_BakChatName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PacketBackupDataTag__storage_, bakChatName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataTag_FieldNumber_StartTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PacketBackupDataTag__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataTag_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PacketBackupDataTag__storage_, endTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgDataId",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataTag_FieldNumber_MsgDataId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PacketBackupDataTag__storage_, msgDataId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataTag_FieldNumber_NickName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PacketBackupDataTag__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "mediaIdlistArray",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataTag_FieldNumber_MediaIdlistArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PacketBackupDataTag__storage_, mediaIdlistArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PacketBackupDataTag class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PacketBackupDataTag__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001K\000\002I\000\003G\000\004HA\000\005H\000\006\000MediaIDList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PacketBackupDataTagResponse

@implementation PacketBackupDataTagResponse

@dynamic hasBakChatName, bakChatName;
@dynamic hasStartTime, startTime;
@dynamic hasEndTime, endTime;
@dynamic hasMsgDataId, msgDataId;

typedef struct PacketBackupDataTagResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *bakChatName;
  NSString *msgDataId;
  int64_t startTime;
  int64_t endTime;
} PacketBackupDataTagResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bakChatName",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataTagResponse_FieldNumber_BakChatName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PacketBackupDataTagResponse__storage_, bakChatName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataTagResponse_FieldNumber_StartTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PacketBackupDataTagResponse__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataTagResponse_FieldNumber_EndTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PacketBackupDataTagResponse__storage_, endTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgDataId",
        .dataTypeSpecific.className = NULL,
        .number = PacketBackupDataTagResponse_FieldNumber_MsgDataId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PacketBackupDataTagResponse__storage_, msgDataId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PacketBackupDataTagResponse class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PacketBackupDataTagResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001K\000\002I\000\003G\000\004HA\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupReportItem

@implementation BackupReportItem

@dynamic hasBakChatName, bakChatName;
@dynamic hasMsgCount, msgCount;

typedef struct BackupReportItem__storage_ {
  uint32_t _has_storage_[1];
  uint32_t msgCount;
  NSString *bakChatName;
} BackupReportItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bakChatName",
        .dataTypeSpecific.className = NULL,
        .number = BackupReportItem_FieldNumber_BakChatName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupReportItem__storage_, bakChatName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "msgCount",
        .dataTypeSpecific.className = NULL,
        .number = BackupReportItem_FieldNumber_MsgCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BackupReportItem__storage_, msgCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupReportItem class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupReportItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupReportList

@implementation BackupReportList

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct BackupReportList__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  NSMutableArray *listArray;
} BackupReportList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = BackupReportList_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupReportList__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BackupReportItem),
        .number = BackupReportList_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BackupReportList__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupReportList class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupReportList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001E\000\002\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupFinishRequest

@implementation BackupFinishRequest

@dynamic hasId_p, id_p;
@dynamic hasData_p, data_p;
@dynamic hasServerSessionCount, serverSessionCount;
@dynamic hasServerMessageCount, serverMessageCount;
@dynamic hasServerFileCount, serverFileCount;
@dynamic hasCalculateSize, calculateSize;
@dynamic hasServerDataPushSize, serverDataPushSize;
@dynamic hasServerReadDbtotalTime, serverReadDbtotalTime;
@dynamic hasServerReadFileTotalTime, serverReadFileTotalTime;
@dynamic hasServerCostTotalTime, serverCostTotalTime;
@dynamic hasServerVersion, serverVersion;

typedef struct BackupFinishRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t serverSessionCount;
  uint32_t serverMessageCount;
  uint32_t serverFileCount;
  uint32_t calculateSize;
  uint32_t serverDataPushSize;
  uint32_t serverReadDbtotalTime;
  uint32_t serverReadFileTotalTime;
  uint32_t serverCostTotalTime;
  uint32_t serverVersion;
  NSString *id_p;
  BackupReportList *data_p;
} BackupFinishRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = BackupFinishRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupFinishRequest__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(BackupReportList),
        .number = BackupFinishRequest_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BackupFinishRequest__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serverSessionCount",
        .dataTypeSpecific.className = NULL,
        .number = BackupFinishRequest_FieldNumber_ServerSessionCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BackupFinishRequest__storage_, serverSessionCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "serverMessageCount",
        .dataTypeSpecific.className = NULL,
        .number = BackupFinishRequest_FieldNumber_ServerMessageCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BackupFinishRequest__storage_, serverMessageCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "serverFileCount",
        .dataTypeSpecific.className = NULL,
        .number = BackupFinishRequest_FieldNumber_ServerFileCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BackupFinishRequest__storage_, serverFileCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "calculateSize",
        .dataTypeSpecific.className = NULL,
        .number = BackupFinishRequest_FieldNumber_CalculateSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BackupFinishRequest__storage_, calculateSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "serverDataPushSize",
        .dataTypeSpecific.className = NULL,
        .number = BackupFinishRequest_FieldNumber_ServerDataPushSize,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BackupFinishRequest__storage_, serverDataPushSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "serverReadDbtotalTime",
        .dataTypeSpecific.className = NULL,
        .number = BackupFinishRequest_FieldNumber_ServerReadDbtotalTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BackupFinishRequest__storage_, serverReadDbtotalTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "serverReadFileTotalTime",
        .dataTypeSpecific.className = NULL,
        .number = BackupFinishRequest_FieldNumber_ServerReadFileTotalTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(BackupFinishRequest__storage_, serverReadFileTotalTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "serverCostTotalTime",
        .dataTypeSpecific.className = NULL,
        .number = BackupFinishRequest_FieldNumber_ServerCostTotalTime,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(BackupFinishRequest__storage_, serverCostTotalTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "serverVersion",
        .dataTypeSpecific.className = NULL,
        .number = BackupFinishRequest_FieldNumber_ServerVersion,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(BackupFinishRequest__storage_, serverVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupFinishRequest class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupFinishRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\013\001\000ID\000\002\000Data\000\003R\000\004R\000\005O\000\006M\000\007R\000\010Kb\010\000\tW\000\nS\000\013"
        "M\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupCommandRequest

@implementation BackupCommandRequest

@dynamic hasCommand, command;
@dynamic hasData_p, data_p;

typedef struct BackupCommandRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t command;
  NSData *data_p;
} BackupCommandRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "command",
        .dataTypeSpecific.className = NULL,
        .number = BackupCommandRequest_FieldNumber_Command,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupCommandRequest__storage_, command),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = BackupCommandRequest_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BackupCommandRequest__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupCommandRequest class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupCommandRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001G\000\002\000Data\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupCommandResponse

@implementation BackupCommandResponse

@dynamic hasCommand, command;
@dynamic hasData_p, data_p;

typedef struct BackupCommandResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t command;
  NSData *data_p;
} BackupCommandResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "command",
        .dataTypeSpecific.className = NULL,
        .number = BackupCommandResponse_FieldNumber_Command,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupCommandResponse__storage_, command),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = BackupCommandResponse_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BackupCommandResponse__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupCommandResponse class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupCommandResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001G\000\002\000Data\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DataConfigInf

@implementation DataConfigInf

@dynamic hasUserName, userName;
@dynamic hasDeviceid, deviceid;
@dynamic hasCreateTime, createTime;
@dynamic hasLastModifyTime, lastModifyTime;
@dynamic hasDeviceInfo, deviceInfo;

typedef struct DataConfigInf__storage_ {
  uint32_t _has_storage_[1];
  uint32_t createTime;
  uint32_t lastModifyTime;
  NSString *userName;
  NSString *deviceid;
  BackupStartGeneralInfo *deviceInfo;
} DataConfigInf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = DataConfigInf_FieldNumber_UserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DataConfigInf__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceid",
        .dataTypeSpecific.className = NULL,
        .number = DataConfigInf_FieldNumber_Deviceid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DataConfigInf__storage_, deviceid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = DataConfigInf_FieldNumber_CreateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DataConfigInf__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "lastModifyTime",
        .dataTypeSpecific.className = NULL,
        .number = DataConfigInf_FieldNumber_LastModifyTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DataConfigInf__storage_, lastModifyTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "deviceInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(BackupStartGeneralInfo),
        .number = DataConfigInf_FieldNumber_DeviceInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DataConfigInf__storage_, deviceInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DataConfigInf class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DataConfigInf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001H\000\002H\000\003J\000\004N\000\005J\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupCancelRequest

@implementation BackupCancelRequest

@dynamic hasId_p, id_p;
@dynamic hasReason, reason;

typedef struct BackupCancelRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t reason;
  NSString *id_p;
} BackupCancelRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = BackupCancelRequest_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupCancelRequest__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "reason",
        .dataTypeSpecific.className = NULL,
        .number = BackupCancelRequest_FieldNumber_Reason,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BackupCancelRequest__storage_, reason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupCancelRequest class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupCancelRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\000ID\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConnectInfoRequest

@implementation GetConnectInfoRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasURL, URL;

typedef struct GetConnectInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *URL;
} GetConnectInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetConnectInfoRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConnectInfoRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoRequest_FieldNumber_URL,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetConnectInfoRequest__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConnectInfoRequest class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConnectInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001K\000\002\003\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConnectInfoResponse

@implementation GetConnectInfoResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasId_p, id_p;
@dynamic hasKey, key;
@dynamic hasHello, hello;
@dynamic hasOk, ok;
@dynamic hasType, type;
@dynamic hasAddrCount, addrCount;
@dynamic addrListArray, addrListArray_Count;
@dynamic hasResource, resource;
@dynamic hasPcname, pcname;
@dynamic hasPcacctName, pcacctName;
@dynamic hasEncryFlag, encryFlag;
@dynamic hasScene, scene;
@dynamic hasDataSize, dataSize;
@dynamic hasWifiName, wifiName;

typedef struct GetConnectInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t addrCount;
  uint32_t encryFlag;
  uint32_t scene;
  BaseResponse *baseResponse;
  NSString *id_p;
  SKBuiltinBuffer_t *key;
  NSString *hello;
  NSString *ok;
  NSMutableArray *addrListArray;
  NSString *resource;
  NSString *pcname;
  NSString *pcacctName;
  NSString *wifiName;
  uint64_t dataSize;
} GetConnectInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetConnectInfoResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoResponse_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetConnectInfoResponse_FieldNumber_Key,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, key),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "hello",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoResponse_FieldNumber_Hello,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, hello),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ok",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoResponse_FieldNumber_Ok,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, ok),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoResponse_FieldNumber_Type,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "addrCount",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoResponse_FieldNumber_AddrCount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, addrCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "addrListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ConnectInfoAddr),
        .number = GetConnectInfoResponse_FieldNumber_AddrListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, addrListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "resource",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoResponse_FieldNumber_Resource,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, resource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcname",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoResponse_FieldNumber_Pcname,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, pcname),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pcacctName",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoResponse_FieldNumber_PcacctName,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, pcacctName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encryFlag",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoResponse_FieldNumber_EncryFlag,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, encryFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoResponse_FieldNumber_Scene,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dataSize",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoResponse_FieldNumber_DataSize,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, dataSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "wifiName",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectInfoResponse_FieldNumber_WifiName,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(GetConnectInfoResponse__storage_, wifiName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConnectInfoResponse class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConnectInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\017\001L\000\002\000ID\000\003C\000\004E\000\005b\000\006D\000\007I\000\010\000AddrList\000\tH\000\nc"
        "\003\000\013c\007\000\014I\000\rE\000\016H\000\017H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupHeartBeatRequest

@implementation BackupHeartBeatRequest

@dynamic hasAck, ack;

typedef struct BackupHeartBeatRequest__storage_ {
  uint32_t _has_storage_[1];
  uint64_t ack;
} BackupHeartBeatRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ack",
        .dataTypeSpecific.className = NULL,
        .number = BackupHeartBeatRequest_FieldNumber_Ack,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupHeartBeatRequest__storage_, ack),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupHeartBeatRequest class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupHeartBeatRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BackupHeartBeatResponse

@implementation BackupHeartBeatResponse

@dynamic hasAck, ack;

typedef struct BackupHeartBeatResponse__storage_ {
  uint32_t _has_storage_[1];
  uint64_t ack;
} BackupHeartBeatResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ack",
        .dataTypeSpecific.className = NULL,
        .number = BackupHeartBeatResponse_FieldNumber_Ack,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BackupHeartBeatResponse__storage_, ack),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BackupHeartBeatResponse class]
                                     rootClass:[MmbackupRoot class]
                                          file:MmbackupRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BackupHeartBeatResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
