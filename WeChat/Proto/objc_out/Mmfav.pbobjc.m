// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mmfav.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mmfav.pbobjc.h"
#import "Mmbuiltintype.pbobjc.h"
#import "Mmbase.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmfavRoot

@implementation MmfavRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - MmfavRoot_FileDescriptor

static GPBFileDescriptor *MmfavRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"micromsg"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - AddFavItem

@implementation AddFavItem

@dynamic hasFavId, favId;
@dynamic hasType, type;
@dynamic hasFlag, flag;
@dynamic hasUpdateTime, updateTime;
@dynamic hasUpdateSeq, updateSeq;

typedef struct AddFavItem__storage_ {
  uint32_t _has_storage_[1];
  int32_t favId;
  int32_t type;
  uint32_t flag;
  uint32_t updateTime;
  uint32_t updateSeq;
} AddFavItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "favId",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItem_FieldNumber_FavId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddFavItem__storage_, favId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItem_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddFavItem__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItem_FieldNumber_Flag,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddFavItem__storage_, flag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "updateTime",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItem_FieldNumber_UpdateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddFavItem__storage_, updateTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "updateSeq",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItem_FieldNumber_UpdateSeq,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AddFavItem__storage_, updateSeq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddFavItem class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddFavItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001E\000\002D\000\003D\000\004J\000\005I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckFavItemRequest

@implementation CheckFavItemRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasSourceType, sourceType;
@dynamic hasSourceId, sourceId;

typedef struct CheckFavItemRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t sourceType;
  BaseRequest *baseRequest;
  NSString *sourceId;
} CheckFavItemRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = CheckFavItemRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckFavItemRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sourceType",
        .dataTypeSpecific.className = NULL,
        .number = CheckFavItemRequest_FieldNumber_SourceType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckFavItemRequest__storage_, sourceType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sourceId",
        .dataTypeSpecific.className = NULL,
        .number = CheckFavItemRequest_FieldNumber_SourceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CheckFavItemRequest__storage_, sourceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckFavItemRequest class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckFavItemRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002J\000\003H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FavVideoInfo

@implementation FavVideoInfo

@dynamic hasFileId, fileId;
@dynamic hasAesKey, aesKey;
@dynamic hasVideoId, videoId;

typedef struct FavVideoInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *fileId;
  NSString *aesKey;
  NSString *videoId;
} FavVideoInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileId",
        .dataTypeSpecific.className = NULL,
        .number = FavVideoInfo_FieldNumber_FileId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FavVideoInfo__storage_, fileId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aesKey",
        .dataTypeSpecific.className = NULL,
        .number = FavVideoInfo_FieldNumber_AesKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FavVideoInfo__storage_, aesKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "videoId",
        .dataTypeSpecific.className = NULL,
        .number = FavVideoInfo_FieldNumber_VideoId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FavVideoInfo__storage_, videoId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FavVideoInfo class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FavVideoInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001F\000\002F\000\003G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShareFavKey

@implementation ShareFavKey

@dynamic hasFromUin, fromUin;
@dynamic hasToUser, toUser;
@dynamic hasShareTime, shareTime;
@dynamic hasScene, scene;
@dynamic hasFavId, favId;
@dynamic hasParamCheck, paramCheck;
@dynamic hasFavItemCheck, favItemCheck;

typedef struct ShareFavKey__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fromUin;
  uint32_t shareTime;
  uint32_t scene;
  uint32_t favId;
  NSString *toUser;
  NSString *paramCheck;
  NSString *favItemCheck;
} ShareFavKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fromUin",
        .dataTypeSpecific.className = NULL,
        .number = ShareFavKey_FieldNumber_FromUin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShareFavKey__storage_, fromUin),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "toUser",
        .dataTypeSpecific.className = NULL,
        .number = ShareFavKey_FieldNumber_ToUser,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShareFavKey__storage_, toUser),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shareTime",
        .dataTypeSpecific.className = NULL,
        .number = ShareFavKey_FieldNumber_ShareTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShareFavKey__storage_, shareTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = ShareFavKey_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShareFavKey__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "favId",
        .dataTypeSpecific.className = NULL,
        .number = ShareFavKey_FieldNumber_FavId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ShareFavKey__storage_, favId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "paramCheck",
        .dataTypeSpecific.className = NULL,
        .number = ShareFavKey_FieldNumber_ParamCheck,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ShareFavKey__storage_, paramCheck),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "favItemCheck",
        .dataTypeSpecific.className = NULL,
        .number = ShareFavKey_FieldNumber_FavItemCheck,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ShareFavKey__storage_, favItemCheck),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShareFavKey class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShareFavKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001G\000\002F\000\003I\000\004E\000\005E\000\006J\000\007L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckFavItemResponse

@implementation CheckFavItemResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct CheckFavItemResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} CheckFavItemResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = CheckFavItemResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckFavItemResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckFavItemResponse class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckFavItemResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModFavIndex

@implementation ModFavIndex

@dynamic hasModField, modField;
@dynamic hasModValue, modValue;

typedef struct ModFavIndex__storage_ {
  uint32_t _has_storage_[1];
  uint32_t modField;
  uint32_t modValue;
} ModFavIndex__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "modField",
        .dataTypeSpecific.className = NULL,
        .number = ModFavIndex_FieldNumber_ModField,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModFavIndex__storage_, modField),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "modValue",
        .dataTypeSpecific.className = NULL,
        .number = ModFavIndex_FieldNumber_ModValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModFavIndex__storage_, modValue),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModFavIndex class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModFavIndex__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\002H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModFavObject

@implementation ModFavObject

@dynamic hasTagName, tagName;
@dynamic hasAttrName, attrName;
@dynamic hasValue, value;
@dynamic hasType, type;

typedef struct ModFavObject__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  NSString *tagName;
  NSString *attrName;
  NSString *value;
} ModFavObject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tagName",
        .dataTypeSpecific.className = NULL,
        .number = ModFavObject_FieldNumber_TagName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModFavObject__storage_, tagName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "attrName",
        .dataTypeSpecific.className = NULL,
        .number = ModFavObject_FieldNumber_AttrName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModFavObject__storage_, attrName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = ModFavObject_FieldNumber_Value,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModFavObject__storage_, value),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ModFavObject_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModFavObject__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModFavObject class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModFavObject__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001G\000\002H\000\003E\000\004D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModFavItemRequest

@implementation ModFavItemRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasFavId, favId;
@dynamic hasIndexCount, indexCount;
@dynamic indexListArray, indexListArray_Count;
@dynamic hasObjectCount, objectCount;
@dynamic objectListArray, objectListArray_Count;

typedef struct ModFavItemRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t favId;
  uint32_t indexCount;
  uint32_t objectCount;
  BaseRequest *baseRequest;
  NSMutableArray *indexListArray;
  NSMutableArray *objectListArray;
} ModFavItemRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ModFavItemRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModFavItemRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "favId",
        .dataTypeSpecific.className = NULL,
        .number = ModFavItemRequest_FieldNumber_FavId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ModFavItemRequest__storage_, favId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "indexCount",
        .dataTypeSpecific.className = NULL,
        .number = ModFavItemRequest_FieldNumber_IndexCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ModFavItemRequest__storage_, indexCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "indexListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ModFavIndex),
        .number = ModFavItemRequest_FieldNumber_IndexListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ModFavItemRequest__storage_, indexListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "objectCount",
        .dataTypeSpecific.className = NULL,
        .number = ModFavItemRequest_FieldNumber_ObjectCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ModFavItemRequest__storage_, objectCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "objectListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ModFavObject),
        .number = ModFavItemRequest_FieldNumber_ObjectListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ModFavItemRequest__storage_, objectListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModFavItemRequest class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModFavItemRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001K\000\002E\000\003J\000\004\000IndexList\000\005K\000\006\000ObjectList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ModFavItemResponse

@implementation ModFavItemResponse

@dynamic hasBaseResponse, baseResponse;

typedef struct ModFavItemResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
} ModFavItemResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ModFavItemResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ModFavItemResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ModFavItemResponse class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ModFavItemResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShareFavRequest

@implementation ShareFavRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasToUser, toUser;
@dynamic hasScene, scene;
@dynamic hasCount, count;
@dynamic favIdListArray, favIdListArray_Count;

typedef struct ShareFavRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t scene;
  uint32_t count;
  BaseRequest *baseRequest;
  NSString *toUser;
  GPBUInt32Array *favIdListArray;
} ShareFavRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ShareFavRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShareFavRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toUser",
        .dataTypeSpecific.className = NULL,
        .number = ShareFavRequest_FieldNumber_ToUser,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShareFavRequest__storage_, toUser),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = ShareFavRequest_FieldNumber_Scene,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ShareFavRequest__storage_, scene),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = ShareFavRequest_FieldNumber_Count,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ShareFavRequest__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "favIdListArray",
        .dataTypeSpecific.className = NULL,
        .number = ShareFavRequest_FieldNumber_FavIdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShareFavRequest__storage_, favIdListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShareFavRequest class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShareFavRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001K\000\002F\000\003E\000\004E\000\005\000FavIdList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ShareFavResponse

@implementation ShareFavResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasURLCount, URLCount;
@dynamic URLListArray, URLListArray_Count;

typedef struct ShareFavResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t URLCount;
  BaseResponse *baseResponse;
  NSMutableArray *URLListArray;
} ShareFavResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = ShareFavResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ShareFavResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "URLCount",
        .dataTypeSpecific.className = NULL,
        .number = ShareFavResponse_FieldNumber_URLCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ShareFavResponse__storage_, URLCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "URLListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = ShareFavResponse_FieldNumber_URLListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ShareFavResponse__storage_, URLListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ShareFavResponse class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ShareFavResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002\001!&\000\003\000UrlList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddFavItemRequest

@implementation AddFavItemRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasClientId, clientId;
@dynamic hasType, type;
@dynamic hasSourceType, sourceType;
@dynamic hasSourceId, sourceId;
@dynamic hasObject, object;

typedef struct AddFavItemRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t type;
  uint32_t sourceType;
  BaseRequest *baseRequest;
  NSString *clientId;
  NSString *sourceId;
  NSString *object;
} AddFavItemRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = AddFavItemRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddFavItemRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientId",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItemRequest_FieldNumber_ClientId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddFavItemRequest__storage_, clientId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItemRequest_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddFavItemRequest__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sourceType",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItemRequest_FieldNumber_SourceType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddFavItemRequest__storage_, sourceType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "sourceId",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItemRequest_FieldNumber_SourceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AddFavItemRequest__storage_, sourceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "object",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItemRequest_FieldNumber_Object,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AddFavItemRequest__storage_, object),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddFavItemRequest class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddFavItemRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001K\000\002H\000\003D\000\004J\000\005H\000\006F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddFavItemResponse

@implementation AddFavItemResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasFavId, favId;
@dynamic hasUpdateSeq, updateSeq;
@dynamic hasUsedSize, usedSize;

typedef struct AddFavItemResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t favId;
  uint32_t updateSeq;
  BaseResponse *baseResponse;
  uint64_t usedSize;
} AddFavItemResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = AddFavItemResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddFavItemResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "favId",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItemResponse_FieldNumber_FavId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddFavItemResponse__storage_, favId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "updateSeq",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItemResponse_FieldNumber_UpdateSeq,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddFavItemResponse__storage_, updateSeq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "usedSize",
        .dataTypeSpecific.className = NULL,
        .number = AddFavItemResponse_FieldNumber_UsedSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AddFavItemResponse__storage_, usedSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddFavItemResponse class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddFavItemResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001L\000\002E\000\003I\000\004H\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelFavItemRsp

@implementation DelFavItemRsp

@dynamic hasRet, ret;
@dynamic hasFavId, favId;

typedef struct DelFavItemRsp__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  uint32_t favId;
} DelFavItemRsp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = DelFavItemRsp_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelFavItemRsp__storage_, ret),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "favId",
        .dataTypeSpecific.className = NULL,
        .number = DelFavItemRsp_FieldNumber_FavId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelFavItemRsp__storage_, favId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelFavItemRsp class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelFavItemRsp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001C\000\002E\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchDelFavItemRequest

@implementation BatchDelFavItemRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasCount, count;
@dynamic favIdListArray, favIdListArray_Count;

typedef struct BatchDelFavItemRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  BaseRequest *baseRequest;
  GPBUInt32Array *favIdListArray;
} BatchDelFavItemRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BatchDelFavItemRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchDelFavItemRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = BatchDelFavItemRequest_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BatchDelFavItemRequest__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "favIdListArray",
        .dataTypeSpecific.className = NULL,
        .number = BatchDelFavItemRequest_FieldNumber_FavIdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchDelFavItemRequest__storage_, favIdListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchDelFavItemRequest class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchDelFavItemRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002E\000\003\000FavIdList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchDelFavItemResponse

@implementation BatchDelFavItemResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct BatchDelFavItemResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  BaseResponse *baseResponse;
  NSMutableArray *listArray;
} BatchDelFavItemResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BatchDelFavItemResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchDelFavItemResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = BatchDelFavItemResponse_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BatchDelFavItemResponse__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(DelFavItemRsp),
        .number = BatchDelFavItemResponse_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchDelFavItemResponse__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchDelFavItemResponse class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchDelFavItemResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002E\000\003\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FavObject

@implementation FavObject

@dynamic hasFavId, favId;
@dynamic hasStatus, status;
@dynamic hasObject, object;
@dynamic hasFlag, flag;
@dynamic hasUpdateTime, updateTime;
@dynamic hasUpdateSeq, updateSeq;

typedef struct FavObject__storage_ {
  uint32_t _has_storage_[1];
  uint32_t favId;
  int32_t status;
  uint32_t flag;
  uint32_t updateTime;
  uint32_t updateSeq;
  NSString *object;
} FavObject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "favId",
        .dataTypeSpecific.className = NULL,
        .number = FavObject_FieldNumber_FavId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FavObject__storage_, favId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = FavObject_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FavObject__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "object",
        .dataTypeSpecific.className = NULL,
        .number = FavObject_FieldNumber_Object,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FavObject__storage_, object),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "flag",
        .dataTypeSpecific.className = NULL,
        .number = FavObject_FieldNumber_Flag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FavObject__storage_, flag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "updateTime",
        .dataTypeSpecific.className = NULL,
        .number = FavObject_FieldNumber_UpdateTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FavObject__storage_, updateTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "updateSeq",
        .dataTypeSpecific.className = NULL,
        .number = FavObject_FieldNumber_UpdateSeq,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FavObject__storage_, updateSeq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FavObject class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FavObject__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001E\000\002F\000\003F\000\004D\000\005J\000\006I\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchGetFavItemRequest

@implementation BatchGetFavItemRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasCount, count;
@dynamic favIdListArray, favIdListArray_Count;

typedef struct BatchGetFavItemRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  BaseRequest *baseRequest;
  GPBUInt32Array *favIdListArray;
} BatchGetFavItemRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BatchGetFavItemRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchGetFavItemRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = BatchGetFavItemRequest_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BatchGetFavItemRequest__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "favIdListArray",
        .dataTypeSpecific.className = NULL,
        .number = BatchGetFavItemRequest_FieldNumber_FavIdListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchGetFavItemRequest__storage_, favIdListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchGetFavItemRequest class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchGetFavItemRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002E\000\003\000FavIdList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchGetFavItemResponse

@implementation BatchGetFavItemResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCount, count;
@dynamic objectListArray, objectListArray_Count;

typedef struct BatchGetFavItemResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  BaseResponse *baseResponse;
  NSMutableArray *objectListArray;
} BatchGetFavItemResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BatchGetFavItemResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchGetFavItemResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = BatchGetFavItemResponse_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BatchGetFavItemResponse__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "objectListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FavObject),
        .number = BatchGetFavItemResponse_FieldNumber_ObjectListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchGetFavItemResponse__storage_, objectListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchGetFavItemResponse class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchGetFavItemResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002E\000\003\000ObjectList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckCDN

@implementation CheckCDN

@dynamic hasDataId, dataId;
@dynamic hasFullMd5, fullMd5;
@dynamic hasHead256Md5, head256Md5;
@dynamic hasFullSize, fullSize;
@dynamic hasDataSourceType, dataSourceType;
@dynamic hasDataSourceId, dataSourceId;
@dynamic hasIsThumb, isThumb;

typedef struct CheckCDN__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fullSize;
  uint32_t dataSourceType;
  uint32_t isThumb;
  NSString *dataId;
  NSString *fullMd5;
  NSString *head256Md5;
  NSString *dataSourceId;
} CheckCDN__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataId",
        .dataTypeSpecific.className = NULL,
        .number = CheckCDN_FieldNumber_DataId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckCDN__storage_, dataId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fullMd5",
        .dataTypeSpecific.className = NULL,
        .number = CheckCDN_FieldNumber_FullMd5,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckCDN__storage_, fullMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "head256Md5",
        .dataTypeSpecific.className = NULL,
        .number = CheckCDN_FieldNumber_Head256Md5,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CheckCDN__storage_, head256Md5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fullSize",
        .dataTypeSpecific.className = NULL,
        .number = CheckCDN_FieldNumber_FullSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CheckCDN__storage_, fullSize),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dataSourceType",
        .dataTypeSpecific.className = NULL,
        .number = CheckCDN_FieldNumber_DataSourceType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CheckCDN__storage_, dataSourceType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "dataSourceId",
        .dataTypeSpecific.className = NULL,
        .number = CheckCDN_FieldNumber_DataSourceId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(CheckCDN__storage_, dataSourceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isThumb",
        .dataTypeSpecific.className = NULL,
        .number = CheckCDN_FieldNumber_IsThumb,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(CheckCDN__storage_, isThumb),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckCDN class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckCDN__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001F\000\002G\000\003J\000\004H\000\005N\000\006L\000\007G\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FavCDNItem

@implementation FavCDNItem

@dynamic hasDataId, dataId;
@dynamic hasFullMd5, fullMd5;
@dynamic hasHead256Md5, head256Md5;
@dynamic hasFullSize, fullSize;
@dynamic hasCdnurl, cdnurl;
@dynamic hasAeskey, aeskey;
@dynamic hasEncryVer, encryVer;
@dynamic hasVideoId, videoId;
@dynamic hasStatus, status;
@dynamic hasDataStatus, dataStatus;

typedef struct FavCDNItem__storage_ {
  uint32_t _has_storage_[1];
  uint32_t fullSize;
  int32_t encryVer;
  int32_t status;
  int32_t dataStatus;
  NSString *dataId;
  NSString *fullMd5;
  NSString *head256Md5;
  NSString *cdnurl;
  NSString *aeskey;
  NSString *videoId;
} FavCDNItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataId",
        .dataTypeSpecific.className = NULL,
        .number = FavCDNItem_FieldNumber_DataId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FavCDNItem__storage_, dataId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fullMd5",
        .dataTypeSpecific.className = NULL,
        .number = FavCDNItem_FieldNumber_FullMd5,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FavCDNItem__storage_, fullMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "head256Md5",
        .dataTypeSpecific.className = NULL,
        .number = FavCDNItem_FieldNumber_Head256Md5,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FavCDNItem__storage_, head256Md5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fullSize",
        .dataTypeSpecific.className = NULL,
        .number = FavCDNItem_FieldNumber_FullSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FavCDNItem__storage_, fullSize),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "cdnurl",
        .dataTypeSpecific.className = NULL,
        .number = FavCDNItem_FieldNumber_Cdnurl,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(FavCDNItem__storage_, cdnurl),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aeskey",
        .dataTypeSpecific.className = NULL,
        .number = FavCDNItem_FieldNumber_Aeskey,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(FavCDNItem__storage_, aeskey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "encryVer",
        .dataTypeSpecific.className = NULL,
        .number = FavCDNItem_FieldNumber_EncryVer,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(FavCDNItem__storage_, encryVer),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "videoId",
        .dataTypeSpecific.className = NULL,
        .number = FavCDNItem_FieldNumber_VideoId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(FavCDNItem__storage_, videoId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = FavCDNItem_FieldNumber_Status,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(FavCDNItem__storage_, status),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dataStatus",
        .dataTypeSpecific.className = NULL,
        .number = FavCDNItem_FieldNumber_DataStatus,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(FavCDNItem__storage_, dataStatus),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FavCDNItem class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FavCDNItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\001F\000\002G\000\003J\000\004H\000\005f\000\006d\002\000\007H\000\010G\000\tF\000\nJ\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFavInfoRequest

@implementation GetFavInfoRequest

@dynamic hasBaseRequest, baseRequest;

typedef struct GetFavInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
} GetFavInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetFavInfoRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetFavInfoRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetFavInfoRequest class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetFavInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001K\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFavInfoResponse

@implementation GetFavInfoResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasUsedSize, usedSize;
@dynamic hasTotalSize, totalSize;
@dynamic hasMxFavFileSize, mxFavFileSize;
@dynamic hasMxAutoUploadSize, mxAutoUploadSize;
@dynamic hasMxAutoDownloadSize, mxAutoDownloadSize;

typedef struct GetFavInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t mxFavFileSize;
  uint32_t mxAutoUploadSize;
  uint32_t mxAutoDownloadSize;
  BaseResponse *baseResponse;
  uint64_t usedSize;
  uint64_t totalSize;
} GetFavInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetFavInfoResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetFavInfoResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "usedSize",
        .dataTypeSpecific.className = NULL,
        .number = GetFavInfoResponse_FieldNumber_UsedSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetFavInfoResponse__storage_, usedSize),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "totalSize",
        .dataTypeSpecific.className = NULL,
        .number = GetFavInfoResponse_FieldNumber_TotalSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetFavInfoResponse__storage_, totalSize),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "mxFavFileSize",
        .dataTypeSpecific.className = NULL,
        .number = GetFavInfoResponse_FieldNumber_MxFavFileSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetFavInfoResponse__storage_, mxFavFileSize),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "mxAutoUploadSize",
        .dataTypeSpecific.className = NULL,
        .number = GetFavInfoResponse_FieldNumber_MxAutoUploadSize,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetFavInfoResponse__storage_, mxAutoUploadSize),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "mxAutoDownloadSize",
        .dataTypeSpecific.className = NULL,
        .number = GetFavInfoResponse_FieldNumber_MxAutoDownloadSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetFavInfoResponse__storage_, mxAutoDownloadSize),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetFavInfoResponse class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetFavInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001L\000\002H\000\003I\000\004M\000\005P\000\006R\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckCDNRequest

@implementation CheckCDNRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct CheckCDNRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  BaseRequest *baseRequest;
  NSMutableArray *listArray;
} CheckCDNRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = CheckCDNRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckCDNRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = CheckCDNRequest_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckCDNRequest__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CheckCDN),
        .number = CheckCDNRequest_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckCDNRequest__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckCDNRequest class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckCDNRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002E\000\003\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckCDNResponse

@implementation CheckCDNResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct CheckCDNResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  BaseResponse *baseResponse;
  NSMutableArray *listArray;
} CheckCDNResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = CheckCDNResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckCDNResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = CheckCDNResponse_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckCDNResponse__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(FavCDNItem),
        .number = CheckCDNResponse_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckCDNResponse__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckCDNResponse class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckCDNResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002E\000\003\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FavSyncRequest

@implementation FavSyncRequest

@dynamic hasSelector, selector;
@dynamic hasKeyBuf, keyBuf;

typedef struct FavSyncRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t selector;
  SKBuiltinBuffer_t *keyBuf;
} FavSyncRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "selector",
        .dataTypeSpecific.className = NULL,
        .number = FavSyncRequest_FieldNumber_Selector,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FavSyncRequest__storage_, selector),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "keyBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = FavSyncRequest_FieldNumber_KeyBuf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FavSyncRequest__storage_, keyBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FavSyncRequest class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FavSyncRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001H\000\003F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FavSyncResponse

@implementation FavSyncResponse

@dynamic hasRet, ret;
@dynamic hasCmdList, cmdList;
@dynamic hasKeyBuf, keyBuf;
@dynamic hasContinueFlag, continueFlag;

typedef struct FavSyncResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  uint32_t continueFlag;
  CmdList *cmdList;
  SKBuiltinBuffer_t *keyBuf;
} FavSyncResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = FavSyncResponse_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FavSyncResponse__storage_, ret),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cmdList",
        .dataTypeSpecific.className = GPBStringifySymbol(CmdList),
        .number = FavSyncResponse_FieldNumber_CmdList,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FavSyncResponse__storage_, cmdList),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "keyBuf",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = FavSyncResponse_FieldNumber_KeyBuf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(FavSyncResponse__storage_, keyBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "continueFlag",
        .dataTypeSpecific.className = NULL,
        .number = FavSyncResponse_FieldNumber_ContinueFlag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(FavSyncResponse__storage_, continueFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FavSyncResponse class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FavSyncResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001C\000\002G\000\003F\000\004L\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransCDNItem

@implementation TransCDNItem

@dynamic hasClientId, clientId;
@dynamic hasFileId, fileId;
@dynamic hasAesKey, aesKey;
@dynamic hasFavDataType, favDataType;
@dynamic hasSize, size;

typedef struct TransCDNItem__storage_ {
  uint32_t _has_storage_[1];
  uint32_t clientId;
  uint32_t favDataType;
  NSString *fileId;
  NSString *aesKey;
  uint64_t size;
} TransCDNItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientId",
        .dataTypeSpecific.className = NULL,
        .number = TransCDNItem_FieldNumber_ClientId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransCDNItem__storage_, clientId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "fileId",
        .dataTypeSpecific.className = NULL,
        .number = TransCDNItem_FieldNumber_FileId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransCDNItem__storage_, fileId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "aesKey",
        .dataTypeSpecific.className = NULL,
        .number = TransCDNItem_FieldNumber_AesKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransCDNItem__storage_, aesKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "favDataType",
        .dataTypeSpecific.className = NULL,
        .number = TransCDNItem_FieldNumber_FavDataType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransCDNItem__storage_, favDataType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = TransCDNItem_FieldNumber_Size,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TransCDNItem__storage_, size),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransCDNItem class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransCDNItem__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001H\000\002F\000\003F\000\004K\000\005D\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchTransCDNRequest

@implementation BatchTransCDNRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct BatchTransCDNRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  BaseRequest *baseRequest;
  NSMutableArray *listArray;
} BatchTransCDNRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = BatchTransCDNRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchTransCDNRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = BatchTransCDNRequest_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BatchTransCDNRequest__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransCDNItem),
        .number = BatchTransCDNRequest_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchTransCDNRequest__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchTransCDNRequest class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchTransCDNRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001K\000\002E\000\003\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BatchTransCDNResponse

@implementation BatchTransCDNResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct BatchTransCDNResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t count;
  BaseResponse *baseResponse;
  NSMutableArray *listArray;
} BatchTransCDNResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = BatchTransCDNResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BatchTransCDNResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = BatchTransCDNResponse_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BatchTransCDNResponse__storage_, count),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransCDNItem),
        .number = BatchTransCDNResponse_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchTransCDNResponse__storage_, listArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchTransCDNResponse class]
                                     rootClass:[MmfavRoot class]
                                          file:MmfavRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchTransCDNResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001L\000\002E\000\003\000List\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
