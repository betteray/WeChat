// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mm.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Mm.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MmRoot

@implementation MmRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - MmRoot_FileDescriptor

static GPBFileDescriptor *MmRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - SKBuiltinBuffer_t

@implementation SKBuiltinBuffer_t

@dynamic hasILen, iLen;
@dynamic hasBuffer, buffer;

typedef struct SKBuiltinBuffer_t__storage_ {
  uint32_t _has_storage_[1];
  int32_t iLen;
  NSData *buffer;
} SKBuiltinBuffer_t__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "iLen",
        .dataTypeSpecific.className = NULL,
        .number = SKBuiltinBuffer_t_FieldNumber_ILen,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SKBuiltinBuffer_t__storage_, iLen),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "buffer",
        .dataTypeSpecific.className = NULL,
        .number = SKBuiltinBuffer_t_FieldNumber_Buffer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SKBuiltinBuffer_t__storage_, buffer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SKBuiltinBuffer_t class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SKBuiltinBuffer_t__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\004\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SKBuiltinString_t

@implementation SKBuiltinString_t

@dynamic hasString, string;

typedef struct SKBuiltinString_t__storage_ {
  uint32_t _has_storage_[1];
  NSString *string;
} SKBuiltinString_t__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "string",
        .dataTypeSpecific.className = NULL,
        .number = SKBuiltinString_t_FieldNumber_String,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SKBuiltinString_t__storage_, string),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SKBuiltinString_t class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SKBuiltinString_t__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BaseRequest

@implementation BaseRequest

@dynamic hasSessionKey, sessionKey;
@dynamic hasUin, uin;
@dynamic hasDeviceId, deviceId;
@dynamic hasClientVersion, clientVersion;
@dynamic hasDeviceType, deviceType;
@dynamic hasScene, scene;

typedef struct BaseRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t clientVersion;
  int32_t scene;
  NSData *sessionKey;
  NSData *deviceId;
  NSString *deviceType;
  int64_t uin;
} BaseRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sessionKey",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_SessionKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, sessionKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_Uin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, uin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_DeviceId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "clientVersion",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_ClientVersion,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, clientVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_DeviceType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = BaseRequest_FieldNumber_Scene,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BaseRequest__storage_, scene),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BaseRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BaseRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\n\000\003\010\000\004\r\000\005\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BaseResponse

@implementation BaseResponse

@dynamic hasRet, ret;
@dynamic hasErrMsg, errMsg;

typedef struct BaseResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  NSString *errMsg;
} BaseResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = BaseResponse_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BaseResponse__storage_, ret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "errMsg",
        .dataTypeSpecific.className = NULL,
        .number = BaseResponse_FieldNumber_ErrMsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BaseResponse__storage_, errMsg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BaseResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BaseResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLoginQRCodeRequest

@implementation GetLoginQRCodeRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasOpcode, opcode;
@dynamic hasDeviceName, deviceName;
@dynamic hasUserName, userName;
@dynamic hasHardwareExtra, hardwareExtra;
@dynamic hasSoftType, softType;
@dynamic hasExtDevLoginType, extDevLoginType;
@dynamic hasMsgContextPubKey, msgContextPubKey;

typedef struct GetLoginQRCodeRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t opcode;
  int32_t hardwareExtra;
  int32_t extDevLoginType;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *deviceName;
  NSString *userName;
  NSString *softType;
  SKBuiltinBuffer_t *msgContextPubKey;
} GetLoginQRCodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = GetLoginQRCodeRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_Opcode,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, opcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_DeviceName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_UserName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "hardwareExtra",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_HardwareExtra,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, hardwareExtra),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "softType",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_SoftType,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, softType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "extDevLoginType",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeRequest_FieldNumber_ExtDevLoginType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, extDevLoginType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msgContextPubKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeRequest_FieldNumber_MsgContextPubKey,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(GetLoginQRCodeRequest__storage_, msgContextPubKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLoginQRCodeRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLoginQRCodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\001\013\000\002\016\000\004\n\000\005\010\000\006\r\000\007\010\000\010\017\000\t\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetLoginQRCodeResponse

@implementation GetLoginQRCodeResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasQrcode, qrcode;
@dynamic hasUuid, uuid;
@dynamic hasCheckTime, checkTime;
@dynamic hasNotifyKey, notifyKey;
@dynamic hasExpiredTime, expiredTime;
@dynamic hasBlueToothBroadCastUuid, blueToothBroadCastUuid;
@dynamic hasBlueToothBroadCastContent, blueToothBroadCastContent;

typedef struct GetLoginQRCodeResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t checkTime;
  int32_t expiredTime;
  BaseResponse *baseResponse;
  SKBuiltinBuffer_t *qrcode;
  NSString *uuid;
  SKBuiltinBuffer_t *notifyKey;
  NSString *blueToothBroadCastUuid;
  SKBuiltinBuffer_t *blueToothBroadCastContent;
} GetLoginQRCodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = GetLoginQRCodeResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "qrcode",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeResponse_FieldNumber_Qrcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, qrcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_Uuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, uuid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checkTime",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_CheckTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, checkTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "notifyKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeResponse_FieldNumber_NotifyKey,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, notifyKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "expiredTime",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_ExpiredTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, expiredTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "blueToothBroadCastUuid",
        .dataTypeSpecific.className = NULL,
        .number = GetLoginQRCodeResponse_FieldNumber_BlueToothBroadCastUuid,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, blueToothBroadCastUuid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blueToothBroadCastContent",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = GetLoginQRCodeResponse_FieldNumber_BlueToothBroadCastContent,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(GetLoginQRCodeResponse__storage_, blueToothBroadCastContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetLoginQRCodeResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetLoginQRCodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\001\014\000\004\t\000\005\t\000\006\013\000\007\026\000\010\031\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckLoginQRCodeRequest

@implementation CheckLoginQRCodeRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasRandomEncryKey, randomEncryKey;
@dynamic hasUuid, uuid;
@dynamic hasTimeStamp, timeStamp;
@dynamic hasOpcode, opcode;

typedef struct CheckLoginQRCodeRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t timeStamp;
  int32_t opcode;
  BaseRequest *baseRequest;
  SKBuiltinBuffer_t *randomEncryKey;
  NSString *uuid;
} CheckLoginQRCodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = CheckLoginQRCodeRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "randomEncryKey",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = CheckLoginQRCodeRequest_FieldNumber_RandomEncryKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, randomEncryKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeRequest_FieldNumber_Uuid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, uuid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeRequest_FieldNumber_TimeStamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeRequest_FieldNumber_Opcode,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeRequest__storage_, opcode),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckLoginQRCodeRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckLoginQRCodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\016\000\004\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckLoginQRCodeResponse

@implementation CheckLoginQRCodeResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasNotifyPkg, notifyPkg;

typedef struct CheckLoginQRCodeResponse__storage_ {
  uint32_t _has_storage_[1];
  BaseResponse *baseResponse;
  CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg *notifyPkg;
} CheckLoginQRCodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = CheckLoginQRCodeResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notifyPkg",
        .dataTypeSpecific.className = GPBStringifySymbol(CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg),
        .number = CheckLoginQRCodeResponse_FieldNumber_NotifyPkg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse__storage_, notifyPkg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckLoginQRCodeResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckLoginQRCodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\014\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg

@implementation CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg

@dynamic hasNotifyData, notifyData;
@dynamic hasOpcode, opcode;

typedef struct CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_ {
  uint32_t _has_storage_[1];
  int32_t opcode;
  SKBuiltinBuffer_t *notifyData;
} CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notifyData",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg_FieldNumber_NotifyData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_, notifyData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "opcode",
        .dataTypeSpecific.className = NULL,
        .number = CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg_FieldNumber_Opcode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_, opcode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckLoginQRCodeResponse_LoginQRCodeNotifyPkg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001J\000\002F\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CheckLoginQRCodeResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NotifyMsg

@implementation NotifyMsg

@dynamic hasUuid, uuid;
@dynamic hasState, state;
@dynamic hasWxid, wxid;
@dynamic hasWxnewpass, wxnewpass;
@dynamic hasAvatar, avatar;
@dynamic hasPushLoginURLExpiredTime, pushLoginURLExpiredTime;
@dynamic hasNickName, nickName;
@dynamic hasEffectiveTime, effectiveTime;
@dynamic hasT10, t10;
@dynamic hasDevices, devices;

typedef struct NotifyMsg__storage_ {
  uint32_t _has_storage_[1];
  int32_t state;
  int32_t pushLoginURLExpiredTime;
  int32_t effectiveTime;
  int32_t t10;
  NSString *uuid;
  NSString *wxid;
  NSString *wxnewpass;
  NSString *avatar;
  NSString *nickName;
  NSString *devices;
} NotifyMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Uuid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_State,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "wxid",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Wxid,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, wxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "wxnewpass",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Wxnewpass,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, wxnewpass),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatar",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Avatar,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, avatar),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushLoginURLExpiredTime",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_PushLoginURLExpiredTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, pushLoginURLExpiredTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_NickName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "effectiveTime",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_EffectiveTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, effectiveTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "t10",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_T10,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, t10),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "devices",
        .dataTypeSpecific.className = NULL,
        .number = NotifyMsg_FieldNumber_Devices,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(NotifyMsg__storage_, devices),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NotifyMsg class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NotifyMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\006\n!,\000\007\010\000\010\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthAccountRequest

@implementation ManualAuthAccountRequest

@dynamic hasAes, aes;
@dynamic hasEcdh, ecdh;
@dynamic hasUserName, userName;
@dynamic hasPwd, pwd;
@dynamic hasPwd2, pwd2;

typedef struct ManualAuthAccountRequest__storage_ {
  uint32_t _has_storage_[1];
  ManualAuthAccountRequest_AesKey *aes;
  ManualAuthAccountRequest_Ecdh *ecdh;
  NSString *userName;
  NSString *pwd;
  NSString *pwd2;
} ManualAuthAccountRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "aes",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthAccountRequest_AesKey),
        .number = ManualAuthAccountRequest_FieldNumber_Aes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthAccountRequest__storage_, aes),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ecdh",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthAccountRequest_Ecdh),
        .number = ManualAuthAccountRequest_FieldNumber_Ecdh,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthAccountRequest__storage_, ecdh),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAccountRequest_FieldNumber_UserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ManualAuthAccountRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAccountRequest_FieldNumber_Pwd,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ManualAuthAccountRequest__storage_, pwd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pwd2",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAccountRequest_FieldNumber_Pwd2,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ManualAuthAccountRequest__storage_, pwd2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthAccountRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthAccountRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthAccountRequest_AesKey

@implementation ManualAuthAccountRequest_AesKey

@dynamic hasLen, len;
@dynamic hasKey, key;

typedef struct ManualAuthAccountRequest_AesKey__storage_ {
  uint32_t _has_storage_[1];
  int32_t len;
  NSData *key;
} ManualAuthAccountRequest_AesKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "len",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAccountRequest_AesKey_FieldNumber_Len,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthAccountRequest_AesKey__storage_, len),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAccountRequest_AesKey_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthAccountRequest_AesKey__storage_, key),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthAccountRequest_AesKey class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthAccountRequest_AesKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthAccountRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthAccountRequest_Ecdh

@implementation ManualAuthAccountRequest_Ecdh

@dynamic hasNid, nid;
@dynamic hasEcdhKey, ecdhKey;

typedef struct ManualAuthAccountRequest_Ecdh__storage_ {
  uint32_t _has_storage_[1];
  int32_t nid;
  ManualAuthAccountRequest_Ecdh_EcdhKey *ecdhKey;
} ManualAuthAccountRequest_Ecdh__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nid",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAccountRequest_Ecdh_FieldNumber_Nid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthAccountRequest_Ecdh__storage_, nid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "ecdhKey",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthAccountRequest_Ecdh_EcdhKey),
        .number = ManualAuthAccountRequest_Ecdh_FieldNumber_EcdhKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthAccountRequest_Ecdh__storage_, ecdhKey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthAccountRequest_Ecdh class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthAccountRequest_Ecdh__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthAccountRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthAccountRequest_Ecdh_EcdhKey

@implementation ManualAuthAccountRequest_Ecdh_EcdhKey

@dynamic hasLen, len;
@dynamic hasKey, key;

typedef struct ManualAuthAccountRequest_Ecdh_EcdhKey__storage_ {
  uint32_t _has_storage_[1];
  int32_t len;
  NSData *key;
} ManualAuthAccountRequest_Ecdh_EcdhKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "len",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAccountRequest_Ecdh_EcdhKey_FieldNumber_Len,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthAccountRequest_Ecdh_EcdhKey__storage_, len),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthAccountRequest_Ecdh_EcdhKey_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthAccountRequest_Ecdh_EcdhKey__storage_, key),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthAccountRequest_Ecdh_EcdhKey class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthAccountRequest_Ecdh_EcdhKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthAccountRequest_Ecdh)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthDeviceRequest

@implementation ManualAuthDeviceRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasBaseReqInfo, baseReqInfo;
@dynamic hasImei, imei;
@dynamic hasSoftType, softType;
@dynamic hasBuiltinIpseq, builtinIpseq;
@dynamic hasClientSeqId, clientSeqId;
@dynamic hasDeviceName, deviceName;
@dynamic hasDeviceType, deviceType;
@dynamic hasLanguage, language;
@dynamic hasTimeZone, timeZone;
@dynamic hasChannel, channel;
@dynamic hasTimeStamp, timeStamp;
@dynamic hasDeviceBrand, deviceBrand;
@dynamic hasOstype, ostype;
@dynamic hasRealCountry, realCountry;
@dynamic hasBundleId, bundleId;
@dynamic hasAdSource, adSource;
@dynamic hasIphoneVer, iphoneVer;
@dynamic hasInputType, inputType;
@dynamic hasClientCheckData, clientCheckData;

typedef struct ManualAuthDeviceRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t builtinIpseq;
  int32_t channel;
  int32_t timeStamp;
  int32_t inputType;
  BaseRequest *baseRequest;
  ManualAuthDeviceRequest_BaseAuthReqInfo *baseReqInfo;
  NSString *imei;
  NSString *softType;
  NSString *clientSeqId;
  NSString *deviceName;
  NSString *deviceType;
  NSString *language;
  NSString *timeZone;
  NSString *deviceBrand;
  NSString *ostype;
  NSString *realCountry;
  NSString *bundleId;
  NSString *adSource;
  NSString *iphoneVer;
  SKBuiltinBuffer_t *clientCheckData;
} ManualAuthDeviceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = ManualAuthDeviceRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "baseReqInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthDeviceRequest_BaseAuthReqInfo),
        .number = ManualAuthDeviceRequest_FieldNumber_BaseReqInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, baseReqInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "imei",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_Imei,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, imei),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "softType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_SoftType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, softType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "builtinIpseq",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_BuiltinIpseq,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, builtinIpseq),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientSeqId",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_ClientSeqId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, clientSeqId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceName",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_DeviceName,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, deviceName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_DeviceType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_Language,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, language),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeZone",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_TimeZone,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, timeZone),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "channel",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_Channel,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, channel),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timeStamp",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_TimeStamp,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, timeStamp),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceBrand",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_DeviceBrand,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, deviceBrand),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "ostype",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_Ostype,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, ostype),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "realCountry",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_RealCountry,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, realCountry),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bundleId",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_BundleId,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, bundleId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "adSource",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_AdSource,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, adSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "iphoneVer",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_IphoneVer,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, iphoneVer),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_FieldNumber_InputType,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, inputType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientCheckData",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ManualAuthDeviceRequest_FieldNumber_ClientCheckData,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest__storage_, clientCheckData),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthDeviceRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthDeviceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\020\001\013\000\002\013\000\004\010\000\005\014\000\006\013\000\010\n\000\t\n\000\013\010\000\016\t\000\017\013\000\022\013\000\023\010\000\024\010\000"
        "\025\t\000\026\t\000\027\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthDeviceRequest_BaseAuthReqInfo

@implementation ManualAuthDeviceRequest_BaseAuthReqInfo

@dynamic hasCliDbencryptInfo, cliDbencryptInfo;
@dynamic hasAuthReqFlag, authReqFlag;

typedef struct ManualAuthDeviceRequest_BaseAuthReqInfo__storage_ {
  uint32_t _has_storage_[1];
  SKBuiltinBuffer_t *cliDbencryptInfo;
  NSString *authReqFlag;
} ManualAuthDeviceRequest_BaseAuthReqInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cliDbencryptInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = ManualAuthDeviceRequest_BaseAuthReqInfo_FieldNumber_CliDbencryptInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest_BaseAuthReqInfo__storage_, cliDbencryptInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "authReqFlag",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthDeviceRequest_BaseAuthReqInfo_FieldNumber_AuthReqFlag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthDeviceRequest_BaseAuthReqInfo__storage_, authReqFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthDeviceRequest_BaseAuthReqInfo class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthDeviceRequest_BaseAuthReqInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\005\020\000\007\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthDeviceRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthRequest

@implementation ManualAuthRequest

@dynamic hasRsaReqData, rsaReqData;
@dynamic hasAesReqData, aesReqData;

typedef struct ManualAuthRequest__storage_ {
  uint32_t _has_storage_[1];
  ManualAuthAccountRequest *rsaReqData;
  ManualAuthDeviceRequest *aesReqData;
} ManualAuthRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rsaReqData",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthAccountRequest),
        .number = ManualAuthRequest_FieldNumber_RsaReqData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthRequest__storage_, rsaReqData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "aesReqData",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthDeviceRequest),
        .number = ManualAuthRequest_FieldNumber_AesReqData,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthRequest__storage_, aesReqData),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse

@implementation ManualAuthResponse

@dynamic hasResult, result;
@dynamic hasUnifyFlag, unifyFlag;
@dynamic hasAuthParam, authParam;
@dynamic hasAccountInfo, accountInfo;
@dynamic hasDns, dns;

typedef struct ManualAuthResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t unifyFlag;
  ManualAuthResponse_AuthResult *result;
  ManualAuthResponse_AuthParam *authParam;
  ManualAuthResponse_AccountInfo *accountInfo;
  ManualAuthResponse_dns_info *dns;
} ManualAuthResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_AuthResult),
        .number = ManualAuthResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse__storage_, result),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "unifyFlag",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_FieldNumber_UnifyFlag,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthResponse__storage_, unifyFlag),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "authParam",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_AuthParam),
        .number = ManualAuthResponse_FieldNumber_AuthParam,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ManualAuthResponse__storage_, authParam),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accountInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_AccountInfo),
        .number = ManualAuthResponse_FieldNumber_AccountInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ManualAuthResponse__storage_, accountInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dns",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_dns_info),
        .number = ManualAuthResponse_FieldNumber_Dns,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ManualAuthResponse__storage_, dns),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\002\t\000\003\t\000\004\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_AuthResult

@implementation ManualAuthResponse_AuthResult

@dynamic hasCode, code;
@dynamic hasErrMsg, errMsg;

typedef struct ManualAuthResponse_AuthResult__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  ManualAuthResponse_AuthResult_ErrMsg *errMsg;
} ManualAuthResponse_AuthResult__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AuthResult_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthResult__storage_, code),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "errMsg",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_AuthResult_ErrMsg),
        .number = ManualAuthResponse_AuthResult_FieldNumber_ErrMsg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthResult__storage_, errMsg),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_AuthResult class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_AuthResult__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_AuthResult_ErrMsg

@implementation ManualAuthResponse_AuthResult_ErrMsg

@dynamic hasMsg, msg;

typedef struct ManualAuthResponse_AuthResult_ErrMsg__storage_ {
  uint32_t _has_storage_[1];
  NSString *msg;
} ManualAuthResponse_AuthResult_ErrMsg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "msg",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AuthResult_ErrMsg_FieldNumber_Msg,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthResult_ErrMsg__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_AuthResult_ErrMsg class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_AuthResult_ErrMsg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse_AuthResult)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_AuthParam

@implementation ManualAuthResponse_AuthParam

@dynamic hasUin, uin;
@dynamic hasEcdh, ecdh;
@dynamic hasSession, session;
@dynamic hasSmsTicket, smsTicket;
@dynamic hasBindMailLoginURL, bindMailLoginURL;
@dynamic hasServerTime, serverTime;

typedef struct ManualAuthResponse_AuthParam__storage_ {
  uint32_t _has_storage_[1];
  int32_t serverTime;
  ManualAuthResponse_AuthParam_Ecdh *ecdh;
  ManualAuthResponse_AuthParam_SessionKey *session;
  NSData *smsTicket;
  NSString *bindMailLoginURL;
  int64_t uin;
} ManualAuthResponse_AuthParam__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uin",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AuthParam_FieldNumber_Uin,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthParam__storage_, uin),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ecdh",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_AuthParam_Ecdh),
        .number = ManualAuthResponse_AuthParam_FieldNumber_Ecdh,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthParam__storage_, ecdh),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_AuthParam_SessionKey),
        .number = ManualAuthResponse_AuthParam_FieldNumber_Session,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthParam__storage_, session),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "smsTicket",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AuthParam_FieldNumber_SmsTicket,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthParam__storage_, smsTicket),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "bindMailLoginURL",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AuthParam_FieldNumber_BindMailLoginURL,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthParam__storage_, bindMailLoginURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "serverTime",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AuthParam_FieldNumber_ServerTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthParam__storage_, serverTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_AuthParam class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_AuthParam__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\020I\000\024\016!!\000\026\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_AuthParam_Ecdh

@implementation ManualAuthResponse_AuthParam_Ecdh

@dynamic hasNid, nid;
@dynamic hasEcdhKey, ecdhKey;

typedef struct ManualAuthResponse_AuthParam_Ecdh__storage_ {
  uint32_t _has_storage_[1];
  int32_t nid;
  ManualAuthResponse_AuthParam_Ecdh_EcdhKey *ecdhKey;
} ManualAuthResponse_AuthParam_Ecdh__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nid",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AuthParam_Ecdh_FieldNumber_Nid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthParam_Ecdh__storage_, nid),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "ecdhKey",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_AuthParam_Ecdh_EcdhKey),
        .number = ManualAuthResponse_AuthParam_Ecdh_FieldNumber_EcdhKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthParam_Ecdh__storage_, ecdhKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_AuthParam_Ecdh class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_AuthParam_Ecdh__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse_AuthParam)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_AuthParam_Ecdh_EcdhKey

@implementation ManualAuthResponse_AuthParam_Ecdh_EcdhKey

@dynamic hasLen, len;
@dynamic hasKey, key;

typedef struct ManualAuthResponse_AuthParam_Ecdh_EcdhKey__storage_ {
  uint32_t _has_storage_[1];
  int32_t len;
  NSData *key;
} ManualAuthResponse_AuthParam_Ecdh_EcdhKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "len",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AuthParam_Ecdh_EcdhKey_FieldNumber_Len,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthParam_Ecdh_EcdhKey__storage_, len),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AuthParam_Ecdh_EcdhKey_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthParam_Ecdh_EcdhKey__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_AuthParam_Ecdh_EcdhKey class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_AuthParam_Ecdh_EcdhKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse_AuthParam_Ecdh)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_AuthParam_SessionKey

@implementation ManualAuthResponse_AuthParam_SessionKey

@dynamic hasLen, len;
@dynamic hasKey, key;

typedef struct ManualAuthResponse_AuthParam_SessionKey__storage_ {
  uint32_t _has_storage_[1];
  int32_t len;
  NSData *key;
} ManualAuthResponse_AuthParam_SessionKey__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "len",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AuthParam_SessionKey_FieldNumber_Len,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthParam_SessionKey__storage_, len),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AuthParam_SessionKey_FieldNumber_Key,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AuthParam_SessionKey__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_AuthParam_SessionKey class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_AuthParam_SessionKey__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse_AuthParam)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_AccountInfo

@implementation ManualAuthResponse_AccountInfo

@dynamic hasWxId, wxId;
@dynamic hasNickName, nickName;
@dynamic hasTag3, tag3;
@dynamic hasBindMail, bindMail;
@dynamic hasBindMobile, bindMobile;
@dynamic hasAlias, alias;
@dynamic hasTag7, tag7;
@dynamic hasStatus, status;
@dynamic hasPluginFlag, pluginFlag;
@dynamic hasRegisterType, registerType;
@dynamic hasTag11, tag11;
@dynamic hasSafeDevice, safeDevice;
@dynamic hasOfficialNamePinyin, officialNamePinyin;
@dynamic hasOfficialNameZh, officialNameZh;
@dynamic hasTag15, tag15;
@dynamic hasFsURL, fsURL;

typedef struct ManualAuthResponse_AccountInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t tag3;
  int32_t status;
  int32_t pluginFlag;
  int32_t registerType;
  int32_t safeDevice;
  NSString *wxId;
  NSString *nickName;
  NSString *bindMail;
  NSString *bindMobile;
  NSString *alias;
  NSString *tag7;
  NSString *tag11;
  NSString *officialNamePinyin;
  NSString *officialNameZh;
  NSString *tag15;
  NSString *fsURL;
} ManualAuthResponse_AccountInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wxId",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_WxId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, wxId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, nickName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag3",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_Tag3,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, tag3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "bindMail",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_BindMail,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, bindMail),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bindMobile",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_BindMobile,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, bindMobile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_Alias,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, alias),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag7",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_Tag7,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, tag7),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_Status,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "pluginFlag",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_PluginFlag,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, pluginFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "registerType",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_RegisterType,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, registerType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag11",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_Tag11,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, tag11),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "safeDevice",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_SafeDevice,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, safeDevice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "officialNamePinyin",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_OfficialNamePinyin,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, officialNamePinyin),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "officialNameZh",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_OfficialNameZh,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, officialNameZh),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag15",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_Tag15,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, tag15),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fsURL",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_AccountInfo_FieldNumber_FsURL,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ManualAuthResponse_AccountInfo__storage_, fsURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_AccountInfo class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_AccountInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\013\001\004\000\002\010\000\004\010\000\005\n\000\006E\000\t\n\000\n\014\000\014\n\000\r\022\000\016\016\000\020\003!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_dns_info

@implementation ManualAuthResponse_dns_info

@dynamic hasRedirect, redirect;
@dynamic hasIp, ip;

typedef struct ManualAuthResponse_dns_info__storage_ {
  uint32_t _has_storage_[1];
  ManualAuthResponse_dns_info_redirect_info *redirect;
  ManualAuthResponse_dns_info_ip_info *ip;
} ManualAuthResponse_dns_info__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redirect",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_dns_info_redirect_info),
        .number = ManualAuthResponse_dns_info_FieldNumber_Redirect,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info__storage_, redirect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_dns_info_ip_info),
        .number = ManualAuthResponse_dns_info_FieldNumber_Ip,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_dns_info class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_dns_info__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_dns_info_redirect_info

@implementation ManualAuthResponse_dns_info_redirect_info

@dynamic hasCnt, cnt;
@dynamic realHostArray, realHostArray_Count;

typedef struct ManualAuthResponse_dns_info_redirect_info__storage_ {
  uint32_t _has_storage_[1];
  int32_t cnt;
  NSMutableArray *realHostArray;
} ManualAuthResponse_dns_info_redirect_info__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cnt",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_dns_info_redirect_info_FieldNumber_Cnt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info_redirect_info__storage_, cnt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "realHostArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_dns_info_redirect_info_real_host_info),
        .number = ManualAuthResponse_dns_info_redirect_info_FieldNumber_RealHostArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info_redirect_info__storage_, realHostArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_dns_info_redirect_info class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_dns_info_redirect_info__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse_dns_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_dns_info_redirect_info_real_host_info

@implementation ManualAuthResponse_dns_info_redirect_info_real_host_info

@dynamic hasHost, host;
@dynamic hasRedirect, redirect;

typedef struct ManualAuthResponse_dns_info_redirect_info_real_host_info__storage_ {
  uint32_t _has_storage_[1];
  NSString *host;
  NSString *redirect;
} ManualAuthResponse_dns_info_redirect_info_real_host_info__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "host",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_dns_info_redirect_info_real_host_info_FieldNumber_Host,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info_redirect_info_real_host_info__storage_, host),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "redirect",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_dns_info_redirect_info_real_host_info_FieldNumber_Redirect,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info_redirect_info_real_host_info__storage_, redirect),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_dns_info_redirect_info_real_host_info class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_dns_info_redirect_info_real_host_info__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse_dns_info_redirect_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_dns_info_ip_info

@implementation ManualAuthResponse_dns_info_ip_info

@dynamic hasLonglinkIpCnt, longlinkIpCnt;
@dynamic hasShortlinkIpCnt, shortlinkIpCnt;
@dynamic longlinkArray, longlinkArray_Count;
@dynamic shortlinkArray, shortlinkArray_Count;

typedef struct ManualAuthResponse_dns_info_ip_info__storage_ {
  uint32_t _has_storage_[1];
  int32_t longlinkIpCnt;
  int32_t shortlinkIpCnt;
  NSMutableArray *longlinkArray;
  NSMutableArray *shortlinkArray;
} ManualAuthResponse_dns_info_ip_info__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "longlinkIpCnt",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_dns_info_ip_info_FieldNumber_LonglinkIpCnt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info_ip_info__storage_, longlinkIpCnt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "shortlinkIpCnt",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_dns_info_ip_info_FieldNumber_ShortlinkIpCnt,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info_ip_info__storage_, shortlinkIpCnt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "longlinkArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_dns_info_ip_info_longlink_ip_info),
        .number = ManualAuthResponse_dns_info_ip_info_FieldNumber_LonglinkArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info_ip_info__storage_, longlinkArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shortlinkArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ManualAuthResponse_dns_info_ip_info_shortlink_ip_info),
        .number = ManualAuthResponse_dns_info_ip_info_FieldNumber_ShortlinkArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info_ip_info__storage_, shortlinkArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_dns_info_ip_info class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_dns_info_ip_info__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse_dns_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_dns_info_ip_info_longlink_ip_info

@implementation ManualAuthResponse_dns_info_ip_info_longlink_ip_info

@dynamic hasIp, ip;
@dynamic hasHost, host;

typedef struct ManualAuthResponse_dns_info_ip_info_longlink_ip_info__storage_ {
  uint32_t _has_storage_[1];
  NSString *ip;
  NSString *host;
} ManualAuthResponse_dns_info_ip_info_longlink_ip_info__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_dns_info_ip_info_longlink_ip_info_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info_ip_info_longlink_ip_info__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "host",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_dns_info_ip_info_longlink_ip_info_FieldNumber_Host,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info_ip_info_longlink_ip_info__storage_, host),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_dns_info_ip_info_longlink_ip_info class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_dns_info_ip_info_longlink_ip_info__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse_dns_info_ip_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ManualAuthResponse_dns_info_ip_info_shortlink_ip_info

@implementation ManualAuthResponse_dns_info_ip_info_shortlink_ip_info

@dynamic hasIp, ip;
@dynamic hasHost, host;

typedef struct ManualAuthResponse_dns_info_ip_info_shortlink_ip_info__storage_ {
  uint32_t _has_storage_[1];
  NSString *ip;
  NSString *host;
} ManualAuthResponse_dns_info_ip_info_shortlink_ip_info__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_dns_info_ip_info_shortlink_ip_info_FieldNumber_Ip,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info_ip_info_shortlink_ip_info__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "host",
        .dataTypeSpecific.className = NULL,
        .number = ManualAuthResponse_dns_info_ip_info_shortlink_ip_info_FieldNumber_Host,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ManualAuthResponse_dns_info_ip_info_shortlink_ip_info__storage_, host),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ManualAuthResponse_dns_info_ip_info_shortlink_ip_info class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ManualAuthResponse_dns_info_ip_info_shortlink_ip_info__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ManualAuthResponse_dns_info_ip_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewInitRequest

@implementation NewInitRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasUserName, userName;
@dynamic hasCurrentSynckey, currentSynckey;
@dynamic hasMaxSynckey, maxSynckey;
@dynamic hasLanguage, language;

typedef struct NewInitRequest__storage_ {
  uint32_t _has_storage_[1];
  BaseRequest *baseRequest;
  NSString *userName;
  NSData *currentSynckey;
  NSData *maxSynckey;
  NSString *language;
} NewInitRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = NewInitRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "userName",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_UserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, userName),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currentSynckey",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_CurrentSynckey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, currentSynckey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "maxSynckey",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_MaxSynckey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, maxSynckey),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "language",
        .dataTypeSpecific.className = NULL,
        .number = NewInitRequest_FieldNumber_Language,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewInitRequest__storage_, language),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewInitRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewInitRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\013\000\002\010\000\003\016\000\004\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Msg

@implementation Msg

@dynamic hasServerid, serverid;
@dynamic hasFromId, fromId;
@dynamic hasToId, toId;
@dynamic hasType, type;
@dynamic hasRaw, raw;
@dynamic hasStatus, status;
@dynamic hasTag7, tag7;
@dynamic hasTag8, tag8;
@dynamic hasCreateTime, createTime;
@dynamic hasExInfo, exInfo;
@dynamic hasXmlContent, xmlContent;
@dynamic hasSvrId, svrId;
@dynamic hasMsgKey, msgKey;

typedef struct Msg__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t status;
  int32_t tag7;
  int32_t createTime;
  int32_t msgKey;
  SKBuiltinString_t *fromId;
  SKBuiltinString_t *toId;
  Msg_RawContent *raw;
  NSData *tag8;
  NSString *exInfo;
  NSString *xmlContent;
  int64_t serverid;
  int64_t svrId;
} Msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serverid",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_Serverid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Msg__storage_, serverid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fromId",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = Msg_FieldNumber_FromId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Msg__storage_, fromId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "toId",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = Msg_FieldNumber_ToId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Msg__storage_, toId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_Type,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Msg__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "raw",
        .dataTypeSpecific.className = GPBStringifySymbol(Msg_RawContent),
        .number = Msg_FieldNumber_Raw,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Msg__storage_, raw),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_Status,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Msg__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag7",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_Tag7,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Msg__storage_, tag7),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag8",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_Tag8,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Msg__storage_, tag8),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_CreateTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Msg__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "exInfo",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_ExInfo,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Msg__storage_, exInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "xmlContent",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_XmlContent,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Msg__storage_, xmlContent),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "svrId",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_SvrId,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Msg__storage_, svrId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgKey",
        .dataTypeSpecific.className = NULL,
        .number = Msg_FieldNumber_MsgKey,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(Msg__storage_, msgKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Msg class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Msg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\t\n\000\013\n\000\014\005\000\r\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Msg_RawContent

@implementation Msg_RawContent

@dynamic hasContent, content;

typedef struct Msg_RawContent__storage_ {
  uint32_t _has_storage_[1];
  NSString *content;
} Msg_RawContent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = Msg_RawContent_FieldNumber_Content,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Msg_RawContent__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Msg_RawContent class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Msg_RawContent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Msg)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info

@implementation contact_info

@dynamic hasWxid, wxid;
@dynamic hasNickname, nickname;
@dynamic hasShortPy, shortPy;
@dynamic hasQuanpin, quanpin;
@dynamic hasSex, sex;
@dynamic hasTag6, tag6;
@dynamic hasTag7, tag7;
@dynamic hasType, type;
@dynamic hasTag9, tag9;
@dynamic hasRemarkName, remarkName;
@dynamic hasRealShortPy, realShortPy;
@dynamic hasRealQuanpin, realQuanpin;
@dynamic hasTag13, tag13;
@dynamic hasTag14, tag14;
@dynamic hasTag16, tag16;
@dynamic hasBChatRoom, bChatRoom;
@dynamic hasTag18, tag18;
@dynamic hasSheng, sheng;
@dynamic hasShi, shi;
@dynamic hasQianming, qianming;
@dynamic hasTag22, tag22;
@dynamic hasTag23, tag23;
@dynamic hasRegisterBodyType, registerBodyType;
@dynamic hasRegisterBody, registerBody;
@dynamic hasTag26, tag26;
@dynamic hasSrc, src;
@dynamic hasLastMsgTime, lastMsgTime;
@dynamic hasAlias, alias;
@dynamic hasChatroomOwnerWxid, chatroomOwnerWxid;
@dynamic hasTag33, tag33;
@dynamic hasTag34, tag34;
@dynamic hasTag35, tag35;
@dynamic hasTag37, tag37;
@dynamic hasCountry, country;
@dynamic hasAvatarBig, avatarBig;
@dynamic hasAvatarSmall, avatarSmall;
@dynamic hasTag42, tag42;
@dynamic hasV1Name, v1Name;
@dynamic hasTag50, tag50;
@dynamic hasChatroomServerVer, chatroomServerVer;
@dynamic hasChatroomMaxMember, chatroomMaxMember;
@dynamic hasTag56, tag56;
@dynamic hasGroupMemberList, groupMemberList;
@dynamic hasTag58, tag58;
@dynamic hasTag62, tag62;
@dynamic hasTag64, tag64;
@dynamic hasTag65, tag65;
@dynamic hasTag66, tag66;
@dynamic hasTag67, tag67;

typedef struct contact_info__storage_ {
  uint32_t _has_storage_[2];
  int32_t sex;
  int32_t tag7;
  int32_t type;
  int32_t tag9;
  int32_t tag13;
  int32_t tag14;
  int32_t bChatRoom;
  int32_t tag18;
  int32_t tag22;
  int32_t tag23;
  int32_t registerBodyType;
  int32_t tag26;
  int32_t src;
  int32_t tag33;
  int32_t tag34;
  int32_t tag35;
  int32_t chatroomServerVer;
  int32_t chatroomMaxMember;
  int32_t tag56;
  int32_t tag58;
  int32_t tag64;
  int32_t tag65;
  int32_t tag66;
  int32_t tag67;
  SKBuiltinString_t *wxid;
  contact_info_NickName *nickname;
  contact_info_PY_SHORT *shortPy;
  contact_info_QuanPin *quanpin;
  NSString *tag6;
  contact_info_BeiZhu *remarkName;
  contact_info_REAL_PY_SHORT *realShortPy;
  contact_info_REAL_QuanPin *realQuanpin;
  NSString *tag16;
  NSString *sheng;
  NSString *shi;
  NSString *qianming;
  NSString *registerBody;
  NSString *lastMsgTime;
  NSString *alias;
  NSString *chatroomOwnerWxid;
  NSData *tag37;
  NSString *country;
  NSString *avatarBig;
  NSString *avatarSmall;
  NSData *tag42;
  NSString *v1Name;
  NSData *tag50;
  contact_info_GroupMemberList *groupMemberList;
  NSData *tag62;
} contact_info__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wxid",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = contact_info_FieldNumber_Wxid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info__storage_, wxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_NickName),
        .number = contact_info_FieldNumber_Nickname,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(contact_info__storage_, nickname),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "shortPy",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_PY_SHORT),
        .number = contact_info_FieldNumber_ShortPy,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(contact_info__storage_, shortPy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "quanpin",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_QuanPin),
        .number = contact_info_FieldNumber_Quanpin,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(contact_info__storage_, quanpin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sex",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Sex,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(contact_info__storage_, sex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag6",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag6,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag7",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag7,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag7),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Type,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(contact_info__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag9",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag9,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag9),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "remarkName",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_BeiZhu),
        .number = contact_info_FieldNumber_RemarkName,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(contact_info__storage_, remarkName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "realShortPy",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_REAL_PY_SHORT),
        .number = contact_info_FieldNumber_RealShortPy,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(contact_info__storage_, realShortPy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "realQuanpin",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_REAL_QuanPin),
        .number = contact_info_FieldNumber_RealQuanpin,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(contact_info__storage_, realQuanpin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tag13",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag13,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag13),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag14",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag14,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag14),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag16",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag16,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag16),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bChatRoom",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_BChatRoom,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(contact_info__storage_, bChatRoom),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag18",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag18,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag18),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sheng",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Sheng,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(contact_info__storage_, sheng),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "shi",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Shi,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(contact_info__storage_, shi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "qianming",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Qianming,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(contact_info__storage_, qianming),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag22",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag22,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag22),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag23",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag23,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag23),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "registerBodyType",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_RegisterBodyType,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(contact_info__storage_, registerBodyType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "registerBody",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_RegisterBody,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(contact_info__storage_, registerBody),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag26",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag26,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag26),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "src",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Src,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(contact_info__storage_, src),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastMsgTime",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_LastMsgTime,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(contact_info__storage_, lastMsgTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "alias",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Alias,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(contact_info__storage_, alias),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatroomOwnerWxid",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_ChatroomOwnerWxid,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(contact_info__storage_, chatroomOwnerWxid),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag33",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag33,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag33),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag34",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag34,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag34),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag35",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag35,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag35),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag37",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag37,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag37),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Country,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(contact_info__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarBig",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_AvatarBig,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(contact_info__storage_, avatarBig),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avatarSmall",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_AvatarSmall,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(contact_info__storage_, avatarSmall),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag42",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag42,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag42),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "v1Name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_V1Name,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(contact_info__storage_, v1Name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag50",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag50,
        .hasIndex = 38,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag50),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "chatroomServerVer",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_ChatroomServerVer,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(contact_info__storage_, chatroomServerVer),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "chatroomMaxMember",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_ChatroomMaxMember,
        .hasIndex = 40,
        .offset = (uint32_t)offsetof(contact_info__storage_, chatroomMaxMember),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag56",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag56,
        .hasIndex = 41,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag56),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "groupMemberList",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_GroupMemberList),
        .number = contact_info_FieldNumber_GroupMemberList,
        .hasIndex = 42,
        .offset = (uint32_t)offsetof(contact_info__storage_, groupMemberList),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tag58",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag58,
        .hasIndex = 43,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag58),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag62",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag62,
        .hasIndex = 44,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag62),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag64",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag64,
        .hasIndex = 45,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag64),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag65",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag65,
        .hasIndex = 46,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag65),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag66",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag66,
        .hasIndex = 47,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag66),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag67",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_FieldNumber_Tag67,
        .hasIndex = 48,
        .offset = (uint32_t)offsetof(contact_info__storage_, tag67),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\003\007\000\013\004\247\000\021\t\000\035\013\000\037\021\0005\010\251\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_NickName

@implementation contact_info_NickName

@dynamic hasName, name;

typedef struct contact_info_NickName__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} contact_info_NickName__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_NickName_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_NickName__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_NickName class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_NickName__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_PY_SHORT

@implementation contact_info_PY_SHORT

@dynamic hasName, name;

typedef struct contact_info_PY_SHORT__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} contact_info_PY_SHORT__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_PY_SHORT_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_PY_SHORT__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_PY_SHORT class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_PY_SHORT__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_QuanPin

@implementation contact_info_QuanPin

@dynamic hasName, name;

typedef struct contact_info_QuanPin__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} contact_info_QuanPin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_QuanPin_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_QuanPin__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_QuanPin class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_QuanPin__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_BeiZhu

@implementation contact_info_BeiZhu

@dynamic hasName, name;

typedef struct contact_info_BeiZhu__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} contact_info_BeiZhu__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_BeiZhu_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_BeiZhu__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_BeiZhu class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_BeiZhu__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_REAL_PY_SHORT

@implementation contact_info_REAL_PY_SHORT

@dynamic hasName, name;

typedef struct contact_info_REAL_PY_SHORT__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} contact_info_REAL_PY_SHORT__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_REAL_PY_SHORT_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_REAL_PY_SHORT__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_REAL_PY_SHORT class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_REAL_PY_SHORT__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_REAL_QuanPin

@implementation contact_info_REAL_QuanPin

@dynamic hasName, name;

typedef struct contact_info_REAL_QuanPin__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} contact_info_REAL_QuanPin__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_REAL_QuanPin_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_REAL_QuanPin__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_REAL_QuanPin class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_REAL_QuanPin__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_GroupMemberList

@implementation contact_info_GroupMemberList

@dynamic hasCnt, cnt;
@dynamic memberArray, memberArray_Count;
@dynamic hasTag3, tag3;
@dynamic hasTag4, tag4;

typedef struct contact_info_GroupMemberList__storage_ {
  uint32_t _has_storage_[1];
  int32_t cnt;
  int32_t tag3;
  NSMutableArray *memberArray;
  NSString *tag4;
} contact_info_GroupMemberList__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cnt",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_FieldNumber_Cnt,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList__storage_, cnt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "memberArray",
        .dataTypeSpecific.className = GPBStringifySymbol(contact_info_GroupMemberList_MemberInfo),
        .number = contact_info_GroupMemberList_FieldNumber_MemberArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList__storage_, memberArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tag3",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_FieldNumber_Tag3,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList__storage_, tag3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag4",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_FieldNumber_Tag4,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList__storage_, tag4),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_GroupMemberList class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_GroupMemberList__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - contact_info_GroupMemberList_MemberInfo

@implementation contact_info_GroupMemberList_MemberInfo

@dynamic hasWxid, wxid;
@dynamic hasNickName, nickName;
@dynamic hasTag6, tag6;
@dynamic hasInviteerWxid, inviteerWxid;
@dynamic hasTag8, tag8;

typedef struct contact_info_GroupMemberList_MemberInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t tag6;
  int32_t tag8;
  NSString *wxid;
  NSString *nickName;
  NSString *inviteerWxid;
} contact_info_GroupMemberList_MemberInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "wxid",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_MemberInfo_FieldNumber_Wxid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList_MemberInfo__storage_, wxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickName",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_MemberInfo_FieldNumber_NickName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList_MemberInfo__storage_, nickName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag6",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_MemberInfo_FieldNumber_Tag6,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList_MemberInfo__storage_, tag6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "inviteerWxid",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_MemberInfo_FieldNumber_InviteerWxid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList_MemberInfo__storage_, inviteerWxid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "tag8",
        .dataTypeSpecific.className = NULL,
        .number = contact_info_GroupMemberList_MemberInfo_FieldNumber_Tag8,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(contact_info_GroupMemberList_MemberInfo__storage_, tag8),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[contact_info_GroupMemberList_MemberInfo class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(contact_info_GroupMemberList_MemberInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(contact_info_GroupMemberList)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - common_msg

@implementation common_msg

@dynamic hasType, type;
@dynamic hasData_p, data_p;

typedef struct common_msg__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  common_msg_Data *data_p;
} common_msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = common_msg_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(common_msg__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = GPBStringifySymbol(common_msg_Data),
        .number = common_msg_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(common_msg__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[common_msg class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(common_msg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - common_msg_Data

@implementation common_msg_Data

@dynamic hasLen, len;
@dynamic hasData_p, data_p;

typedef struct common_msg_Data__storage_ {
  uint32_t _has_storage_[1];
  int32_t len;
  NSData *data_p;
} common_msg_Data__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "len",
        .dataTypeSpecific.className = NULL,
        .number = common_msg_Data_FieldNumber_Len,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(common_msg_Data__storage_, len),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = common_msg_Data_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(common_msg_Data__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[common_msg_Data class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(common_msg_Data__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(common_msg)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewInitResponse

@implementation NewInitResponse

@dynamic hasTag1, tag1;
@dynamic hasSyncKeyCur, syncKeyCur;
@dynamic hasSyncKeyMax, syncKeyMax;
@dynamic hasContinueFlag, continueFlag;
@dynamic hasCntList, cntList;
@dynamic tag7Array, tag7Array_Count;

typedef struct NewInitResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t continueFlag;
  int32_t cntList;
  NSString *tag1;
  NSData *syncKeyCur;
  NSData *syncKeyMax;
  NSMutableArray *tag7Array;
} NewInitResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tag1",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_Tag1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, tag1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "syncKeyCur",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_SyncKeyCur,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, syncKeyCur),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "syncKeyMax",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_SyncKeyMax,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, syncKeyMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "continueFlag",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_ContinueFlag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, continueFlag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cntList",
        .dataTypeSpecific.className = NULL,
        .number = NewInitResponse_FieldNumber_CntList,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, cntList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag7Array",
        .dataTypeSpecific.className = GPBStringifySymbol(common_msg),
        .number = NewInitResponse_FieldNumber_Tag7Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NewInitResponse__storage_, tag7Array),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewInitResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewInitResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\006\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NewSyncRequest

@implementation NewSyncRequest

@dynamic hasTag1, tag1;
@dynamic hasSelector, selector;
@dynamic hasKeyBuf, keyBuf;
@dynamic hasScene, scene;
@dynamic hasDeviceType, deviceType;
@dynamic hasSyncMsgDigest, syncMsgDigest;

typedef struct NewSyncRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t selector;
  int32_t scene;
  int32_t syncMsgDigest;
  NSString *tag1;
  NSData *keyBuf;
  NSString *deviceType;
} NewSyncRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tag1",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_Tag1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, tag1),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "selector",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_Selector,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, selector),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "keyBuf",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_KeyBuf,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, keyBuf),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "scene",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_Scene,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, scene),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_DeviceType,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, deviceType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "syncMsgDigest",
        .dataTypeSpecific.className = NULL,
        .number = NewSyncRequest_FieldNumber_SyncMsgDigest,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NewSyncRequest__storage_, syncMsgDigest),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NewSyncRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NewSyncRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\003\006\000\005\n\000\006\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - new_sync_resp

@implementation new_sync_resp

@dynamic hasTag1, tag1;
@dynamic hasMsg, msg;
@dynamic hasTag3, tag3;
@dynamic hasSyncKey, syncKey;
@dynamic hasTag5, tag5;
@dynamic hasTag6, tag6;
@dynamic hasUtc, utc;

typedef struct new_sync_resp__storage_ {
  uint32_t _has_storage_[1];
  int32_t tag1;
  int32_t tag3;
  int32_t tag5;
  int32_t tag6;
  int32_t utc;
  new_sync_resp_new_msg *msg;
  NSData *syncKey;
} new_sync_resp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "tag1",
        .dataTypeSpecific.className = NULL,
        .number = new_sync_resp_FieldNumber_Tag1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(new_sync_resp__storage_, tag1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "msg",
        .dataTypeSpecific.className = GPBStringifySymbol(new_sync_resp_new_msg),
        .number = new_sync_resp_FieldNumber_Msg,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(new_sync_resp__storage_, msg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "tag3",
        .dataTypeSpecific.className = NULL,
        .number = new_sync_resp_FieldNumber_Tag3,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(new_sync_resp__storage_, tag3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "syncKey",
        .dataTypeSpecific.className = NULL,
        .number = new_sync_resp_FieldNumber_SyncKey,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(new_sync_resp__storage_, syncKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "tag5",
        .dataTypeSpecific.className = NULL,
        .number = new_sync_resp_FieldNumber_Tag5,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(new_sync_resp__storage_, tag5),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag6",
        .dataTypeSpecific.className = NULL,
        .number = new_sync_resp_FieldNumber_Tag6,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(new_sync_resp__storage_, tag6),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "utc",
        .dataTypeSpecific.className = NULL,
        .number = new_sync_resp_FieldNumber_Utc,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(new_sync_resp__storage_, utc),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[new_sync_resp class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(new_sync_resp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - new_sync_resp_new_msg

@implementation new_sync_resp_new_msg

@dynamic hasCntList, cntList;
@dynamic tag2Array, tag2Array_Count;

typedef struct new_sync_resp_new_msg__storage_ {
  uint32_t _has_storage_[1];
  int32_t cntList;
  NSMutableArray *tag2Array;
} new_sync_resp_new_msg__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cntList",
        .dataTypeSpecific.className = NULL,
        .number = new_sync_resp_new_msg_FieldNumber_CntList,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(new_sync_resp_new_msg__storage_, cntList),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "tag2Array",
        .dataTypeSpecific.className = GPBStringifySymbol(common_msg),
        .number = new_sync_resp_new_msg_FieldNumber_Tag2Array,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(new_sync_resp_new_msg__storage_, tag2Array),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[new_sync_resp_new_msg class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(new_sync_resp_new_msg__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(new_sync_resp)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MicroMsgRequestNew

@implementation MicroMsgRequestNew

@dynamic hasToUserName, toUserName;
@dynamic hasContent, content;
@dynamic hasType, type;
@dynamic hasCreateTime, createTime;
@dynamic hasClientMsgId, clientMsgId;
@dynamic hasMsgSource, msgSource;

typedef struct MicroMsgRequestNew__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t createTime;
  SKBuiltinString_t *toUserName;
  NSString *content;
  NSString *msgSource;
  int64_t clientMsgId;
} MicroMsgRequestNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "toUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MicroMsgRequestNew_FieldNumber_ToUserName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, toUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_Type,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientMsgId",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_ClientMsgId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, clientMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "msgSource",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgRequestNew_FieldNumber_MsgSource,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MicroMsgRequestNew__storage_, msgSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MicroMsgRequestNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MicroMsgRequestNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\001\n\000\004\n\000\005\013\000\006\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMsgRequestNew

@implementation SendMsgRequestNew

@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct SendMsgRequestNew__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  NSMutableArray *listArray;
} SendMsgRequestNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = SendMsgRequestNew_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMsgRequestNew__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MicroMsgRequestNew),
        .number = SendMsgRequestNew_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendMsgRequestNew__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMsgRequestNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMsgRequestNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MicroMsgResponseNew

@implementation MicroMsgResponseNew

@dynamic hasRet, ret;
@dynamic hasToUserName, toUserName;
@dynamic hasMsgId, msgId;
@dynamic hasClientMsgId, clientMsgId;
@dynamic hasCreateTime, createTime;
@dynamic hasServerTime, serverTime;
@dynamic hasType, type;
@dynamic hasNewMsgId, newMsgId;

typedef struct MicroMsgResponseNew__storage_ {
  uint32_t _has_storage_[1];
  int32_t ret;
  int32_t msgId;
  int32_t clientMsgId;
  int32_t createTime;
  int32_t serverTime;
  int32_t type;
  SKBuiltinString_t *toUserName;
  int64_t newMsgId;
} MicroMsgResponseNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ret",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_Ret,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, ret),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "toUserName",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = MicroMsgResponseNew_FieldNumber_ToUserName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, toUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msgId",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_MsgId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, msgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientMsgId",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_ClientMsgId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, clientMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_CreateTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "serverTime",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_ServerTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, serverTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_Type,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "newMsgId",
        .dataTypeSpecific.className = NULL,
        .number = MicroMsgResponseNew_FieldNumber_NewMsgId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(MicroMsgResponseNew__storage_, newMsgId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MicroMsgResponseNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MicroMsgResponseNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\006\002\n\000\003\005\000\004\013\000\005\n\000\006\n\000\010\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendMsgResponseNew

@implementation SendMsgResponseNew

@dynamic hasBaseResponse, baseResponse;
@dynamic hasCount, count;
@dynamic listArray, listArray_Count;

typedef struct SendMsgResponseNew__storage_ {
  uint32_t _has_storage_[1];
  int32_t count;
  BaseResponse *baseResponse;
  NSMutableArray *listArray;
} SendMsgResponseNew__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = SendMsgResponseNew_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendMsgResponseNew__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = SendMsgResponseNew_FieldNumber_Count,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SendMsgResponseNew__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "listArray",
        .dataTypeSpecific.className = GPBStringifySymbol(MicroMsgResponseNew),
        .number = SendMsgResponseNew_FieldNumber_ListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SendMsgResponseNew__storage_, listArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendMsgResponseNew class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendMsgResponseNew__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckResUpdateRequest

@implementation CheckResUpdateRequest

@dynamic resIdArray, resIdArray_Count;

typedef struct CheckResUpdateRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *resIdArray;
} CheckResUpdateRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "resIdArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CheckResUpdateRequest_ResID),
        .number = CheckResUpdateRequest_FieldNumber_ResIdArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest__storage_, resIdArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckResUpdateRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckResUpdateRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000resId\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckResUpdateRequest_ResID

@implementation CheckResUpdateRequest_ResID

@dynamic hasType, type;
@dynamic subTypeVectorArray, subTypeVectorArray_Count;

typedef struct CheckResUpdateRequest_ResID__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSMutableArray *subTypeVectorArray;
} CheckResUpdateRequest_ResID__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "subTypeVectorArray",
        .dataTypeSpecific.className = GPBStringifySymbol(CheckResUpdateRequest_ResID_SubTypeVector),
        .number = CheckResUpdateRequest_ResID_FieldNumber_SubTypeVectorArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID__storage_, subTypeVectorArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckResUpdateRequest_ResID class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckResUpdateRequest_ResID__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000subTypeVector\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CheckResUpdateRequest)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CheckResUpdateRequest_ResID_SubTypeVector

@implementation CheckResUpdateRequest_ResID_SubTypeVector

@dynamic hasSubType, subType;
@dynamic hasKeyVersion, keyVersion;
@dynamic hasResVersion, resVersion;
@dynamic hasEid, eid;

typedef struct CheckResUpdateRequest_ResID_SubTypeVector__storage_ {
  uint32_t _has_storage_[1];
  int32_t subType;
  int32_t keyVersion;
  int32_t resVersion;
  int32_t eid;
} CheckResUpdateRequest_ResID_SubTypeVector__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "subType",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_SubTypeVector_FieldNumber_SubType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID_SubTypeVector__storage_, subType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "keyVersion",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_SubTypeVector_FieldNumber_KeyVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID_SubTypeVector__storage_, keyVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "resVersion",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_SubTypeVector_FieldNumber_ResVersion,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID_SubTypeVector__storage_, resVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "eid",
        .dataTypeSpecific.className = NULL,
        .number = CheckResUpdateRequest_ResID_SubTypeVector_FieldNumber_Eid,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(CheckResUpdateRequest_ResID_SubTypeVector__storage_, eid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CheckResUpdateRequest_ResID_SubTypeVector class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CheckResUpdateRequest_ResID_SubTypeVector__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\007\000\002\n\000\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(CheckResUpdateRequest_ResID)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsObject

@implementation SnsObject

@dynamic hasId_p, id_p;
@dynamic hasUsername, username;
@dynamic hasNickname, nickname;
@dynamic hasCreateTime, createTime;
@dynamic hasObjectDesc, objectDesc;
@dynamic hasExtFlag, extFlag;
@dynamic hasObjectOperations, objectOperations;

typedef struct SnsObject__storage_ {
  uint32_t _has_storage_[1];
  int32_t createTime;
  int32_t extFlag;
  NSString *username;
  NSString *nickname;
  SKBuiltinBuffer_t *objectDesc;
  SKBuiltinString_t *objectOperations;
  uint64_t id_p;
} SnsObject__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsObject__storage_, id_p),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "username",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_Username,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsObject__storage_, username),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "nickname",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_Nickname,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SnsObject__storage_, nickname),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SnsObject__storage_, createTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "objectDesc",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = SnsObject_FieldNumber_ObjectDesc,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SnsObject__storage_, objectDesc),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extFlag",
        .dataTypeSpecific.className = NULL,
        .number = SnsObject_FieldNumber_ExtFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SnsObject__storage_, extFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "objectOperations",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinString_t),
        .number = SnsObject_FieldNumber_ObjectOperations,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SnsObject__storage_, objectOperations),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsObject class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsObject__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\004\n\000\005\n\000\020\007\000\034\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsTimeLineRequest

@implementation SnsTimeLineRequest

@dynamic hasBaseRequest, baseRequest;
@dynamic hasFirstPageMd5, firstPageMd5;
@dynamic hasMinFilterId, minFilterId;
@dynamic hasMaxId, maxId;
@dynamic hasLastRequestTime, lastRequestTime;
@dynamic hasClientLatestId, clientLatestId;
@dynamic hasSession, session;
@dynamic hasNetworkType, networkType;
@dynamic hasAdexpinfo, adexpinfo;

typedef struct SnsTimeLineRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t minFilterId;
  int32_t maxId;
  int32_t lastRequestTime;
  int32_t networkType;
  BaseRequest *baseRequest;
  NSString *firstPageMd5;
  SKBuiltinBuffer_t *session;
  NSString *adexpinfo;
  int64_t clientLatestId;
} SnsTimeLineRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseRequest",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseRequest),
        .number = SnsTimeLineRequest_FieldNumber_BaseRequest,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, baseRequest),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "firstPageMd5",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_FirstPageMd5,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, firstPageMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "minFilterId",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_MinFilterId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, minFilterId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxId",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_MaxId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, maxId),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "lastRequestTime",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_LastRequestTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, lastRequestTime),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "clientLatestId",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_ClientLatestId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, clientLatestId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = GPBStringifySymbol(SKBuiltinBuffer_t),
        .number = SnsTimeLineRequest_FieldNumber_Session,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkType",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_NetworkType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, networkType),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "adexpinfo",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineRequest_FieldNumber_Adexpinfo,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SnsTimeLineRequest__storage_, adexpinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsTimeLineRequest class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsTimeLineRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\013\000\002\014\000\003\013\000\004\005\000\005\017\000\006\016\000\010\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsTimeLineResponse

@implementation SnsTimeLineResponse

@dynamic hasBaseResponse, baseResponse;
@dynamic hasFirstPageMd5, firstPageMd5;
@dynamic hasObjectCount, objectCount;
@dynamic objectListArray, objectListArray_Count;
@dynamic hasNewRequestTime, newRequestTime;
@dynamic hasObjectCountForSameMd5, objectCountForSameMd5;
@dynamic hasControlFlag, controlFlag;
@dynamic hasServerConfig, serverConfig;
@dynamic hasRecCount, recCount;
@dynamic hasSession, session;

typedef struct SnsTimeLineResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t objectCount;
  int32_t newRequestTime;
  int32_t objectCountForSameMd5;
  int32_t controlFlag;
  int32_t recCount;
  BaseResponse *baseResponse;
  NSString *firstPageMd5;
  NSMutableArray *objectListArray;
  SnsTimeLineResponse_SnsServerConfig *serverConfig;
  NSData *session;
} SnsTimeLineResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseResponse",
        .dataTypeSpecific.className = GPBStringifySymbol(BaseResponse),
        .number = SnsTimeLineResponse_FieldNumber_BaseResponse,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, baseResponse),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "firstPageMd5",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_FirstPageMd5,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, firstPageMd5),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "objectCount",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_ObjectCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, objectCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "objectListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(SnsObject),
        .number = SnsTimeLineResponse_FieldNumber_ObjectListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, objectListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newRequestTime",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_NewRequestTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, newRequestTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "objectCountForSameMd5",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_ObjectCountForSameMd5,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, objectCountForSameMd5),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "controlFlag",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_ControlFlag,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, controlFlag),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "serverConfig",
        .dataTypeSpecific.className = GPBStringifySymbol(SnsTimeLineResponse_SnsServerConfig),
        .number = SnsTimeLineResponse_FieldNumber_ServerConfig,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, serverConfig),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "recCount",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_RecCount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, recCount),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "session",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_FieldNumber_Session,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse__storage_, session),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsTimeLineResponse class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsTimeLineResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\t\001\014\000\002\014\000\003\013\000\004\000objectList\000\005\016\000\006\025\000\007\013\000\010\014\000\t\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SnsTimeLineResponse_SnsServerConfig

@implementation SnsTimeLineResponse_SnsServerConfig

@dynamic hasPostMentionLimit, postMentionLimit;
@dynamic hasCopyAndPasteWordLimit, copyAndPasteWordLimit;

typedef struct SnsTimeLineResponse_SnsServerConfig__storage_ {
  uint32_t _has_storage_[1];
  int32_t postMentionLimit;
  int32_t copyAndPasteWordLimit;
} SnsTimeLineResponse_SnsServerConfig__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "postMentionLimit",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_SnsServerConfig_FieldNumber_PostMentionLimit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse_SnsServerConfig__storage_, postMentionLimit),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "copyAndPasteWordLimit",
        .dataTypeSpecific.className = NULL,
        .number = SnsTimeLineResponse_SnsServerConfig_FieldNumber_CopyAndPasteWordLimit,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SnsTimeLineResponse_SnsServerConfig__storage_, copyAndPasteWordLimit),
        .flags = (GPBFieldFlags)(GPBFieldRequired | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SnsTimeLineResponse_SnsServerConfig class]
                                     rootClass:[MmRoot class]
                                          file:MmRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SnsTimeLineResponse_SnsServerConfig__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\020\000\002\025\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SnsTimeLineResponse)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
